// Чат функционал с списком чатов

const API_BASE = '';
let currentUser = null;
let currentChat = null;
let chats = [];
let friends = [];
let replyToMessage = null;  // Сообщение, на которое отвечаем
const replyKeyboardState = {
    chatId: null,
    markup: null,
    oneTime: false,
    resize: false,
    placeholder: '',
    originalPlaceholder: '',
    active: false
};
const LAST_CHAT_KEY = 'xipher_last_chat';
const PINNED_CHATS_KEY = 'xipher_pinned_chats';
const PINNED_SYNC_FLAG = 'xipher_pins_synced';
const PINNED_SYNC_INTERVAL_MS = 15000;
const MUTED_CHATS_KEY = 'xipher_muted_chats';
const HIDDEN_CHATS_KEY = 'xipher_hidden_chats';
const CHAT_LIST_PRIVACY_KEY = 'xipher_chat_list_privacy_blur';
const CHAT_FOLDERS_KEY = 'xipher_chat_folders';
const ACTIVE_FOLDER_KEY = 'xipher_active_folder';
const CHAT_FOLDERS_SYNC_FLAG = 'xipher_folders_synced';
const CHAT_FOLDERS_SYNC_INTERVAL_MS = 15000;
const NOTIF_DESKTOP_KEY = 'xipher_notif_desktop';
const NOTIF_SOUND_KEY = 'xipher_notif_sound';
const NOTIF_PREVIEW_KEY = 'xipher_notif_preview';
const NOTIF_CALL_SOUND_KEY = 'xipher_notif_call_sound';
const NOTIF_VIBRATION_KEY = 'xipher_notif_vibration';
const CALL_QUALITY_CONFIG = (typeof window !== 'undefined' && window.XIPHER_CALL_QUALITY) ? window.XIPHER_CALL_QUALITY : null;
const CALL_QUALITY_STORAGE_KEYS = (CALL_QUALITY_CONFIG && CALL_QUALITY_CONFIG.storageKeys) || {
    camera: 'xipher_call_quality_camera',
    screen: 'xipher_call_quality_screen'
};
const CALL_QUALITY_DEFAULTS = (CALL_QUALITY_CONFIG && CALL_QUALITY_CONFIG.defaults) || {
    camera: { resolution: 720, fps: 15 },
    screen: { resolution: 720, fps: 15 }
};
const CALL_QUALITY_RESOLUTION_OPTIONS = (CALL_QUALITY_CONFIG && CALL_QUALITY_CONFIG.resolutionOptions) || [360, 540, 720, 1080];
const CALL_QUALITY_FPS_OPTIONS = (CALL_QUALITY_CONFIG && CALL_QUALITY_CONFIG.fpsOptions) || [15, 30, 60];
const CALL_QUALITY_FREE_CAP = (CALL_QUALITY_CONFIG && CALL_QUALITY_CONFIG.freeCap) || { resolution: 720, fps: 15 };
const CALL_QUALITY_PREMIUM_CAP = (CALL_QUALITY_CONFIG && CALL_QUALITY_CONFIG.premiumCap) || { resolution: 1080, fps: 60 };
const QUIET_HOURS_FROM_KEY = 'xipher_quiet_hours_from';
const QUIET_HOURS_TO_KEY = 'xipher_quiet_hours_to';
const CHAT_NOTIF_RECENT_MS = 4000;
const CALL_NOTIF_RECENT_MS = 2000;
const FOLDER_LIMIT_FREE = 3;
const FOLDER_LIMIT_PREMIUM = 20;
const PIN_LIMIT_FREE = 3;
const PIN_LIMIT_PREMIUM = 10;
const CHANNEL_LIMIT_FREE = 250;
const CHANNEL_LIMIT_PREMIUM = 1000;
const PUBLIC_LINK_LIMIT_FREE = 5;
const PUBLIC_LINK_LIMIT_PREMIUM = 20;
const BUSINESS_HOURS_DEFAULTS = {
    mon: { enabled: true, start: '09:00', end: '18:00' },
    tue: { enabled: true, start: '09:00', end: '18:00' },
    wed: { enabled: true, start: '09:00', end: '18:00' },
    thu: { enabled: true, start: '09:00', end: '18:00' },
    fri: { enabled: true, start: '09:00', end: '18:00' },
    sat: { enabled: false, start: '10:00', end: '16:00' },
    sun: { enabled: false, start: '10:00', end: '16:00' }
};
const BUSINESS_DAY_KEYS = {
    mon: 'settings.business.day.mon',
    tue: 'settings.business.day.tue',
    wed: 'settings.business.day.wed',
    thu: 'settings.business.day.thu',
    fri: 'settings.business.day.fri',
    sat: 'settings.business.day.sat',
    sun: 'settings.business.day.sun'
};
const BUSINESS_DAY_ORDER = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
const BUSINESS_JS_DAY_KEYS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
const PREMIUM_ACTIVE_KEY = 'xipher_premium_active';
const PREMIUM_PLAN_KEY = 'xipher_premium_plan';
const PREMIUM_EXPIRES_KEY = 'xipher_premium_expires_at';
const PREMIUM_PAYMENT_LABEL_KEY = 'xipher_premium_payment_label';
const PREMIUM_PAYMENT_PLAN_KEY = 'xipher_premium_payment_plan';
const PREMIUM_PAYMENT_STARTED_KEY = 'xipher_premium_payment_started_at';
const PREMIUM_PAYMENT_STALE_MS = 10 * 60 * 1000;
const PREMIUM_PLAN_AMOUNTS = {
    trial: '9',
    month: '99',
    year: '499'
};
const PREMIUM_GIFT_PREFIX = '[[XIPHER_PREMIUM_GIFT]]';
const PREMIUM_GIFT_PLANS = {
    month: { months: 1, price: 99 },
    half: { months: 6, price: 299 },
    year: { months: 12, price: 499 }
};
const USER_AVATAR_URL_KEY_PREFIX = 'xipher_user_avatar_url:';
const SPOILER_PREFIX = '[spoiler]';
const SPOILER_WRAPPER = '||';
const IMAGE_EXTS = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'];
let hasRestoredSelection = false;
let pinnedChatKeys = new Set();
let mutedChatKeys = new Set();
let hiddenChatKeys = new Set();
let sessionsRenderSeq = 0;
let chatFolders = [];
let activeFolderId = 'all';
let editingFolderId = null;
let folderEditorSelection = new Set();
let pendingFolderAssignChat = null;
let folderAssignSelection = new Set();
let foldersSyncInFlight = false;
let lastFoldersSyncAt = 0;
let pinnedSyncInFlight = false;
let lastPinnedSyncAt = 0;
let pendingDeleteChat = null;
let mediaRecorder = null;   // Для записи голосовых сообщений
let audioChunks = [];        // Чанки аудио для записи
let selectedTtlSeconds = 0;
const VOICE_PLAYBACK_RATES = [1, 1.5, 2];
let voicePlaybackRate = 1;
let selectedPremiumPlan = 'trial';
let selectedPremiumGiftPlan = 'half';
let premiumPaymentState = null;
let premiumPaymentPlanPending = null;
let premiumPaymentContext = { mode: 'self', giftRecipient: null };
let premiumPaymentPoller = null;
let premiumPaymentTimer = null;
try {
    const storedRate = parseFloat(localStorage.getItem('xipher_voice_rate'));
    if (VOICE_PLAYBACK_RATES.includes(storedRate)) {
        voicePlaybackRate = storedRate;
    }
} catch (_) {}
let activityUpdateInterval = null;  // Интервал для обновления активности
let reportTargetMessage = null;
let ws = null;  // WebSocket соединение
let wsBuffer = ''; // Буфер для склейки/парсинга сообщений WS
let wsBufferTimer = null; // Таймер очистки буфера
const WS_BUFFER_TIMEOUT_MS = 2000; // Сколько ждём, чтобы достроить кадр
const wsSendQueue = []; // Очередь исходящих сообщений, если сокет временно недоступен
let isWsAuthed = false; // Флаг успешной авторизации по WS
const wsReadyResolvers = []; // Ожидающие промисы readiness
const READ_RECEIPTS_KEY = 'xipher_send_read_receipts';
const deliveredMessageIds = new Set();
const readMessageIds = new Set();
const messageTtlTimers = new Map();
const TYPING_SEND_THROTTLE_MS = 2000;
const TYPING_IDLE_TIMEOUT_MS = 2500;
const TYPING_DISPLAY_TIMEOUT_MS = 4500;
const TYPING_PENDING_TIMEOUT_MS = 2000;
const TYPING_PENDING_RETRY_MS = 300;
const typingSendState = {
    key: '',
    target: null,
    lastSentAt: 0,
    idleTimer: null,
    isTyping: false,
    pending: null,
    pendingTimer: null
};
const typingDisplayState = {
    key: '',
    users: new Map(),
    timers: new Map()
};
const chatNotificationState = {
    initialized: false,
    snapshot: new Map(),
    recentNotifiedAt: new Map()
};
const recentCallNotifications = new Map();

function getCurrentUserId() {
    return currentUser?.id || localStorage.getItem('xipher_user_id') || '';
}

function readLocalBool(key, fallback = false) {
    try {
        const value = localStorage.getItem(key);
        if (value === null) return fallback;
        return value === 'true';
    } catch (_) {
        return fallback;
    }
}

function parseTimeToMinutes(value) {
    if (!value || typeof value !== 'string') return null;
    const parts = value.split(':');
    if (parts.length < 2) return null;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    if (!Number.isFinite(hours) || !Number.isFinite(minutes)) return null;
    if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) return null;
    return (hours * 60) + minutes;
}

function isQuietHoursActive(now = new Date()) {
    const fromRaw = localStorage.getItem(QUIET_HOURS_FROM_KEY);
    const toRaw = localStorage.getItem(QUIET_HOURS_TO_KEY);
    const from = parseTimeToMinutes(fromRaw);
    const to = parseTimeToMinutes(toRaw);
    if (from === null || to === null) return false;
    if (from === to) return false;
    const minutes = now.getHours() * 60 + now.getMinutes();
    if (from < to) {
        return minutes >= from && minutes < to;
    }
    return minutes >= from || minutes < to;
}

function normalizeNotificationText(text, maxLen = 140) {
    if (!text) return '';
    let out = String(text).replace(/\s+/g, ' ').trim();
    if (out.length > maxLen) {
        out = out.slice(0, Math.max(0, maxLen - 3)) + '...';
    }
    return out;
}

function isChatMutedByParts(chatId, chatType) {
    const key = buildChatKeyFromParts(chatId, chatType || 'chat');
    return key ? mutedChatKeys.has(key) : false;
}

function shouldNotifyForChatTarget(chatId, chatType) {
    if (!chatId) return true;
    const active = getActiveChatSelection();
    if (!active || !active.id) return true;
    const normalizedType = normalizeChatType(chatType || 'chat');
    const activeType = normalizeChatType(active.type || 'chat');
    const isSameChat = String(active.id) === String(chatId) && activeType === normalizedType;
    if (!isSameChat) return true;
    return document.hidden;
}

function wasChatRecentlyNotified(chatId) {
    if (!chatId) return false;
    const key = String(chatId);
    const lastAt = chatNotificationState.recentNotifiedAt.get(key) || 0;
    if (!lastAt) return false;
    if (Date.now() - lastAt < CHAT_NOTIF_RECENT_MS) return true;
    chatNotificationState.recentNotifiedAt.delete(key);
    return false;
}

function markChatNotified(chatId) {
    if (!chatId) return;
    chatNotificationState.recentNotifiedAt.set(String(chatId), Date.now());
}

function shouldNotifyCall(key) {
    if (!key) return true;
    const lastAt = recentCallNotifications.get(key) || 0;
    if (lastAt && Date.now() - lastAt < CALL_NOTIF_RECENT_MS) return false;
    recentCallNotifications.set(key, Date.now());
    return true;
}

function showToastNotification(message, type = 'info') {
    if (!message || document.hidden) return;
    const manager = typeof notifications !== 'undefined' ? notifications : null;
    if (!manager) return;
    if (typeof manager[type] === 'function') {
        manager[type](message);
        return;
    }
    if (typeof manager.info === 'function') {
        manager.info(message);
    }
}

function showDesktopNotification({ title, body, tag, chatId, chatType }) {
    if (!readLocalBool(NOTIF_DESKTOP_KEY, false)) return;
    if (typeof Notification === 'undefined') return;
    if (Notification.permission !== 'granted') return;
    const safeTitle = normalizeNotificationText(title || 'Xipher', 80);
    const safeBody = normalizeNotificationText(body || '', 160);
    const options = {
        body: safeBody,
        icon: '/images/xipher-avatar.png'
    };
    options.silent = isQuietHoursActive();
    if (tag) options.tag = tag;
    if (chatId) {
        options.data = { chatId: String(chatId), chatType: chatType || 'chat' };
    }
    try {
        const notification = new Notification(safeTitle, options);
        notification.onclick = () => {
            try {
                window.focus();
            } catch (_) {}
            if (chatId && typeof openChatFromPush === 'function') {
                openChatFromPush(String(chatId), chatType || 'chat');
            }
            notification.close();
        };
    } catch (error) {
        console.warn('[Notifications] Desktop notification failed:', error);
    }
}

function maybeVibrate(pattern) {
    if (!readLocalBool(NOTIF_VIBRATION_KEY, false)) return;
    if (isQuietHoursActive()) return;
    if (!navigator?.vibrate) return;
    try {
        navigator.vibrate(pattern);
    } catch (_) {}
}

function emitNotification({ title, body, chatId, chatType, toastType = 'info', tag, vibratePattern }) {
    const safeTitle = normalizeNotificationText(title || 'Xipher', 80);
    const safeBody = normalizeNotificationText(body || '', 160);
    const toastText = safeBody ? `${safeTitle}: ${safeBody}` : safeTitle;
    showToastNotification(toastText, toastType);
    showDesktopNotification({ title: safeTitle, body: safeBody, chatId, chatType, tag });
    if (vibratePattern) {
        maybeVibrate(vibratePattern);
    }
}

function buildMessageNotificationBody(rawText) {
    if (!readLocalBool(NOTIF_PREVIEW_KEY, false)) {
        return 'Новое сообщение';
    }
    const preview = formatMessagePreviewText(rawText);
    return normalizeNotificationText(preview || 'Новое сообщение', 140);
}

function buildNameFromParts(source) {
    if (!source) return '';
    const first = typeof source.first_name === 'string' ? source.first_name.trim() : '';
    const last = typeof source.last_name === 'string' ? source.last_name.trim() : '';
    return [first, last].filter(Boolean).join(' ').trim();
}

function resolveEntityDisplayName(source, fallback = 'Пользователь') {
    if (!source) return fallback;
    const fromParts = buildNameFromParts(source);
    return source.display_name || fromParts || source.name || source.username || fallback;
}

function getChatDisplayName(chat) {
    if (!chat) return 'Пользователь';
    if (chat.is_saved_messages && chat.name) return chat.name;
    const fallback = chat.type === 'group' ? 'Группа' : (chat.type === 'channel' ? 'Канал' : 'Пользователь');
    return resolveEntityDisplayName(chat, fallback);
}

function getFriendDisplayName(friend) {
    return resolveEntityDisplayName(friend, 'Пользователь');
}

function getDisplayInitial(source, fallback = '?') {
    const name = resolveEntityDisplayName(source, '');
    const base = name || source?.name || source?.username || fallback;
    return String(base).charAt(0).toUpperCase();
}

function getChatSearchText(chat) {
    if (!chat) return '';
    const parts = [getChatDisplayName(chat), chat.name, chat.username].filter(Boolean);
    return parts.join(' ').toLowerCase();
}

function resolveChatDisplayName(chatId, fallbackName) {
    const targetId = String(chatId || '');
    const chat = (chats || []).find(item => String(item.id) === targetId);
    if (chat) return getChatDisplayName(chat);
    const friend = (friends || []).find(item => String(item.id || item.user_id) === targetId);
    if (friend) return getFriendDisplayName(friend);
    return fallbackName || 'Пользователь';
}

function notifyIncomingMessageFromPayload(payload, overrides = {}) {
    if (!payload) return;
    const senderId = payload.sender_id || payload.senderId || payload.from_user_id || payload.fromUserId || '';
    const currentId = getCurrentUserId();
    if (senderId && currentId && String(senderId) === String(currentId)) return;
    const chatType = normalizeChatType(overrides.chatType || payload.chat_type || payload.chatType || 'chat');
    let chatId = overrides.chatId || payload.chat_id || payload.chatId;
    if (!chatId && (chatType === 'chat' || !chatType)) {
        chatId = senderId;
    }
    if (!chatId) return;
    if (isChatMutedByParts(chatId, chatType)) return;
    if (!shouldNotifyForChatTarget(chatId, chatType)) return;
    const rawContent = typeof payload.content === 'string' ? payload.content : '';
    const body = buildMessageNotificationBody(rawContent);
    const title = resolveChatDisplayName(
        chatId,
        overrides.chatName || payload.sender_name || payload.sender_username || payload.from_username || payload.username
    );
    emitNotification({
        title,
        body,
        chatId,
        chatType,
        toastType: 'info',
        tag: `chat:${chatId}`,
        vibratePattern: [80, 40, 80]
    });
    markChatNotified(chatId);
}

function notifyIncomingCall(data) {
    if (!data) return;
    const fromId = data.from_user_id || data.fromUserId || '';
    if (!shouldNotifyCall(`call:${fromId || 'unknown'}`)) return;
    const callerName = resolveChatDisplayName(fromId, data.from_username || data.fromUsername);
    const callType = (data.call_type || data.callType || 'video').toLowerCase();
    const modeLabel = callType === 'audio' ? 'аудио' : 'видео';
    emitNotification({
        title: 'Входящий звонок',
        body: callerName ? `${callerName} • ${modeLabel}` : `Входящий ${modeLabel} звонок`,
        chatId: fromId,
        chatType: 'chat',
        toastType: 'warning',
        tag: `call:${fromId}`,
        vibratePattern: [200, 100, 200]
    });
}

function notifyIncomingGroupCall(data) {
    if (!data) return;
    const groupId = data.group_id || data.groupId || '';
    if (!groupId) return;
    if (!shouldNotifyCall(`group:${groupId}`)) return;
    const groupName = data.group_name || data.groupName || 'Группа';
    const callerName = data.from_username || data.fromUsername || 'Участник';
    const callType = (data.call_type || data.callType || 'video').toLowerCase();
    const modeLabel = callType === 'audio' ? 'аудио' : 'видео';
    emitNotification({
        title: `Звонок в группе ${groupName}`,
        body: `${callerName} • ${modeLabel}`,
        chatId: groupId,
        chatType: 'group',
        toastType: 'warning',
        tag: `group-call:${groupId}`,
        vibratePattern: [200, 100, 200]
    });
}

function buildChatSnapshot(chat) {
    return {
        unread: Number(chat?.unread || 0),
        lastMessage: typeof chat?.lastMessage === 'string' ? chat.lastMessage : '',
        time: chat?.time || ''
    };
}

function shouldNotifyForChatSnapshot(chat, prevSnapshot, nextSnapshot) {
    if (!chat || chat.is_saved_messages) return false;
    if (isChatMuted(chat)) return false;
    if (!shouldNotifyForChatTarget(chat.id, chat.type)) return false;
    const nextUnread = Number(nextSnapshot?.unread || 0);
    const prevUnread = Number(prevSnapshot?.unread || 0);
    if (nextUnread <= prevUnread) return false;
    return nextUnread > 0;
}

function notifyOnChatListUpdate(allItems) {
    if (!Array.isArray(allItems)) return;
    const directChats = allItems.filter(item => item && (item.type === 'chat' || !item.type) && !item.is_saved_messages);
    const activeIds = new Set();

    directChats.forEach(chat => {
        const chatId = String(chat.id || '');
        if (!chatId) return;
        activeIds.add(chatId);
        const nextSnapshot = buildChatSnapshot(chat);
        const prevSnapshot = chatNotificationState.snapshot.get(chatId);

        if (!chatNotificationState.initialized) {
            chatNotificationState.snapshot.set(chatId, nextSnapshot);
            return;
        }

        if (wasChatRecentlyNotified(chatId)) {
            chatNotificationState.snapshot.set(chatId, nextSnapshot);
            return;
        }

        if (shouldNotifyForChatSnapshot(chat, prevSnapshot, nextSnapshot)) {
            emitNotification({
                title: resolveChatDisplayName(chatId, getChatDisplayName(chat)),
                body: buildMessageNotificationBody(nextSnapshot.lastMessage),
                chatId,
                chatType: chat.type,
                toastType: 'info',
                tag: `chat:${chatId}`,
                vibratePattern: [80, 40, 80]
            });
            markChatNotified(chatId);
        }
        chatNotificationState.snapshot.set(chatId, nextSnapshot);
    });

    if (!chatNotificationState.initialized) {
        chatNotificationState.initialized = true;
    }

    if (chatNotificationState.snapshot.size) {
        for (const key of chatNotificationState.snapshot.keys()) {
            if (!activeIds.has(key)) {
                chatNotificationState.snapshot.delete(key);
                chatNotificationState.recentNotifiedAt.delete(key);
            }
        }
    }
}

function isReadReceiptsEnabled() {
    try {
        const stored = localStorage.getItem(READ_RECEIPTS_KEY);
        if (stored === null) return true;
        return stored === 'true';
    } catch (_) {
        return true;
    }
}

function setReadReceiptsEnabled(enabled) {
    try {
        localStorage.setItem(READ_RECEIPTS_KEY, enabled ? 'true' : 'false');
    } catch (_) {}
}

function isChatListPrivacyEnabled() {
    try {
        return localStorage.getItem(CHAT_LIST_PRIVACY_KEY) === 'true';
    } catch (_) {
        return false;
    }
}

function applyChatListPrivacyState(enabled) {
    document.body.classList.toggle('chat-privacy-mode', Boolean(enabled));
}

function setChatListPrivacyEnabled(enabled) {
    try {
        localStorage.setItem(CHAT_LIST_PRIVACY_KEY, enabled ? 'true' : 'false');
    } catch (_) {}
    applyChatListPrivacyState(enabled);
}

function isSpoilerPrefixContent(content) {
    return typeof content === 'string' && content.startsWith(SPOILER_PREFIX);
}

function parseSpoilerWrapper(content, allowEmpty = false) {
    if (typeof content !== 'string') return null;
    const trimmed = content.trim();
    if (trimmed.length < SPOILER_WRAPPER.length * 2) return null;
    if (!trimmed.startsWith(SPOILER_WRAPPER) || !trimmed.endsWith(SPOILER_WRAPPER)) return null;
    const inner = trimmed.slice(SPOILER_WRAPPER.length, -SPOILER_WRAPPER.length).trim();
    if (!inner && !allowEmpty) return null;
    return inner;
}

function parseSpoilerMarkup(content, options = {}) {
    const raw = typeof content === 'string' ? content : '';
    if (isSpoilerPrefixContent(raw)) {
        return { isSpoiler: true, content: raw.slice(SPOILER_PREFIX.length) };
    }
    const wrapped = parseSpoilerWrapper(raw, options.allowEmpty);
    if (wrapped !== null) {
        return { isSpoiler: true, content: wrapped };
    }
    return { isSpoiler: false, content: raw };
}

function isSpoilerContent(content) {
    return parseSpoilerMarkup(content).isSpoiler;
}

function stripSpoilerContent(content) {
    return parseSpoilerMarkup(content).content;
}

function encodeSpoilerContent(content) {
    const safe = typeof content === 'string' ? content : '';
    return isSpoilerPrefixContent(safe) ? safe : `${SPOILER_PREFIX}${safe}`;
}

function isImageFileName(name) {
    if (!name) return false;
    const ext = name.split('.').pop().toLowerCase();
    return IMAGE_EXTS.includes(ext);
}

function applySpoilerTextState(textEl, isSpoiler) {
    if (!textEl) return;
    if (!isSpoiler) {
        textEl.classList.remove('spoiler-blur', 'is-revealed');
        return;
    }
    textEl.classList.add('spoiler-blur');
}

const TTL_OPTIONS = [
    { seconds: 0, key: 'chat.ttl.off' },
    { seconds: 10, key: 'chat.ttl.10s' },
    { seconds: 3600, key: 'chat.ttl.1h' },
    { seconds: 86400, key: 'chat.ttl.1d' }
];

function getSelectedTtlSeconds() {
    return selectedTtlSeconds || 0;
}

window.getSelectedTtlSeconds = getSelectedTtlSeconds;

function normalizeEpochMs(value) {
    const n = Number(value);
    if (!Number.isFinite(n) || n <= 0) return 0;
    return n < 100000000000 ? n * 1000 : n;
}

function formatTtlRemaining(remainingMs) {
    const totalSeconds = Math.max(0, Math.ceil(remainingMs / 1000));
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    if (hours > 0) {
        return `${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }
    return `${minutes}:${String(seconds).padStart(2, '0')}`;
}

function ensureTtlElement(messageEl) {
    if (!messageEl) return null;
    const timeRow = messageEl.querySelector('.message-time');
    if (!timeRow) return null;
    let ttlEl = timeRow.querySelector('.message-ttl');
    if (!ttlEl) {
        ttlEl = document.createElement('span');
        ttlEl.className = 'message-ttl';
        timeRow.appendChild(ttlEl);
    }
    return ttlEl;
}

function clearMessageTtlTimer(messageKey) {
    if (!messageKey) return;
    const timerId = messageTtlTimers.get(messageKey);
    if (timerId) {
        clearInterval(timerId);
        messageTtlTimers.delete(messageKey);
    }
}

function startMessageTtlCountdown(messageEl) {
    if (!messageEl) return;
    const ttlSeconds = Number(messageEl.dataset.ttlSeconds || 0);
    const readTimestamp = Number(messageEl.dataset.readTimestamp || 0);
    if (!ttlSeconds || !readTimestamp) return;
    const messageKey = messageEl.dataset.messageId || messageEl.dataset.tempId;
    if (!messageKey) return;
    const expiresAt = readTimestamp + (ttlSeconds * 1000);
    messageEl.dataset.ttlExpiresAt = String(expiresAt);
    const ttlEl = ensureTtlElement(messageEl);
    if (!ttlEl) return;

    clearMessageTtlTimer(messageKey);
    const tick = () => {
        if (!document.body.contains(messageEl)) {
            clearMessageTtlTimer(messageKey);
            return;
        }
        const remaining = expiresAt - Date.now();
        if (remaining <= 0) {
            clearMessageTtlTimer(messageKey);
            messageEl.remove();
            return;
        }
        ttlEl.textContent = `TTL ${formatTtlRemaining(remaining)}`;
        ttlEl.style.display = 'inline-flex';
    };
    tick();
    const timerId = setInterval(tick, 1000);
    messageTtlTimers.set(messageKey, timerId);
}

function applyMessageTtlData(messageEl, msg) {
    if (!messageEl || !msg) return;
    const ttlSeconds = Number(msg.ttl_seconds ?? msg.ttlSeconds ?? 0);
    if (ttlSeconds > 0) {
        messageEl.dataset.ttlSeconds = String(ttlSeconds);
    } else {
        delete messageEl.dataset.ttlSeconds;
    }
    const readTimestamp = normalizeEpochMs(msg.read_timestamp ?? msg.readTimestamp ?? 0);
    if (readTimestamp > 0) {
        messageEl.dataset.readTimestamp = String(readTimestamp);
    }
    const ttlEl = ensureTtlElement(messageEl);
    if (!ttlSeconds || !ttlEl) {
        if (ttlEl) {
            ttlEl.textContent = '';
            ttlEl.style.display = 'none';
        }
        return;
    }
    if (readTimestamp > 0) {
        startMessageTtlCountdown(messageEl);
    } else {
        ttlEl.textContent = '';
        ttlEl.style.display = 'none';
    }
}

function markMessageReadLocal(messageId, messageEl) {
    const target = messageEl || document.getElementById(`msg-${messageId}`) || document.querySelector(`[data-message-id="${messageId}"]`);
    if (!target) return;
    const ttlSeconds = Number(target.dataset.ttlSeconds || 0);
    if (!ttlSeconds) return;
    if (!target.dataset.readTimestamp) {
        target.dataset.readTimestamp = String(Date.now());
    }
    startMessageTtlCountdown(target);
}

function sendReceipt(type, messageId) {
    const token = localStorage.getItem('xipher_token');
    if (!token || !messageId) return;
    if (!ws || ws.readyState !== WebSocket.OPEN) {
        if (!ws || ws.readyState === WebSocket.CLOSED) {
            connectWebSocket();
        }
    }
    sendWebSocketMessage({
        type,
        token,
        message_id: messageId
    });
}

function sendDeliveryReceipt(messageId) {
    if (!messageId || deliveredMessageIds.has(messageId)) return;
    deliveredMessageIds.add(messageId);
    sendReceipt('message_delivered', messageId);
}

function sendReadReceipt(messageId) {
    if (!isReadReceiptsEnabled()) return;
    if (!messageId || readMessageIds.has(messageId)) return;
    readMessageIds.add(messageId);
    sendReceipt('message_read', messageId);
}

function resolveMessageStatus(msg, isSent) {
    if (!isSent) return '';
    if (msg && msg.status) return msg.status;
    if (msg && msg.is_read) return 'read';
    if (msg && msg.is_delivered) return 'delivered';
    if (msg && msg.temp_id) return 'sent';
    return 'delivered';
}

function applyMessageStatus(statusEl, status) {
    if (!statusEl) return;
    if (!status) {
        statusEl.textContent = '';
        statusEl.dataset.status = '';
        statusEl.style.display = 'none';
        return;
    }
    statusEl.dataset.status = status;
    statusEl.style.display = 'inline-flex';
    statusEl.textContent = status === 'sent' ? '✓' : '✓✓';
}

function setMessageStatus(messageId, status) {
    if (!messageId) return;
    const messageEl = document.getElementById(`msg-${messageId}`) || document.querySelector(`[data-message-id="${messageId}"]`);
    if (!messageEl) return;
    let statusEl = messageEl.querySelector('.message-status');
    if (!statusEl) {
        const timeEl = messageEl.querySelector('.message-time');
        if (!timeEl) return;
        statusEl = document.createElement('span');
        statusEl.className = 'message-status';
        timeEl.appendChild(statusEl);
    }
    applyMessageStatus(statusEl, status);
    if (status === 'read') {
        markMessageReadLocal(messageId, messageEl);
    }
}

function getAvatarStorageKey(userId) {
    const resolvedId = userId || getCurrentUserId();
    return resolvedId ? `${USER_AVATAR_URL_KEY_PREFIX}${resolvedId}` : '';
}

function getStoredAvatarUrl(userId) {
    const key = getAvatarStorageKey(userId);
    if (!key) return '';
    try {
        return localStorage.getItem(key) || '';
    } catch (_) {
        return '';
    }
}

function setStoredAvatarUrl(userId, avatarUrl) {
    const key = getAvatarStorageKey(userId);
    if (!key) return;
    try {
        if (avatarUrl) {
            localStorage.setItem(key, avatarUrl);
        } else {
            localStorage.removeItem(key);
        }
    } catch (_) {}
}

function resolveWsReady() {
    while (wsReadyResolvers.length) {
        const fn = wsReadyResolvers.shift();
        try { fn(); } catch (_) {}
    }
}

function clearReplyState() {
    replyToMessage = null;
    const replyPreview = document.getElementById('replyPreview');
    if (replyPreview) {
        replyPreview.style.display = 'none';
    }
    const replyPreviewText = document.getElementById('replyPreviewText');
    if (replyPreviewText) {
        replyPreviewText.textContent = '';
    }
}

window.clearReplyState = clearReplyState;

function normalizeTypingChatType(type) {
    if (!type) return 'chat';
    if (type === 'direct' || type === 'dm') return 'chat';
    return type;
}

function getActiveTypingTarget() {
    const channel = window.channelsModule?.currentChannel?.();
    if (window.channelsModule?.isChannelActive?.() && channel?.id) {
        return { chat_type: 'channel', chat_id: channel.id };
    }
    const group = window.groupsModule?.currentGroup?.();
    if (window.groupsModule?.isGroupActive?.() && group?.id) {
        return { chat_type: 'group', chat_id: group.id };
    }
    if (currentChat && currentChat.id && !currentChat.is_saved_messages) {
        return { chat_type: 'chat', chat_id: currentChat.id };
    }
    return null;
}

function setChatHeaderStatusBase(text, color = '') {
    const statusElement = document.getElementById('chatHeaderStatus');
    if (!statusElement) return;
    statusElement.dataset.baseText = text || '';
    statusElement.dataset.baseColor = color || '';
    if (!statusElement.classList.contains('is-typing')) {
        statusElement.textContent = text || '';
        statusElement.style.color = color || '';
    }
}

function applyChatHeaderStatusBase() {
    const statusElement = document.getElementById('chatHeaderStatus');
    if (!statusElement) return;
    const baseText = statusElement.dataset.baseText || statusElement.textContent || '';
    const baseColor = statusElement.dataset.baseColor || '';
    statusElement.classList.remove('is-typing');
    statusElement.textContent = baseText;
    statusElement.style.color = baseColor;
}

function buildTypingStatusText(names, chatType) {
    if (chatType === 'group') {
        if (names.length === 1) {
            return formatTemplate(t('chat.typingWithName'), { name: names[0] });
        }
        if (names.length > 1) {
            return formatTemplate(t('chat.typingMany'), { count: names.length });
        }
    }
    return t('chat.typing');
}

function renderTypingIndicator(names, chatType) {
    const statusElement = document.getElementById('chatHeaderStatus');
    if (!statusElement) return;
    statusElement.classList.add('is-typing');
    statusElement.style.color = '';
    statusElement.textContent = '';

    const textSpan = document.createElement('span');
    textSpan.className = 'typing-text';
    textSpan.textContent = buildTypingStatusText(names, chatType);

    const dots = document.createElement('span');
    dots.className = 'typing-dots';
    for (let i = 0; i < 3; i += 1) {
        dots.appendChild(document.createElement('span'));
    }

    statusElement.appendChild(textSpan);
    statusElement.appendChild(dots);
}

function updateTypingIndicatorDisplay() {
    if (!typingDisplayState.key) {
        applyChatHeaderStatusBase();
        return;
    }
    const names = Array.from(typingDisplayState.users.values()).filter(Boolean);
    if (!typingDisplayState.users.size) {
        applyChatHeaderStatusBase();
        return;
    }
    const [chatType] = typingDisplayState.key.split(':');
    renderTypingIndicator(names, chatType);
}

function clearTypingIndicator() {
    typingDisplayState.timers.forEach((timer) => clearTimeout(timer));
    typingDisplayState.timers.clear();
    typingDisplayState.users.clear();
    typingDisplayState.key = '';
    updateTypingIndicatorDisplay();
}

function sendTypingSignal(target, isTyping) {
    if (!target) return;
    const token = localStorage.getItem('xipher_token');
    if (!token) return;
    const payload = {
        type: 'typing',
        token,
        chat_type: target.chat_type,
        chat_id: target.chat_id,
        is_typing: isTyping ? '1' : '0'
    };
    if (!ws || ws.readyState === WebSocket.CLOSED) {
        connectWebSocket();
    }
    if (!ws || ws.readyState !== WebSocket.OPEN) {
        typingSendState.pending = { payload, queuedAt: Date.now() };
        schedulePendingTypingSend();
        return;
    }
    sendTypingPayload(payload);
}

function sendTypingPayload(payload) {
    if (!payload || !ws || ws.readyState !== WebSocket.OPEN) return;
    try {
        ws.send(JSON.stringify(payload));
    } catch (e) {
        console.warn('[WebSocket] typing send failed', e);
    }
}

function schedulePendingTypingSend() {
    if (typingSendState.pendingTimer) return;
    typingSendState.pendingTimer = setTimeout(() => {
        typingSendState.pendingTimer = null;
        const pending = typingSendState.pending;
        if (!pending) return;
        if (Date.now() - pending.queuedAt > TYPING_PENDING_TIMEOUT_MS) {
            typingSendState.pending = null;
            return;
        }
        if (!ws || ws.readyState !== WebSocket.OPEN) {
            schedulePendingTypingSend();
            return;
        }
        sendTypingPayload(pending.payload);
        typingSendState.pending = null;
    }, TYPING_PENDING_RETRY_MS);
}

function stopTypingForCurrentTarget() {
    if (typingSendState.idleTimer) {
        clearTimeout(typingSendState.idleTimer);
        typingSendState.idleTimer = null;
    }
    if (typingSendState.pendingTimer) {
        clearTimeout(typingSendState.pendingTimer);
        typingSendState.pendingTimer = null;
    }
    typingSendState.pending = null;
    if (!typingSendState.isTyping || !typingSendState.target) {
        typingSendState.isTyping = false;
        typingSendState.target = null;
        typingSendState.key = '';
        typingSendState.lastSentAt = 0;
        return;
    }
    sendTypingSignal(typingSendState.target, false);
    typingSendState.isTyping = false;
    typingSendState.target = null;
    typingSendState.key = '';
    typingSendState.lastSentAt = 0;
}

function handleTypingInput(value) {
    const target = getActiveTypingTarget();
    if (!target) {
        stopTypingForCurrentTarget();
        return;
    }

    const key = `${target.chat_type}:${target.chat_id}`;
    if (typingSendState.key && typingSendState.key !== key) {
        stopTypingForCurrentTarget();
    }
    typingSendState.key = key;
    typingSendState.target = target;

    const trimmed = typeof value === 'string' ? value.trim() : '';
    if (!trimmed) {
        stopTypingForCurrentTarget();
        return;
    }

    const now = Date.now();
    if (!typingSendState.isTyping || now - typingSendState.lastSentAt > TYPING_SEND_THROTTLE_MS) {
        sendTypingSignal(target, true);
        typingSendState.isTyping = true;
        typingSendState.lastSentAt = now;
    }

    if (typingSendState.idleTimer) {
        clearTimeout(typingSendState.idleTimer);
    }
    typingSendState.idleTimer = setTimeout(() => {
        sendTypingSignal(target, false);
        typingSendState.isTyping = false;
        typingSendState.idleTimer = null;
    }, TYPING_IDLE_TIMEOUT_MS);
}

function handleTypingEvent(data) {
    if (!data) return;
    const chatType = normalizeTypingChatType(data.chat_type || data.chatType);
    const chatId = data.chat_id || data.chatId || '';
    if (!chatType || !chatId) return;

    const activeTarget = getActiveTypingTarget();
    if (!activeTarget) return;
    if (currentChat?.is_saved_messages) return;

    const activeKey = `${activeTarget.chat_type}:${activeTarget.chat_id}`;
    const eventKey = `${chatType}:${chatId}`;
    if (eventKey !== activeKey) return;

    const senderId = data.from_user_id || data.user_id || '';
    if (senderId && senderId === getCurrentUserId()) return;

    const isTyping = !('is_typing' in data) || data.is_typing === true || data.is_typing === 1
        || data.is_typing === '1' || data.is_typing === 'true' || data.is_typing === 'yes';
    const displayName = data.from_username || data.username || '';
    const userKey = senderId || displayName || 'unknown';

    if (!isTyping) {
        if (typingDisplayState.timers.has(userKey)) {
            clearTimeout(typingDisplayState.timers.get(userKey));
            typingDisplayState.timers.delete(userKey);
        }
        typingDisplayState.users.delete(userKey);
        updateTypingIndicatorDisplay();
        return;
    }

    if (typingDisplayState.key && typingDisplayState.key !== eventKey) {
        clearTypingIndicator();
    }
    typingDisplayState.key = eventKey;
    typingDisplayState.users.set(userKey, displayName);

    if (typingDisplayState.timers.has(userKey)) {
        clearTimeout(typingDisplayState.timers.get(userKey));
    }
    const timer = setTimeout(() => {
        typingDisplayState.users.delete(userKey);
        typingDisplayState.timers.delete(userKey);
        updateTypingIndicatorDisplay();
    }, TYPING_DISPLAY_TIMEOUT_MS);
    typingDisplayState.timers.set(userKey, timer);
    updateTypingIndicatorDisplay();
}

function clearTypingForMessageSender(messagePayload, normalizedChatType, resolvedChatId, isSentByCurrent) {
    if (isSentByCurrent) return;
    if (!typingDisplayState.key) return;
    if (!resolvedChatId) return;
    const eventKey = `${normalizedChatType}:${resolvedChatId}`;
    if (typingDisplayState.key !== eventKey) return;

    if (normalizedChatType === 'chat' || normalizedChatType === 'saved') {
        clearTypingIndicator();
        return;
    }

    const senderId = messagePayload.sender_id || messagePayload.senderId || messagePayload.from_user_id || messagePayload.user_id || '';
    const senderName = messagePayload.sender_username || messagePayload.sender_name || messagePayload.from_username || messagePayload.username || '';
    const keys = [];
    if (senderId) keys.push(String(senderId));
    if (senderName) keys.push(String(senderName));
    if (!keys.length) return;

    let changed = false;
    keys.forEach((key) => {
        if (typingDisplayState.timers.has(key)) {
            clearTimeout(typingDisplayState.timers.get(key));
            typingDisplayState.timers.delete(key);
        }
        if (typingDisplayState.users.delete(key)) {
            changed = true;
        }
    });
    if (changed) {
        updateTypingIndicatorDisplay();
    }
}

window.setChatHeaderStatusBase = setChatHeaderStatusBase;
window.clearTypingIndicator = clearTypingIndicator;
window.stopTypingForCurrentTarget = stopTypingForCurrentTarget;

function readChatKeySet(key) {
    try {
        const raw = localStorage.getItem(key);
        if (!raw) return new Set();
        const list = JSON.parse(raw);
        if (!Array.isArray(list)) return new Set();
        return new Set(list.map(String));
    } catch (_) {
        return new Set();
    }
}

function writeChatKeySet(key, set) {
    try {
        localStorage.setItem(key, JSON.stringify(Array.from(set)));
    } catch (_) {}
}

function formatTemplate(text, vars) {
    if (!text) return '';
    return Object.keys(vars || {}).reduce((out, key) => {
        return out.replace(new RegExp(`\\{${key}\\}`, 'g'), String(vars[key]));
    }, text);
}

function parseTimeToMinutes(value) {
    if (typeof value !== 'string') return null;
    const match = value.match(/^([01]?\\d|2[0-3]):([0-5]\\d)$/);
    if (!match) return null;
    const hours = parseInt(match[1], 10);
    const minutes = parseInt(match[2], 10);
    if (!Number.isFinite(hours) || !Number.isFinite(minutes)) return null;
    return hours * 60 + minutes;
}

function formatOpenCountdown(totalMinutes) {
    const minutes = Math.max(1, Math.round(totalMinutes));
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    const lang = getLanguage();
    if (lang === 'en') {
        if (hours > 0 && mins > 0) return `${hours}h ${mins}m`;
        if (hours > 0) return `${hours}h`;
        return `${mins}m`;
    }
    if (hours > 0 && mins > 0) return `${hours} ч ${mins} мин`;
    if (hours > 0) return `${hours} ч`;
    return `${mins} мин`;
}

function parsePremiumDate(value) {
    if (!value) return null;
    if (value instanceof Date) return value;
    const direct = new Date(value);
    if (!Number.isNaN(direct.getTime())) return direct;
    const normalized = value.replace(' ', 'T');
    const normalizedDate = new Date(normalized);
    if (!Number.isNaN(normalizedDate.getTime())) return normalizedDate;
    if (!normalized.endsWith('Z') && !normalized.includes('+')) {
        const withZ = new Date(`${normalized}Z`);
        if (!Number.isNaN(withZ.getTime())) return withZ;
    }
    return null;
}

function formatPremiumExpiryDate(value) {
    const date = parsePremiumDate(value);
    if (!date) return '';
    const locale = getLanguage() === 'en' ? 'en-US' : 'ru-RU';
    return new Intl.DateTimeFormat(locale, {
        day: '2-digit',
        month: 'short',
        year: 'numeric'
    }).format(date);
}

function createPremiumBadge(size = 'small') {
    const badge = document.createElement('span');
    badge.className = size === 'large' ? 'premium-badge premium-badge--large' : 'premium-badge';
    badge.textContent = '★';
    badge.setAttribute('data-i18n-title', 'premium.badge');
    badge.title = t('premium.badge');
    badge.setAttribute('aria-label', t('premium.badge'));
    return badge;
}

function isPremiumActive() {
    if (currentUser && typeof currentUser.is_premium === 'boolean') {
        return currentUser.is_premium;
    }
    try {
        return localStorage.getItem(PREMIUM_ACTIVE_KEY) === 'true';
    } catch (_) {
        return false;
    }
}

function getPremiumPlan() {
    if (currentUser && typeof currentUser.premium_plan === 'string') {
        return currentUser.premium_plan;
    }
    try {
        return localStorage.getItem(PREMIUM_PLAN_KEY) || '';
    } catch (_) {
        return '';
    }
}

function normalizePremiumPlan(plan) {
    if (plan === 'year' || plan === 'month' || plan === 'trial') return plan;
    return 'month';
}

function mapPremiumPlanForUI(plan) {
    if (plan === 'half') return 'month';
    if (plan === 'year' || plan === 'month' || plan === 'trial') return plan;
    return '';
}

function normalizePremiumGiftPlan(plan) {
    if (plan === 'month' || plan === 'half' || plan === 'year') return plan;
    return 'half';
}

function getPremiumGiftPlanConfig(plan) {
    const key = normalizePremiumGiftPlan(plan);
    return PREMIUM_GIFT_PLANS[key] || PREMIUM_GIFT_PLANS.half;
}

function formatPremiumGiftDuration(months) {
    const value = Number(months);
    if (!Number.isFinite(value) || value <= 0) return '';
    const lang = getLanguage();
    if (lang === 'en') {
        if (value >= 12) return '1 year';
        return value === 1 ? '1 month' : `${value} months`;
    }
    if (value >= 12) return '1 год';
    if (value % 10 === 1 && value % 100 !== 11) return `${value} месяц`;
    if (value % 10 >= 2 && value % 10 <= 4 && (value % 100 < 12 || value % 100 > 14)) {
        return `${value} месяца`;
    }
    return `${value} месяцев`;
}

function formatPremiumGiftPrice(price) {
    const value = Number(price);
    if (!Number.isFinite(value) || value <= 0) return '';
    return `${value} ₽`;
}

function getPremiumExpiry() {
    if (currentUser && typeof currentUser.premium_expires_at === 'string') {
        return currentUser.premium_expires_at;
    }
    try {
        return localStorage.getItem(PREMIUM_EXPIRES_KEY) || '';
    } catch (_) {
        return '';
    }
}

function getPendingPremiumPayment() {
    try {
        const label = localStorage.getItem(PREMIUM_PAYMENT_LABEL_KEY) || '';
        if (!label) return null;
        const plan = localStorage.getItem(PREMIUM_PAYMENT_PLAN_KEY) || '';
        const startedRaw = localStorage.getItem(PREMIUM_PAYMENT_STARTED_KEY);
        let startedAt = Number(startedRaw);
        if (!Number.isFinite(startedAt) || startedAt <= 0) {
            startedAt = Date.now();
        }
        if (Date.now() - startedAt > PREMIUM_PAYMENT_STALE_MS) {
            clearPendingPremiumPayment();
            return null;
        }
        return { label, plan, startedAt };
    } catch (_) {
        return null;
    }
}

function setPendingPremiumPayment(payment) {
    if (!payment || !payment.label) return;
    try {
        localStorage.setItem(PREMIUM_PAYMENT_LABEL_KEY, payment.label);
        if (payment.plan) {
            localStorage.setItem(PREMIUM_PAYMENT_PLAN_KEY, payment.plan);
        } else {
            localStorage.removeItem(PREMIUM_PAYMENT_PLAN_KEY);
        }
        localStorage.setItem(PREMIUM_PAYMENT_STARTED_KEY, String(Date.now()));
    } catch (_) {}
}

function setPremiumPaymentContext(context = {}) {
    premiumPaymentContext = {
        mode: context.mode === 'gift' ? 'gift' : 'self',
        giftRecipient: context.giftRecipient || null
    };
}

function resetPremiumPaymentContext() {
    premiumPaymentContext = { mode: 'self', giftRecipient: null };
}

function clearPendingPremiumPayment() {
    try {
        localStorage.removeItem(PREMIUM_PAYMENT_LABEL_KEY);
        localStorage.removeItem(PREMIUM_PAYMENT_PLAN_KEY);
        localStorage.removeItem(PREMIUM_PAYMENT_STARTED_KEY);
    } catch (_) {}
    stopPremiumPaymentTimer();
}

function resetPendingPremiumPaymentState() {
    if (!getPendingPremiumPayment()) return;
    clearPendingPremiumPayment();
    stopPremiumPaymentPolling();
    updatePremiumPaymentStatusUI();
}

function formatPremiumWaitTime(ms) {
    const totalSeconds = Math.max(0, Math.floor(ms / 1000));
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    if (hours > 0) {
        return `${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }
    return `${minutes}:${String(seconds).padStart(2, '0')}`;
}

function updatePremiumPaymentTimer() {
    const timerEl = document.getElementById('premiumPaymentTimer');
    if (!timerEl) return;
    const pending = getPendingPremiumPayment();
    if (!pending || !pending.startedAt) return;
    const elapsed = Date.now() - pending.startedAt;
    timerEl.textContent = formatTemplate(t('settings.premium.payment.timer'), {
        time: formatPremiumWaitTime(elapsed)
    });
}

function stopPremiumPaymentTimer() {
    if (premiumPaymentTimer) {
        clearInterval(premiumPaymentTimer);
        premiumPaymentTimer = null;
    }
}

function startPremiumPaymentTimer() {
    stopPremiumPaymentTimer();
    updatePremiumPaymentTimer();
    premiumPaymentTimer = setInterval(updatePremiumPaymentTimer, 1000);
}

function updatePremiumPaymentStatusUI() {
    const statusEl = document.getElementById('premiumPaymentStatus');
    const timerEl = document.getElementById('premiumPaymentTimer');
    if (!statusEl || !timerEl) return;

    const isPremium = isPremiumActive();
    const pending = getPendingPremiumPayment();

    if (isPremium) {
        statusEl.textContent = t('settings.premium.payment.status.paid');
        statusEl.classList.add('is-success');
        statusEl.classList.remove('is-pending');
        statusEl.style.display = 'inline-flex';
        timerEl.style.display = 'none';
        stopPremiumPaymentTimer();
        return;
    }

    if (pending && pending.label) {
        statusEl.textContent = t('settings.premium.payment.status.pending');
        statusEl.classList.add('is-pending');
        statusEl.classList.remove('is-success');
        statusEl.style.display = 'inline-flex';
        statusEl.style.cursor = 'pointer';
        timerEl.style.display = 'inline-flex';
        timerEl.style.cursor = 'pointer';
        startPremiumPaymentTimer();
        return;
    }

    statusEl.textContent = '';
    statusEl.style.display = 'none';
    statusEl.classList.remove('is-pending', 'is-success');
    statusEl.style.cursor = 'default';
    timerEl.textContent = '';
    timerEl.style.display = 'none';
    timerEl.style.cursor = 'default';
    stopPremiumPaymentTimer();
}

function getFolderLimit() {
    return isPremiumActive() ? FOLDER_LIMIT_PREMIUM : FOLDER_LIMIT_FREE;
}

function getFolderUsage() {
    return Array.isArray(chatFolders) ? chatFolders.length : 0;
}

function canCreateFolder() {
    return getFolderUsage() < getFolderLimit();
}

function updatePremiumUI() {
    const isPremium = isPremiumActive();
    const used = getFolderUsage();
    const limit = getFolderLimit();
    const remaining = Math.max(0, limit - used);

    const statusPill = document.getElementById('premiumStatusPill');
    if (statusPill) {
        statusPill.textContent = t(isPremium ? 'settings.premium.status.active' : 'settings.premium.status.free');
        statusPill.classList.toggle('active', isPremium);
    }

    const limitNote = document.getElementById('premiumFolderLimitNote');
    if (limitNote) {
        const key = isPremium
            ? 'folders.limit.active'
            : (used >= limit ? 'folders.limit.reached' : 'folders.limit.free');
        limitNote.textContent = formatTemplate(t(key), {
            limit,
            used,
            remaining,
            limitPremium: FOLDER_LIMIT_PREMIUM
        });
    }

    const expiryNote = document.getElementById('premiumExpiryNote');
    if (expiryNote) {
        const expiryValue = getPremiumExpiry();
        const formattedExpiry = formatPremiumExpiryDate(expiryValue);
        if (isPremium && formattedExpiry) {
            expiryNote.textContent = formatTemplate(t('settings.premium.expires'), { date: formattedExpiry });
            expiryNote.style.display = 'inline-flex';
        } else {
            expiryNote.textContent = '';
            expiryNote.style.display = 'none';
        }
    }

    const limitValue = document.getElementById('premiumFolderLimitValue');
    if (limitValue) limitValue.textContent = String(limit);
    const usedValue = document.getElementById('premiumFolderUsedValue');
    if (usedValue) usedValue.textContent = String(used);
    const remainingValue = document.getElementById('premiumFolderRemainingValue');
    if (remainingValue) remainingValue.textContent = String(remaining);

    const planFromUser = getPremiumPlan();
    const planForUI = mapPremiumPlanForUI(planFromUser);
    if (isPremium && planForUI) {
        selectedPremiumPlan = planForUI;
    } else if (!selectedPremiumPlan || normalizePremiumPlan(selectedPremiumPlan) !== selectedPremiumPlan) {
        selectedPremiumPlan = 'trial';
    }

    document.querySelectorAll('input[name="premiumPlan"]').forEach(input => {
        input.checked = input.value === selectedPremiumPlan;
    });
    document.querySelectorAll('.premium-plan-option').forEach(option => {
        option.classList.toggle('is-active', option.dataset.plan === selectedPremiumPlan);
    });

    const subscribeBtn = document.getElementById('premiumSubscribeBtn');
    if (subscribeBtn) {
        if (isPremium) {
            subscribeBtn.textContent = t('settings.premium.cta.active');
            subscribeBtn.disabled = true;
        } else {
            const priceLabel = selectedPremiumPlan === 'year'
                ? t('settings.premium.cta.price.year')
                : (selectedPremiumPlan === 'trial'
                    ? t('settings.premium.cta.price.trial')
                    : t('settings.premium.cta.price.month'));
            subscribeBtn.textContent = formatTemplate(t('settings.premium.cta.subscribe'), { price: priceLabel });
            subscribeBtn.disabled = false;
        }
    }

    const manageBtn = document.getElementById('premiumManageBtn');
    if (manageBtn) {
        manageBtn.style.display = isPremium ? 'inline-flex' : 'none';
    }

    updateCallQualityControls();
    if (typeof updateInlineCallQualityControls === 'function') {
        updateInlineCallQualityControls();
    }
    updatePremiumPaymentStatusUI();
    updateBusinessHoursUI();
    updateFolderLimitUI();
}

function updatePremiumGiftUI() {
    document.querySelectorAll('input[name="premiumGiftPlan"]').forEach(input => {
        input.checked = input.value === selectedPremiumGiftPlan;
    });
    document.querySelectorAll('.premium-gift-plan').forEach(option => {
        option.classList.toggle('is-active', option.dataset.plan === selectedPremiumGiftPlan);
    });
}

function canGiftPremiumInChat(chat = currentChat) {
    return Boolean(chat)
        && !chat.is_saved_messages
        && (chat.type === 'chat' || !chat.type)
        && !chat.is_bot;
}

function normalizeGiftUsername(value) {
    if (!value) return '';
    return value.replace(/^@+/, '').trim();
}

function getPremiumGiftChatUsername(chat = currentChat) {
    if (!canGiftPremiumInChat(chat)) return '';
    const candidate = chat.username || chat.data?.username || chat.name || '';
    return normalizeGiftUsername(candidate);
}

function getPremiumGiftChatTarget(chat = currentChat) {
    if (!canGiftPremiumInChat(chat)) return null;
    return {
        id: chat.id,
        username: getPremiumGiftChatUsername(chat)
    };
}

async function resolvePremiumGiftRecipient(username) {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications.error('Необходима авторизация');
        window.location.href = '/login';
        return null;
    }
    try {
        const response = await fetch(API_BASE + '/api/find-user', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, username })
        });
        const data = await response.json();
        if (!data.success || !data.user_id) {
            notifications.error(t('settings.premium.gift.error.notFound'));
            return null;
        }
        return {
            id: data.user_id,
            isPremium: data.is_premium === true || data.is_premium === 'true'
        };
    } catch (error) {
        console.error('Premium gift lookup failed:', error);
        notifications.error(t('settings.premium.gift.error.notFound'));
        return null;
    }
}

async function sendPremiumGiftMessage({ targetId, content, optimistic = false } = {}) {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications.error('Необходима авторизация');
        window.location.href = '/login';
        return false;
    }
    if (!targetId || !content) return false;

    const tempId = optimistic ? generateTempId() : '';
    if (optimistic) {
        const time = new Date().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
        addMessageToUI({
            content,
            sent: true,
            status: 'sent',
            temp_id: tempId,
            time,
            message_type: 'text'
        }, true);
    }

    try {
        const requestBody = {
            token,
            receiver_id: targetId,
            content,
            message_type: 'text'
        };
        if (tempId) {
            requestBody.temp_id = tempId;
        }

        const response = await fetch(API_BASE + '/api/send-message', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });
        const data = await response.json();
        if (!data.success) {
            if (data.message && data.message.includes('Invalid token')) {
                await window.xipherSession?.logout();
                notifications.error('Сессия истекла. Необходима повторная авторизация');
                setTimeout(() => {
                    window.location.href = '/login';
                }, 2000);
            } else {
                notifications.error(data.message || 'Ошибка отправки сообщения');
            }
            return false;
        }

        if (tempId) {
            reconcileTempMessage(tempId, {
                id: data.message_id,
                temp_id: data.temp_id || tempId,
                time: formatServerTimeToLocal(data.created_at)
            });
        }

        await loadChats();
        if (currentChat && currentChat.id) {
            setTimeout(() => {
                checkNewMessages(currentChat.id);
            }, 500);
        }
        return true;
    } catch (error) {
        console.error('Premium gift send failed:', error);
        notifications.error('Ошибка отправки сообщения');
        return false;
    }
}

async function sendPremiumGift() {
    const input = document.getElementById('premiumGiftUsername');
    if (!input) return;
    const raw = input.value.trim();
    const chatTarget = getPremiumGiftChatTarget();
    const fallbackUsername = chatTarget?.username || '';
    const username = normalizeGiftUsername(raw) || fallbackUsername;
    if (!username) {
        notifications.warning(t('settings.premium.gift.error.empty'));
        input.focus();
        return;
    }
    const plan = normalizePremiumGiftPlan(selectedPremiumGiftPlan);
    let targetId = chatTarget?.id || null;
    if (!targetId || (raw && normalizeGiftUsername(raw) !== normalizeGiftUsername(chatTarget?.username || ''))) {
        const recipient = await resolvePremiumGiftRecipient(username);
        if (!recipient) return;
        targetId = recipient.id;
    }
    if (!targetId) {
        notifications.error(t('settings.premium.gift.error.notFound'));
        return;
    }
    if (currentUser?.id && String(currentUser.id) === String(targetId)) {
        notifications.warning(t('settings.premium.gift.error.self'));
        return;
    }
    openPremiumPaymentModal(plan, {
        mode: 'gift',
        giftRecipient: { id: targetId, username }
    });
    closePremiumGiftModal();
}

function updateFolderLimitUI() {
    const used = getFolderUsage();
    const limit = getFolderLimit();
    const remaining = Math.max(0, limit - used);
    const isPremium = isPremiumActive();

    const pill = document.getElementById('folderLimitPill');
    if (pill) {
        pill.textContent = `${used} / ${limit}`;
    }

    const note = document.getElementById('folderLimitNote');
    if (note) {
        const key = isPremium
            ? 'folders.limit.active'
            : (used >= limit ? 'folders.limit.reached' : 'folders.limit.free');
        note.textContent = formatTemplate(t(key), {
            limit,
            used,
            remaining,
            limitPremium: FOLDER_LIMIT_PREMIUM
        });
    }

    const createBtn = document.getElementById('createFolderBtn');
    if (createBtn) {
        createBtn.disabled = used >= limit;
    }

    const assignBtn = document.getElementById('createFolderFromAssignBtn');
    if (assignBtn) {
        assignBtn.disabled = used >= limit;
    }

    const upgradeBtn = document.getElementById('folderUpgradeBtn');
    if (upgradeBtn) {
        upgradeBtn.style.display = (!isPremium && used >= limit) ? 'inline-flex' : 'none';
    }
}

function setPremiumState({ active = false, plan = '', expiresAt } = {}) {
    try {
        localStorage.setItem(PREMIUM_ACTIVE_KEY, active ? 'true' : 'false');
        if (plan) {
            localStorage.setItem(PREMIUM_PLAN_KEY, plan);
        } else {
            localStorage.removeItem(PREMIUM_PLAN_KEY);
        }
        if (expiresAt !== undefined) {
            if (expiresAt) {
                localStorage.setItem(PREMIUM_EXPIRES_KEY, expiresAt);
            } else {
                localStorage.removeItem(PREMIUM_EXPIRES_KEY);
            }
        }
    } catch (_) {}
    if (currentUser) {
        currentUser.is_premium = active;
        currentUser.premium_plan = plan;
        if (expiresAt !== undefined) {
            currentUser.premium_expires_at = expiresAt || '';
        }
    }
    if (active) {
        clearPendingPremiumPayment();
    }
    updatePremiumUI();
}

async function refreshPremiumStatus() {
    const token = localStorage.getItem('xipher_token');
    if (!token) return false;
    try {
        const response = await fetch(API_BASE + '/api/validate-token', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token })
        });
        const data = await response.json();
        if (!data || !data.success) return false;
        const payload = data.data || {};
        const premiumActive = payload.is_premium === true || payload.is_premium === 'true';
        const premiumPlan = typeof payload.premium_plan === 'string' ? payload.premium_plan : '';
        const premiumExpiresAt = typeof payload.premium_expires_at === 'string' ? payload.premium_expires_at : '';
        setPremiumState({ active: premiumActive, plan: premiumPlan, expiresAt: premiumExpiresAt });
        return premiumActive;
    } catch (error) {
        console.warn('Premium refresh failed', error);
        return false;
    }
}

function stopPremiumPaymentPolling() {
    if (premiumPaymentPoller) {
        clearInterval(premiumPaymentPoller);
        premiumPaymentPoller = null;
    }
}

function startPremiumPaymentPolling({ force = false } = {}) {
    stopPremiumPaymentPolling();
    const wasPremium = isPremiumActive();
    let attempts = 0;
    premiumPaymentPoller = setInterval(async () => {
        attempts += 1;
        const active = await refreshPremiumStatus();
        if (active) {
            if (!wasPremium) {
                notifications.success(t('settings.premium.toast.active'));
            }
            stopPremiumPaymentPolling();
            return;
        }
        const pending = getPendingPremiumPayment();
        if (!pending && !force) {
            stopPremiumPaymentPolling();
            return;
        }
        if (!pending && force && attempts >= 12) {
            stopPremiumPaymentPolling();
        }
    }, 5000);
}

async function createPremiumPayment(plan, provider) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return null;
    try {
        const response = await fetch(API_BASE + '/api/premium/create-payment', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, plan, provider })
        });
        const data = await response.json();
        if (!data || !data.success) {
            resetPendingPremiumPaymentState();
            notifications.error(data?.message || t('settings.premium.payment.toast.error'));
            return null;
        }
        return data.data || null;
    } catch (error) {
        console.error('Premium payment create failed:', error);
        resetPendingPremiumPaymentState();
        notifications.error(t('settings.premium.payment.toast.error'));
        return null;
    }
}

async function createPremiumGiftPayment(plan, provider, receiverId) {
    const token = localStorage.getItem('xipher_token');
    if (!token || !receiverId) return null;
    try {
        const response = await fetch(API_BASE + '/api/premium/create-gift-payment', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, plan, provider, receiver_id: receiverId })
        });
        const data = await response.json();
        if (!data || !data.success) {
            notifications.error(data?.message || t('settings.premium.payment.toast.error'));
            return null;
        }
        return data.data || null;
    } catch (error) {
        console.error('Premium gift payment create failed:', error);
        notifications.error(t('settings.premium.payment.toast.error'));
        return null;
    }
}

function getSelectedPremiumPaymentProvider() {
    const selected = document.querySelector('input[name="premiumPaymentProvider"]:checked');
    return selected?.value || 'yoomoney';
}

function updatePremiumPaymentProviderUI() {
    const provider = getSelectedPremiumPaymentProvider();
    const noteEl = document.getElementById('premiumPaymentNote');
    if (noteEl) {
        const key = provider === 'stripe'
            ? 'settings.premium.payment.note.stripe'
            : 'settings.premium.payment.note.yoomoney';
        noteEl.textContent = t(key);
    }
    const methodsEl = document.getElementById('premiumPaymentYooMoneyMethods');
    if (methodsEl) {
        methodsEl.style.display = provider === 'yoomoney' ? 'grid' : 'none';
    }
}

function openPremiumPaymentModal(plan, context = {}) {
    const modal = document.getElementById('premiumPaymentModal');
    if (!modal) return;
    const mode = context.mode === 'gift' ? 'gift' : 'self';
    setPremiumPaymentContext({
        mode,
        giftRecipient: context.giftRecipient || null
    });
    const normalizedPlan = mode === 'gift'
        ? normalizePremiumGiftPlan(plan)
        : normalizePremiumPlan(plan);
    premiumPaymentPlanPending = normalizedPlan;
    premiumPaymentState = null;

    let planLabel = '';
    if (mode === 'gift') {
        const giftKey = normalizedPlan === 'year'
            ? 'settings.premium.gift.plan.year'
            : (normalizedPlan === 'half'
                ? 'settings.premium.gift.plan.half'
                : 'settings.premium.gift.plan.month');
        planLabel = t(giftKey);
    } else {
        planLabel = normalizedPlan === 'year'
            ? t('settings.premium.plan.year.title')
            : (normalizedPlan === 'trial'
                ? t('settings.premium.plan.trial.title')
                : t('settings.premium.plan.month.title'));
    }
    const planEl = document.getElementById('premiumPaymentPlanLabel');
    if (planEl) {
        planEl.textContent = planLabel;
    }
    const amountEl = document.getElementById('premiumPaymentAmount');
    if (amountEl) {
        if (mode === 'gift') {
            const config = getPremiumGiftPlanConfig(normalizedPlan);
            amountEl.textContent = config?.price ? `${config.price} ₽` : '';
        } else {
            const rawAmount = PREMIUM_PLAN_AMOUNTS[normalizedPlan] || '';
            amountEl.textContent = rawAmount ? `${rawAmount} ₽` : '';
        }
    }

    const defaultProvider = document.querySelector('input[name="premiumPaymentProvider"][value="yoomoney"]');
    if (defaultProvider) defaultProvider.checked = true;
    const defaultOption = document.querySelector('input[name="premiumPaymentType"][value="AC"]');
    if (defaultOption) defaultOption.checked = true;
    updatePremiumPaymentProviderUI();

    modal.style.display = 'flex';
}

function closePremiumPaymentModal() {
    const modal = document.getElementById('premiumPaymentModal');
    if (!modal) return;
    modal.style.display = 'none';
    premiumPaymentState = null;
    premiumPaymentPlanPending = null;
    resetPremiumPaymentContext();
}

async function submitPremiumPayment() {
    const plan = premiumPaymentPlanPending || selectedPremiumPlan;
    if (!plan) return;
    const provider = getSelectedPremiumPaymentProvider();
    const isGift = premiumPaymentContext?.mode === 'gift';
    const giftRecipientId = premiumPaymentContext?.giftRecipient?.id || '';
    if (isGift && !giftRecipientId) {
        notifications.error(t('settings.premium.gift.error.notFound'));
        return;
    }
    const payment = isGift
        ? await createPremiumGiftPayment(plan, provider, giftRecipientId)
        : await createPremiumPayment(plan, provider);
    if (!payment) return;
    premiumPaymentState = payment;

    if (payment.provider === 'stripe') {
        const checkoutUrl = payment.checkout_url;
        if (!checkoutUrl) {
            notifications.error(t('settings.premium.payment.toast.error'));
            return;
        }
        const paymentWindow = window.open(checkoutUrl, 'stripe_payment');
        if (!paymentWindow) {
            window.location.href = checkoutUrl;
        } else {
            paymentWindow.focus();
        }
    } else {
        if (!payment.form_action || !payment.receiver || !payment.label || !payment.sum) {
            notifications.error(t('settings.premium.payment.toast.error'));
            return;
        }
        const paymentType = document.querySelector('input[name="premiumPaymentType"]:checked')?.value || 'AC';

        const form = document.createElement('form');
        form.method = 'POST';
        form.action = payment.form_action;
        form.target = 'yoomoney_payment';

        const addField = (name, value) => {
            const input = document.createElement('input');
            input.type = 'hidden';
            input.name = name;
            input.value = value;
            form.appendChild(input);
        };

        addField('receiver', payment.receiver);
        addField('quickpay-form', 'button');
        addField('sum', payment.sum);
        addField('paymentType', paymentType);
        addField('label', payment.label);
        if (payment.success_url) {
            addField('successURL', payment.success_url);
        }

        const paymentWindow = window.open('', 'yoomoney_payment', 'width=480,height=720');
        document.body.appendChild(form);
        form.submit();
        form.remove();
        if (paymentWindow) paymentWindow.focus();
    }

    if (!isGift) {
        setPendingPremiumPayment({
            label: payment.label,
            plan: payment.plan
        });
        updatePremiumPaymentStatusUI();
        notifications.info(t('settings.premium.payment.toast.opened'));
        startPremiumPaymentPolling();
    } else {
        notifications.info(t('premium.gift.payment.toast.opened'));
    }
    closePremiumPaymentModal();
}

async function postPremiumUpdate(active, plan) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return false;
    try {
        const response = await fetch(API_BASE + '/api/set-premium', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                token,
                active: active ? 'true' : 'false',
                plan: plan || ''
            })
        });
        const data = await response.json();
        if (!data || !data.success) {
            notifications.error(data?.message || t('settings.premium.toast.error'));
            return false;
        }
        const payload = data.data || {};
        const nextActive = payload.is_premium === true || payload.is_premium === 'true';
        const nextPlan = typeof payload.premium_plan === 'string' ? payload.premium_plan : '';
        const nextExpiresAt = typeof payload.premium_expires_at === 'string' ? payload.premium_expires_at : '';
        setPremiumState({ active: nextActive, plan: nextPlan, expiresAt: nextExpiresAt });
        return true;
    } catch (error) {
        console.error('Premium update failed:', error);
        notifications.error(t('settings.premium.toast.error'));
        return false;
    }
}

async function activatePremium(plan) {
    const normalizedPlan = normalizePremiumPlan(plan);
    resetPendingPremiumPaymentState();
    openPremiumPaymentModal(normalizedPlan);
}

function openPremiumCancelModal() {
    const modal = document.getElementById('premiumCancelModal');
    if (!modal) return;
    modal.style.display = 'flex';
}

function closePremiumCancelModal() {
    const modal = document.getElementById('premiumCancelModal');
    if (!modal) return;
    modal.style.display = 'none';
}

async function confirmPremiumCancel() {
    if (!isPremiumActive()) {
        closePremiumCancelModal();
        return;
    }
    notifications.info(t('settings.premium.toast.cancel'));
    closePremiumCancelModal();
}

function cancelPremium() {
    if (!isPremiumActive()) return;
    openPremiumCancelModal();
}

function handleFolderLimitReached() {
    notifications.warning(formatTemplate(t('folders.limit.toast'), {
        limitPremium: FOLDER_LIMIT_PREMIUM
    }));
    updateFolderLimitUI();
}

function normalizeBusinessHours(raw) {
    let payload = raw;
    if (typeof payload === 'string' && payload.trim()) {
        try {
            payload = JSON.parse(payload);
        } catch (_) {
            payload = null;
        }
    }
    const normalized = {};
    Object.keys(BUSINESS_HOURS_DEFAULTS).forEach(day => {
        const defaults = BUSINESS_HOURS_DEFAULTS[day];
        const value = payload && typeof payload === 'object' ? payload[day] : null;
        normalized[day] = {
            enabled: typeof value?.enabled === 'boolean' ? value.enabled : defaults.enabled,
            start: typeof value?.start === 'string' ? value.start : defaults.start,
            end: typeof value?.end === 'string' ? value.end : defaults.end
        };
    });
    return normalized;
}

function buildBusinessHoursSummary(raw) {
    if (!raw) return '';
    if (typeof raw === 'string') {
        const trimmed = raw.trim();
        if (!trimmed || trimmed === '{}') return '';
    }
    if (typeof raw === 'object' && Object.keys(raw).length === 0) return '';
    const normalized = normalizeBusinessHours(raw);
    const now = new Date();
    const todayKey = BUSINESS_JS_DAY_KEYS[now.getDay()];
    const todayIndex = BUSINESS_DAY_ORDER.indexOf(todayKey);
    const nowMinutes = now.getHours() * 60 + now.getMinutes();
    const nowSeconds = (nowMinutes * 60) + now.getSeconds();

    let isOpen = false;
    let nextOpen = null;
    let nextOpenMinutes = null;
    let closeTime = '';

    const todayEntry = normalized[todayKey];
    if (todayEntry && todayEntry.enabled) {
        const startMin = parseTimeToMinutes(todayEntry.start);
        const endMin = parseTimeToMinutes(todayEntry.end);
        if (startMin !== null && endMin !== null) {
            const startSeconds = startMin * 60;
            const endSeconds = endMin * 60;
            if (nowSeconds >= startSeconds && nowSeconds < endSeconds) {
                isOpen = true;
                closeTime = todayEntry.end;
            } else if (nowSeconds < startSeconds) {
                nextOpen = { day: todayKey, time: todayEntry.start };
                nextOpenMinutes = Math.ceil((startSeconds - nowSeconds) / 60);
            }
        }
    }

    if (!isOpen && !nextOpen) {
        const baseIndex = todayIndex >= 0 ? todayIndex : 0;
        for (let offset = 1; offset <= 7; offset += 1) {
            const dayKey = BUSINESS_DAY_ORDER[(baseIndex + offset) % BUSINESS_DAY_ORDER.length];
            const entry = normalized[dayKey];
            if (!entry || !entry.enabled) continue;
            const startMin = parseTimeToMinutes(entry.start);
            const endMin = parseTimeToMinutes(entry.end);
            if (startMin === null || endMin === null) continue;
            nextOpen = { day: dayKey, time: entry.start };
            break;
        }
    }

    const statusLabel = t(isOpen ? 'profile.business.status.open' : 'profile.business.status.closed');
    let statusHint = '';
    if (isOpen && closeTime) {
        statusHint = formatTemplate(t('profile.business.until'), { time: closeTime });
    } else if (nextOpen) {
        if (nextOpen.day === todayKey && Number.isFinite(nextOpenMinutes) && nextOpenMinutes > 0) {
            statusHint = formatTemplate(t('profile.business.opensIn'), { time: formatOpenCountdown(nextOpenMinutes) });
        } else if (nextOpen.day === todayKey) {
            statusHint = formatTemplate(t('profile.business.opensToday'), { time: nextOpen.time });
        } else {
            const dayLabel = BUSINESS_DAY_KEYS[nextOpen.day] ? t(BUSINESS_DAY_KEYS[nextOpen.day]) : '';
            statusHint = formatTemplate(t('profile.business.opensDay'), { day: dayLabel, time: nextOpen.time });
        }
    }

    const lines = [];
    BUSINESS_DAY_ORDER.forEach(day => {
        const entry = normalized[day];
        const label = t(BUSINESS_DAY_KEYS[day]);
        const time = entry && entry.enabled && entry.start && entry.end
            ? `${entry.start}–${entry.end}`
            : t('settings.premium.business.closed');
        const isToday = day === todayKey;
        const isDisabled = !entry || !entry.enabled;
        lines.push(
            `<div class="profile-hours-row${isToday ? ' is-today' : ''}${isDisabled ? ' is-disabled' : ''}">` +
            `<span class="profile-hours-day">${escapeHtml(label)}</span>` +
            `<span class="profile-hours-time">${escapeHtml(time)}</span>` +
            `</div>`
        );
    });
    if (!lines.length) return '';
    return `
        <details class="profile-hours-card" open>
            <summary class="profile-hours-summary">
                <div class="profile-hours-heading">
                    <div class="profile-hours-title">${escapeHtml(t('profile.business.title'))}</div>
                    <div class="profile-hours-status">
                        <span class="profile-hours-pill ${isOpen ? 'is-open' : 'is-closed'}">${escapeHtml(statusLabel)}</span>
                        ${statusHint ? `<span class="profile-hours-next">${escapeHtml(statusHint)}</span>` : ''}
                    </div>
                </div>
                <span class="profile-hours-chevron">&#9662;</span>
            </summary>
            <div class="profile-hours-list">
                ${lines.join('')}
            </div>
        </details>
    `;
}

function updateBusinessHoursRow(row) {
    const toggle = row.querySelector('.business-day-toggle');
    const isEnabled = toggle ? toggle.checked : true;
    row.classList.toggle('is-disabled', !isEnabled);
    row.querySelectorAll('.business-time-input').forEach(input => {
        input.disabled = !isEnabled;
    });
}

function applyBusinessHoursToForm(raw) {
    const grid = document.getElementById('businessHoursGrid');
    if (!grid) return;
    const normalized = normalizeBusinessHours(raw);
    grid.querySelectorAll('.business-hours-row').forEach(row => {
        const day = row.dataset.day;
        if (!day || !normalized[day]) return;
        const entry = normalized[day];
        const toggle = row.querySelector('.business-day-toggle');
        const startInput = row.querySelector('.business-time-input[data-role="start"]');
        const endInput = row.querySelector('.business-time-input[data-role="end"]');
        if (toggle) toggle.checked = entry.enabled;
        if (startInput) startInput.value = entry.start;
        if (endInput) endInput.value = entry.end;
        updateBusinessHoursRow(row);
    });
}

function readBusinessHoursForm() {
    const grid = document.getElementById('businessHoursGrid');
    const result = {};
    if (!grid) return result;
    grid.querySelectorAll('.business-hours-row').forEach(row => {
        const day = row.dataset.day;
        if (!day) return;
        const toggle = row.querySelector('.business-day-toggle');
        const startInput = row.querySelector('.business-time-input[data-role="start"]');
        const endInput = row.querySelector('.business-time-input[data-role="end"]');
        result[day] = {
            enabled: toggle ? toggle.checked : true,
            start: startInput ? startInput.value : '',
            end: endInput ? endInput.value : ''
        };
    });
    return result;
}

function updateBusinessHoursUI() {
    const card = document.getElementById('premiumBusinessCard');
    if (!card) return;
    card.classList.toggle('is-locked', !isPremiumActive());
}

async function saveBusinessHours() {
    if (!isPremiumActive()) {
        notifications.warning(t('settings.premium.business.lockedToast'));
        openSettingsPanel('premium');
        return;
    }
    const token = localStorage.getItem('xipher_token');
    if (!token) return;
    const payload = readBusinessHoursForm();
    try {
        const response = await fetch(API_BASE + '/api/set-business-hours', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                token,
                business_hours: JSON.stringify(payload)
            })
        });
        const data = await response.json();
        if (!data || !data.success) {
            notifications.error(data?.message || t('settings.premium.business.error'));
            return;
        }
        if (currentUser) {
            currentUser.business_hours = payload;
        }
        notifications.success(t('settings.premium.business.saved'));
    } catch (error) {
        console.error('saveBusinessHours error:', error);
        notifications.error(t('settings.premium.business.error'));
    }
}

function setupBusinessHours() {
    const grid = document.getElementById('businessHoursGrid');
    if (!grid) return;
    grid.querySelectorAll('.business-hours-row').forEach(row => {
        const toggle = row.querySelector('.business-day-toggle');
        if (toggle) {
            toggle.addEventListener('change', () => updateBusinessHoursRow(row));
        }
        updateBusinessHoursRow(row);
    });
    document.getElementById('saveBusinessHoursBtn')?.addEventListener('click', saveBusinessHours);
    if (currentUser?.business_hours) {
        applyBusinessHoursToForm(currentUser.business_hours);
    }
}

function loadChatStateSets() {
    pinnedChatKeys = normalizeChatKeySet(readChatKeySet(PINNED_CHATS_KEY));
    mutedChatKeys = normalizeChatKeySet(readChatKeySet(MUTED_CHATS_KEY));
    hiddenChatKeys = normalizeChatKeySet(readChatKeySet(HIDDEN_CHATS_KEY));
    writeChatKeySet(PINNED_CHATS_KEY, pinnedChatKeys);
    writeChatKeySet(MUTED_CHATS_KEY, mutedChatKeys);
    writeChatKeySet(HIDDEN_CHATS_KEY, hiddenChatKeys);
}

function createFolderId() {
    if (window.crypto && typeof window.crypto.randomUUID === 'function') {
        return window.crypto.randomUUID();
    }
    return `folder-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function loadChatFolders() {
    let stored = [];
    try {
        const raw = localStorage.getItem(CHAT_FOLDERS_KEY);
        if (raw) {
            stored = JSON.parse(raw);
        }
    } catch (_) {
        stored = [];
    }

    if (!Array.isArray(stored)) {
        stored = [];
    }

    chatFolders = stored
        .filter(folder => folder && folder.id && folder.name)
        .map(folder => {
            const rawKeys = Array.isArray(folder.chatKeys) ? folder.chatKeys.map(String) : [];
            const normalizedKeys = normalizeChatKeySet(rawKeys);
            return {
                id: String(folder.id),
                name: String(folder.name).slice(0, 64),
                chatKeys: Array.from(normalizedKeys)
            };
        });

    activeFolderId = localStorage.getItem(ACTIVE_FOLDER_KEY) || 'all';
    if (activeFolderId !== 'all' && !chatFolders.some(folder => folder.id === activeFolderId)) {
        activeFolderId = 'all';
        try {
            localStorage.setItem(ACTIVE_FOLDER_KEY, activeFolderId);
        } catch (_) {}
    }

    updateFolderLimitUI();
}

function saveChatFolders() {
    try {
        localStorage.setItem(CHAT_FOLDERS_KEY, JSON.stringify(chatFolders));
    } catch (_) {}
}

function persistChatFolders({ sync = true, render = true } = {}) {
    saveChatFolders();
    if (render) {
        renderChats();
    }
    if (sync) {
        try {
            localStorage.setItem(CHAT_FOLDERS_SYNC_FLAG, '0');
        } catch (_) {}
        postChatFoldersUpdate(chatFolders);
    }
}

function normalizeFolderPayload(list) {
    const normalized = [];
    (list || []).forEach((folder) => {
        if (!folder) return;
        const id = folder.id || folder.folder_id;
        const name = folder.name || folder.title;
        if (!id || !name) return;
        const rawKeys = Array.isArray(folder.chat_keys)
            ? folder.chat_keys
            : (Array.isArray(folder.chatKeys) ? folder.chatKeys : []);
        const normalizedKeys = normalizeChatKeySet(rawKeys.map(String));
        normalized.push({
            id: String(id),
            name: String(name).slice(0, 64),
            chatKeys: Array.from(normalizedKeys)
        });
    });
    return normalized;
}

function applyChatFoldersFromServer(list) {
    chatFolders = normalizeFolderPayload(list);
    saveChatFolders();
    try {
        localStorage.setItem(CHAT_FOLDERS_SYNC_FLAG, '1');
    } catch (_) {}
    if (activeFolderId !== 'all' && !getFolderById(activeFolderId)) {
        setActiveFolder('all', { render: false });
    }
    renderChats();
    updatePremiumUI();
}

async function postChatFoldersUpdate(folders) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return false;
    const payload = (folders || []).map((folder) => ({
        id: folder.id,
        name: folder.name,
        chat_keys: Array.isArray(folder.chatKeys) ? folder.chatKeys : []
    }));
    try {
        const response = await fetch(API_BASE + '/api/set-chat-folders', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                token,
                folders: JSON.stringify(payload)
            })
        });
        const data = await response.json();
        if (data && data.success) {
            try {
                localStorage.setItem(CHAT_FOLDERS_SYNC_FLAG, '1');
            } catch (_) {}
            return true;
        }
        return false;
    } catch (error) {
        console.error('Failed to update chat folders:', error);
        return false;
    }
}

async function syncChatFoldersFromServer(force = false) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return;
    const now = Date.now();
    if (foldersSyncInFlight) return;
    if (!force && now - lastFoldersSyncAt < CHAT_FOLDERS_SYNC_INTERVAL_MS) return;
    foldersSyncInFlight = true;
    try {
        const response = await fetch(API_BASE + '/api/get-chat-folders', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token })
        });
        const data = await response.json();
        if (!data || !data.success) return;
        const remote = normalizeFolderPayload(Array.isArray(data.folders) ? data.folders : []);
        const wasSynced = localStorage.getItem(CHAT_FOLDERS_SYNC_FLAG) === '1';
        const hasLocal = localStorage.getItem(CHAT_FOLDERS_KEY) !== null;
        if (!wasSynced && hasLocal) {
            await postChatFoldersUpdate(chatFolders);
            return;
        }
        applyChatFoldersFromServer(remote);
    } catch (error) {
        console.error('Failed to sync chat folders:', error);
    } finally {
        foldersSyncInFlight = false;
        lastFoldersSyncAt = Date.now();
    }
}

function getFolderById(folderId) {
    if (!folderId) return null;
    return chatFolders.find(folder => folder.id === folderId) || null;
}

function setActiveFolder(folderId, { render = true } = {}) {
    activeFolderId = folderId || 'all';
    if (activeFolderId !== 'all' && !getFolderById(activeFolderId)) {
        activeFolderId = 'all';
    }
    try {
        localStorage.setItem(ACTIVE_FOLDER_KEY, activeFolderId);
    } catch (_) {}
    if (render) {
        renderChats();
    }
}

function getChatsForActiveFolder(list = chats) {
    const visible = getVisibleChats(list);
    if (activeFolderId !== 'all' && !getFolderById(activeFolderId)) {
        activeFolderId = 'all';
        try {
            localStorage.setItem(ACTIVE_FOLDER_KEY, activeFolderId);
        } catch (_) {}
    }
    if (activeFolderId === 'all') {
        return visible;
    }
    const folder = getFolderById(activeFolderId);
    if (!folder || !Array.isArray(folder.chatKeys)) {
        return visible;
    }
    const keys = new Set(folder.chatKeys.map(String));
    return visible.filter(chat => keys.has(buildChatKey(chat)));
}

function getFolderChatCount(folder) {
    const { keys } = buildVisibleChatKeySet();
    return countFolderChats(folder, keys);
}

function renderFolderRail() {
    const rail = document.getElementById('foldersRailList');
    if (!rail) return;
    const fragment = document.createDocumentFragment();
    const { visible, keys } = buildVisibleChatKeySet();

    const allItem = buildFolderRailItem({
        id: 'all',
        name: 'Все',
        icon: '💬',
        count: visible.length
    });
    fragment.appendChild(allItem);

    if (chatFolders.length === 0) {
        rail.replaceChildren(fragment);
        return;
    }

    chatFolders.forEach(folder => {
        const item = buildFolderRailItem({
            id: folder.id,
            name: folder.name,
            icon: '📁',
            count: countFolderChats(folder, keys)
        });
        fragment.appendChild(item);
    });
    rail.replaceChildren(fragment);
}

function buildFolderRailItem({ id, name, icon, count }) {
    const item = document.createElement('button');
    item.className = 'folder-rail-item';
    if (id === activeFolderId) {
        item.classList.add('active');
    }
    item.dataset.folderId = id;
    item.title = name;

    const iconEl = document.createElement('div');
    iconEl.className = 'folder-rail-icon';
    // Используем SVG иконки вместо эмодзи
    const iconHtml = typeof emojiToIcon === 'function' ? emojiToIcon(icon || '📁') : (icon || '📁');
    iconEl.innerHTML = iconHtml;

    const labelEl = document.createElement('div');
    labelEl.className = 'folder-rail-label';
    labelEl.textContent = name;

    item.appendChild(iconEl);
    item.appendChild(labelEl);

    if (typeof count === 'number' && count > 0) {
        const countEl = document.createElement('div');
        countEl.className = 'folder-rail-count';
        countEl.textContent = count;
        item.appendChild(countEl);
    }

    item.addEventListener('click', () => {
        setActiveFolder(id);
    });

    return item;
}

function normalizeChatType(type) {
    const raw = (type || '').toString().toLowerCase();
    if (!raw || raw === 'direct' || raw === 'message' || raw === 'chat') {
        return 'chat';
    }
    if (raw === 'saved_messages' || raw === 'saved') {
        return 'saved';
    }
    if (raw === 'group') return 'group';
    if (raw === 'channel') return 'channel';
    return raw;
}

function getChatTypeForKey(chat) {
    if (!chat) return 'chat';
    if (chat.is_saved_messages) return 'saved';
    return normalizeChatType(chat.type || 'chat');
}

function buildChatKey(chat) {
    if (!chat || !chat.id) return '';
    const type = getChatTypeForKey(chat);
    return `${type}:${chat.id}`;
}

function buildChatKeyFromParts(chatId, chatType) {
    if (!chatId) return '';
    const type = normalizeChatType(chatType);
    return `${type}:${chatId}`;
}

function normalizeChatKeySet(keys) {
    const out = new Set();
    (keys || []).forEach((key) => {
        const parts = splitChatKey(key);
        if (!parts || !parts.id) return;
        out.add(`${parts.type}:${parts.id}`);
    });
    return out;
}

function isChatPinned(chat) {
    const key = buildChatKey(chat);
    return key ? pinnedChatKeys.has(key) : false;
}

function isChatMuted(chat) {
    const key = buildChatKey(chat);
    return key ? mutedChatKeys.has(key) : false;
}

function isChatHidden(chat) {
    const key = buildChatKey(chat);
    return key ? hiddenChatKeys.has(key) : false;
}

function getVisibleChats(list = chats) {
    return list.filter(chat => !isChatHidden(chat));
}

function buildVisibleChatKeySet(list = chats) {
    const visible = getVisibleChats(list);
    const keys = new Set();
    visible.forEach(chat => {
        const key = buildChatKey(chat);
        if (key) {
            keys.add(key);
        }
    });
    return { visible, keys };
}

function countFolderChats(folder, visibleKeySet) {
    if (!folder || !Array.isArray(folder.chatKeys)) return 0;
    if (!visibleKeySet || visibleKeySet.size === 0) return 0;
    let total = 0;
    folder.chatKeys.forEach(key => {
        if (visibleKeySet.has(String(key))) {
            total += 1;
        }
    });
    return total;
}

function sortChatsForDisplay(list) {
    const pinned = [];
    const rest = [];
    list.forEach(chat => {
        const key = buildChatKey(chat);
        if (key && pinnedChatKeys.has(key)) {
            pinned.push(chat);
        } else {
            rest.push(chat);
        }
    });
    return pinned.concat(rest);
}

function splitChatKey(key) {
    if (!key) return null;
    const sep = key.indexOf(':');
    if (sep <= 0) return null;
    return {
        type: normalizeChatType(key.slice(0, sep)),
        id: key.slice(sep + 1)
    };
}

function applyPinnedKeyState(key, pinned, { render = true } = {}) {
    if (!key) return;
    if (pinned) {
        pinnedChatKeys.add(key);
    } else {
        pinnedChatKeys.delete(key);
    }
    writeChatKeySet(PINNED_CHATS_KEY, pinnedChatKeys);
    if (render) {
        renderChats();
    }
}

function setPinnedKeySet(keys) {
    pinnedChatKeys = new Set(keys || []);
    writeChatKeySet(PINNED_CHATS_KEY, pinnedChatKeys);
    renderChats();
}

async function postChatPinUpdate(chatId, chatType, pinned) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return false;
    const endpoint = pinned ? '/api/pin-chat' : '/api/unpin-chat';
    const response = await fetch(API_BASE + endpoint, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            token,
            chat_id: chatId,
            chat_type: normalizeChatType(chatType)
        })
    });
    const data = await response.json();
    return Boolean(data && data.success);
}

async function pushPinnedKeysToServer(keys) {
    const list = Array.from(keys || []);
    if (!list.length) return;
    await Promise.allSettled(list.map((key) => {
        const parts = splitChatKey(key);
        if (!parts || !parts.id) return Promise.resolve();
        return postChatPinUpdate(parts.id, parts.type, true);
    }));
}

async function syncPinnedChatsFromServer(force = false) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return;
    const now = Date.now();
    if (pinnedSyncInFlight) return;
    if (!force && now - lastPinnedSyncAt < PINNED_SYNC_INTERVAL_MS) return;
    pinnedSyncInFlight = true;
    try {
        const response = await fetch(API_BASE + '/api/get-chat-pins', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ token })
        });
        const data = await response.json();
        if (!data || !data.success) return;
        const remoteSet = new Set();
        const pins = Array.isArray(data.pins) ? data.pins : [];
        pins.forEach((pin) => {
            if (!pin) return;
            const key = buildChatKeyFromParts(pin.chat_id, pin.chat_type);
            if (key) remoteSet.add(key);
        });
        const hasSynced = localStorage.getItem(PINNED_SYNC_FLAG) === '1';
        const localSet = readChatKeySet(PINNED_CHATS_KEY);
        if (!hasSynced && remoteSet.size === 0 && localSet.size > 0) {
            await pushPinnedKeysToServer(localSet);
            setPinnedKeySet(localSet);
        } else {
            setPinnedKeySet(remoteSet);
        }
        localStorage.setItem(PINNED_SYNC_FLAG, '1');
    } catch (error) {
        console.error('Failed to sync pinned chats:', error);
    } finally {
        pinnedSyncInFlight = false;
        lastPinnedSyncAt = Date.now();
    }
}

async function setChatPinned(chat, pinned) {
    const key = buildChatKey(chat);
    if (!key) return;
    const wasPinned = pinnedChatKeys.has(key);
    if (pinned === wasPinned) return;
    if (pinned && !wasPinned) {
        const limit = isPremiumActive() ? PIN_LIMIT_PREMIUM : PIN_LIMIT_FREE;
        if (pinnedChatKeys.size >= limit) {
            notifications.warning(formatTemplate(t('pinned.limit.toast'), { limit }));
            return;
        }
    }
    applyPinnedKeyState(key, pinned, { render: true });
    try {
        const ok = await postChatPinUpdate(chat.id, getChatTypeForKey(chat), pinned);
        if (ok) {
            localStorage.setItem(PINNED_SYNC_FLAG, '1');
            lastPinnedSyncAt = Date.now();
            return;
        }
        applyPinnedKeyState(key, wasPinned, { render: true });
        notifications.error('Не удалось обновить закрепление');
    } catch (error) {
        applyPinnedKeyState(key, wasPinned, { render: true });
        console.error('Pin update failed:', error);
        notifications.error('Не удалось обновить закрепление');
    }
}

function setChatMuted(chat, muted) {
    const key = buildChatKey(chat);
    if (!key) return;
    if (muted) {
        mutedChatKeys.add(key);
    } else {
        mutedChatKeys.delete(key);
    }
    writeChatKeySet(MUTED_CHATS_KEY, mutedChatKeys);
    renderChats();
}

function hideChatForMe(chat) {
    const key = buildChatKey(chat);
    if (!key) return;
    hiddenChatKeys.add(key);
    writeChatKeySet(HIDDEN_CHATS_KEY, hiddenChatKeys);
    const activeSelection = getActiveChatSelection();
    const activeKey = activeSelection ? buildChatKeyFromParts(activeSelection.id, activeSelection.type) : '';
    if (activeSelection && key === activeKey) {
        resetActiveChatSelection();
    }
    renderChats();
}

const LANGUAGE_KEY = 'xipher_lang';
const PERSONAL_CHANNEL_KEY = 'xipher_personal_channel';
const THEME_KEY = 'xipher_theme';
const I18N = {
    ru: {
        'status.online': 'Онлайн',
        'menu.profile': 'Профиль',
        'menu.createChannel': 'Создать канал',
        'menu.createGroup': 'Создать группу',
        'menu.calls': 'Звонки',
        'menu.saved': 'Сохраненные сообщения',
        'menu.settings': 'Настройки',
        'menu.theme': 'Тема',
        'menu.theme.light': 'Светлая тема',
        'menu.theme.dark': 'Темная тема',
        'menu.language': 'Язык',
        'menu.language.ru': 'Русский',
        'menu.language.en': 'English',
        'menu.premium': 'Xipher Premium',
        'menu.soon': 'Скоро',
        'menu.faq': 'Xipher FAQ',
        'settings.title': 'Настройки',
        'settings.qrTitle': 'QR-профиль',
        'settings.moreTitle': 'Меню',
        'settings.editProfile': 'Редактировать профиль',
        'settings.logout': 'Выйти из аккаунта',
        'settings.closeTitle': 'Закрыть',
        'settings.nav.account': 'Мой аккаунт',
        'settings.nav.notifications': 'Уведомления и звуки',
        'settings.nav.calls': 'Звонки',
        'settings.nav.privacy': 'Приватность и безопасность',
        'settings.nav.sessions': 'Активные сеансы',
        'settings.nav.blocked': 'Заблокированные пользователи',
        'settings.nav.login': 'Login email',
        'settings.nav.language': 'Язык',
        'settings.nav.premium': 'Xipher Premium',
        'settings.nav.faq': 'Xipher FAQ',
        'settings.premium.open': 'Открыть Premium',
        'settings.account.profile': 'Профиль',
        'settings.account.photoEdit': 'Редактирование фото',
        'settings.account.changePhoto': 'Сменить фото',
        'settings.account.basic': 'Основные данные',
        'settings.account.firstName': 'Имя',
        'settings.account.firstNamePlaceholder': 'Имя',
        'settings.account.lastName': 'Фамилия',
        'settings.account.lastNamePlaceholder': 'Фамилия',
        'settings.account.bioEdit': 'Редактирование описания профиля',
        'settings.account.bioPlaceholder': 'О себе',
        'settings.account.username': 'UserName',
        'settings.account.usernameNote': 'Смена username будет доступна позже',
        'settings.account.personalChannel': 'Персональный канал',
        'settings.account.personalChannelNote': 'Выберите личный канал, который вы создали',
        'settings.account.noChannels': 'Пока нет каналов',
        'settings.account.birthday': 'День рождения',
        'settings.account.birthDayPlaceholder': 'День',
        'settings.account.birthMonthPlaceholder': 'Месяц',
        'settings.account.birthYearPlaceholder': 'Год (опц.)',
        'settings.account.birthdayNote': 'Оставьте 0, чтобы не указывать',
        'settings.save': 'Сохранить',
        'settings.notifications.title': 'Уведомления',
        'settings.notifications.desktop': 'Уведомления рабочего стола',
        'settings.notifications.sound': 'Звук сообщений',
        'settings.notifications.preview': 'Показывать превью сообщений',
        'settings.notifications.callSound': 'Звук звонков',
        'settings.notifications.vibration': 'Вибрация',
        'settings.notifications.quietHours': 'Тихие часы',
        'settings.notifications.quietRange': 'Время тишины',
        'settings.notifications.quietNote': 'Уведомления будут тихими в этом диапазоне',
        'settings.notifications.events': 'События',
        'settings.notifications.contactJoin': 'Новые контакты в Xipher-подобных чатах',
        'settings.notifications.pinned': 'Закрепленные сообщения',
        'settings.calls.title': 'Звонки',
        'settings.calls.accept': 'Принимать звонки',
        'settings.calls.who': 'Кто может звонить',
        'settings.calls.qualityTitle': 'Качество',
        'settings.calls.cameraQuality': 'Камера',
        'settings.calls.screenQuality': 'Демонстрация экрана',
        'settings.calls.qualityPremiumNote': 'HD и 60 FPS доступны в Premium.',
        'call.choose.title': 'Выберите тип звонка',
        'call.choose.video': 'С камерой',
        'call.choose.audio': 'Без камеры',
        'call.choose.groupHint': 'В группах доступны только аудио-звонки',
        'settings.privacy.autoDelete': 'Авто-удаленные сообщения',
        'settings.privacy.interval': 'Интервал',
        'settings.privacy.off': 'Выкл',
        'settings.privacy.after1d': 'Через 1 день',
        'settings.privacy.after1w': 'Через 1 неделю',
        'settings.privacy.after1m': 'Через 1 месяц',
        'settings.privacy.custom': 'Своё время',
        'settings.privacy.customDays': 'Своё время (дни)',
        'settings.privacy.customDaysPlaceholder': '30',
        'settings.privacy.personal': 'Персональные данные',
        'settings.privacy.lastSeen': 'Последнее время входа и онлайн',
        'settings.privacy.forward': 'Пересылать от тебя сообщения',
        'settings.privacy.calls': 'Звонить тебе',
        'settings.privacy.voice': 'Отправлять тебе голосовые сообщения',
        'settings.privacy.messages': 'Отправлять тебе сообщения',
        'settings.privacy.readReceipts': 'Отправлять отчеты о прочтении',
        'settings.privacy.chatListBlur': 'Размывать превью в списке чатов',
        'settings.privacy.birth': 'Смотреть твою дату рождения',
        'settings.privacy.bio': 'Смотреть описание твоего профиля',
        'settings.privacy.groups': 'Добавлять тебя в группы и каналы',
        'settings.privacy.everyone': 'Все',
        'settings.privacy.contacts': 'Друзья',
        'settings.privacy.nobody': 'Никто',
        'settings.privacy.deleteInactive': 'Удалить мой аккаунт при неактивности',
        'settings.privacy.period': 'Период',
        'settings.privacy.after1mDelete': 'Через 1 месяц',
        'settings.privacy.after3m': 'Через 3 месяца',
        'settings.privacy.after6m': 'Через 6 месяцев',
        'settings.privacy.after12m': 'Через 12 месяцев',
        'settings.privacy.after24m': 'Через 2 года',
        'settings.privacy.customPeriod': 'Кастомное время',
        'settings.privacy.customMonths': 'Кастомное время (от 1 мес.)',
        'settings.privacy.customMonthsPlaceholder': '6',
        'settings.sessions.title': 'Активные сеансы',
        'settings.sessions.current': 'Текущий сеанс (этот девайс)',
        'settings.sessions.browser': 'Браузер',
        'settings.sessions.lastActivity': 'Последняя активность',
        'settings.sessions.other': 'Другие устройства',
        'settings.sessions.empty': 'Нет других сеансов',
        'settings.sessions.end': 'Завершить',
        'settings.sessions.endSelected': 'Завершить выбранные',
        'settings.sessions.endAll': 'Завершить все остальные',
        'settings.sessions.now': 'сейчас',
        'settings.sessions.activePrefix': 'Активен',
        'settings.sessions.device': 'Сеанс',
        'settings.blocked.title': 'Заблокированные пользователи',
        'settings.blocked.note': 'Нажмите на пользователя, чтобы увидеть детали блокировки',
        'settings.blocked.empty': 'Список пуст',
        'settings.blocked.since': 'Заблокирован',
        'settings.blocked.unblock': 'Разблокировать',
        'settings.login.title': 'Login email',
        'settings.login.note': 'Email для восстановления пароля (предлагается после регистрации)',
        'settings.login.email': 'Email',
        'settings.language.title': 'Язык',
        'settings.language.note': 'Смена на русский или английский',
        'settings.language.label': 'Выбор языка',
        'settings.language.ru': 'Русский',
        'settings.language.en': 'English',
        'settings.premium.title': 'Xipher Premium',
        'settings.premium.headline': 'Больше порядка для ваших чатов',
        'settings.premium.subtitle': 'Новый уровень для чатов, папок и профиля.',
        'settings.premium.cta.subscribe': 'Подключить за {price}',
        'settings.premium.cta.active': 'Premium активен',
        'settings.premium.cta.price.trial': '9 ₽ / 7 дней',
        'settings.premium.cta.price.year': '499 ₽ / год',
        'settings.premium.cta.price.month': '99 ₽ / месяц',
        'settings.premium.manage': 'Отключить Premium',
        'settings.premium.gift.title': 'Подарить Premium другу',
        'settings.premium.gift.note': 'На 1, 6 месяцев или год. 6 месяцев — 299 ₽.',
        'settings.premium.gift.username': 'Username получателя',
        'settings.premium.gift.usernamePlaceholder': '@username',
        'settings.premium.gift.plan.month': '1 месяц',
        'settings.premium.gift.plan.half': '6 месяцев',
        'settings.premium.gift.plan.year': '1 год',
        'settings.premium.gift.send': 'Подарить Premium',
        'settings.premium.gift.error.empty': 'Введите username получателя',
        'settings.premium.gift.error.self': 'Нельзя подарить Premium самому себе',
        'settings.premium.gift.error.notFound': 'Пользователь не найден',
        'settings.premium.gift.toast.sent': 'Подарок отправлен {username}',
        'premium.gift.payment.success': 'Оплата подарка принята. Premium будет начислен получателю.',
        'premium.gift.payment.cancel': 'Оплата подарка отменена.',
        'premium.gift.payment.toast.opened': 'Окно оплаты подарка открыто.',
        'settings.premium.metric.limit': 'Лимит папок',
        'settings.premium.metric.used': 'Использовано',
        'settings.premium.metric.remaining': 'Свободно',
        'settings.premium.plan.trial.title': 'Пробный',
        'settings.premium.plan.trial.billing': '7 дней',
        'settings.premium.plan.trial.tag': '7 дней',
        'settings.premium.plan.month.title': 'Месячный',
        'settings.premium.plan.month.billing': 'в месяц',
        'settings.premium.plan.month.tag': 'Гибко',
        'settings.premium.plan.year.title': 'Годовой',
        'settings.premium.plan.year.billing': 'в год',
        'settings.premium.plan.year.tag': '-58%',
        'settings.premium.features.title': 'Возможности Premium',
        'settings.premium.features.note': 'Ключевые улучшения для общения и профиля.',
        'settings.premium.feature.double.title': 'x2 лимиты',
        'settings.premium.feature.double.desc': 'До 1000 каналов, 10 закрепленных чатов и 20 публичных ссылок.',
        'settings.premium.feature.video.title': 'Активные видео-аватары',
        'settings.premium.feature.video.desc': 'Загружайте GIF-аватары, которые проигрываются в списке чатов.',
        'settings.premium.feature.quality.title': 'HD звонки и демки',
        'settings.premium.feature.quality.desc': 'Камера и демонстрация экрана до 1080p и 60 FPS.',
        'settings.premium.feature.bots.title': 'Боты и Bot IDE',
        'settings.premium.feature.bots.desc': 'Создавайте ботов, используйте шаблоны и редактируйте код.',
        'settings.premium.feature.badge.title': 'Профильный бейдж',
        'settings.premium.feature.badge.desc': 'Звездочка рядом с именем показывает Premium-статус.',
        'settings.premium.feature.business.title': 'Xipher для бизнеса',
        'settings.premium.feature.business.desc': 'Настройте часы работы для профиля и контактов.',
        'settings.premium.business.title': 'Xipher для бизнеса',
        'settings.premium.business.note': 'График работы на все дни недели.',
        'settings.premium.business.save': 'Сохранить график',
        'settings.premium.business.lock': 'Доступно с Premium',
        'settings.premium.business.lockedToast': 'Часы работы доступны с Premium.',
        'settings.premium.business.saved': 'График работы сохранен',
        'settings.premium.business.error': 'Не удалось сохранить график',
        'settings.premium.business.closed': 'Закрыто',
        'settings.premium.expires': 'До {date}',
        'settings.premium.payment.title': 'Оплата Premium',
        'settings.premium.payment.note.yoomoney': 'Оплата проходит на защищенной странице YooMoney.',
        'settings.premium.payment.note.stripe': 'Оплата проходит на защищенной странице Stripe.',
        'settings.premium.payment.provider.yoomoney': 'РФ карты (ЮMoney)',
        'settings.premium.payment.provider.stripe': 'Stripe (международные карты)',
        'settings.premium.payment.method.card': 'Банковской картой',
        'settings.premium.payment.method.wallet': 'Кошельком ЮMoney',
        'settings.premium.payment.pay': 'Перейти к оплате',
        'settings.premium.payment.cancel': 'Отмена',
        'settings.premium.payment.footnote': 'Окно оплаты откроется отдельно.',
        'settings.premium.payment.toast.opened': 'Открыто окно оплаты. Premium активируется после подтверждения.',
        'settings.premium.payment.toast.error': 'Не удалось создать платеж.',
        'settings.premium.payment.toast.success': 'Оплата принята. Проверяем статус Premium...',
        'settings.premium.payment.status.pending': 'Ожидание оплаты',
        'settings.premium.payment.status.paid': 'Оплата подтверждена',
        'settings.premium.payment.timer': 'Ожидание {time}',
        'profile.business.title': 'Часы работы',
        'profile.business.status.open': 'Открыто',
        'profile.business.status.closed': 'Закрыто',
        'profile.business.until': 'до {time}',
        'profile.business.opensIn': 'откроется через {time}',
        'profile.business.opensToday': 'откроется в {time}',
        'profile.business.opensDay': 'откроется {day} в {time}',
        'settings.premium.cancel.title': 'Отключить Premium?',
        'settings.premium.cancel.note': 'Premium останется активным до конца оплаченного периода.',
        'settings.premium.cancel.no': 'Отмена',
        'settings.premium.cancel.yes': 'Отключить',
        'settings.premium.status.active': 'Premium активен',
        'settings.premium.status.free': 'Free план',
        'settings.premium.toast.active': 'Premium активирован',
        'settings.premium.toast.cancel': 'Отключение запланировано',
        'settings.premium.toast.error': 'Не удалось обновить подписку',
        'settings.premium.avatar.locked': 'GIF-аватары доступны только в Premium.',
        'premium.gift.preview': 'Premium в подарок',
        'premium.gift.received.title': 'Вам подарили Premium',
        'premium.gift.sent.title': 'Вы подарили Premium',
        'premium.gift.from': 'от {username}',
        'premium.gift.to': 'для {username}',
        'premium.badge': 'Профильный бейдж',
        'pinned.limit.toast': 'Лимит закреплений: {limit}.',
        'settings.business.day.mon': 'Пн',
        'settings.business.day.tue': 'Вт',
        'settings.business.day.wed': 'Ср',
        'settings.business.day.thu': 'Чт',
        'settings.business.day.fri': 'Пт',
        'settings.business.day.sat': 'Сб',
        'settings.business.day.sun': 'Вс',
        'folders.limit.free': 'Лимит папок: {limit}. Осталось: {remaining}.',
        'folders.limit.active': 'Premium активен: {used}/{limit} папок.',
        'folders.limit.reached': 'Лимит папок исчерпан. Premium даст до {limitPremium}.',
        'folders.limit.toast': 'Лимит папок исчерпан. Premium увеличит до {limitPremium}.',
        'settings.faq.title': 'Xipher FAQ',
        'settings.faq.note': 'Ответы на вопросы о Xipher как в Android-клиенте.',
        'settings.faq.q1': 'Как создать канал или группу?',
        'settings.faq.a1': 'Откройте меню (☰) и выберите “Создать канал” или “Создать группу”.',
        'settings.faq.q2': 'Как изменить тему?',
        'settings.faq.a2': 'В меню переключите тему или откройте “Настройки” → “Язык”.',
        'settings.faq.q3': 'Где найти QR-профиль?',
        'settings.faq.a3': 'Откройте “Настройки” и нажмите кнопку QR в правом верхнем углу.',
        'settings.faq.q4': 'Почему боты за Premium?',
        'settings.faq.a4': 'Мы размещаем ваши проекты на хостинге, поэтому создание ботов — платная функция.',
        'chat.searchPlaceholder': 'Поиск чатов...',
        'chat.emptyTitle': 'Выберите чат',
        'chat.emptySubtitle': 'Выберите чат из списка слева, чтобы начать общение',
        'chat.headerTitle': 'Выберите чат',
        'chat.headerSubtitle': 'Начните общение',
        'chat.typing': 'Печатает',
        'chat.typingWithName': 'Печатает {name}',
        'chat.typingMany': 'Печатают {count} участников',
        'chat.messagePlaceholder': 'Введите сообщение...',
        'chat.spoiler.preview': 'Спойлер',
        'chat.spoiler.reveal': 'Нажмите, чтобы открыть',
        'chat.spoiler.toggle': 'Спойлер',
        'chat.send': 'Отправить',
        'chat.ttl.toggle': 'Таймер',
        'chat.ttl.off': 'Выключен',
        'chat.ttl.10s': '10 сек',
        'chat.ttl.1h': '1 час',
        'chat.ttl.1d': '1 день',
        'chat.replyLabel': 'Ответ на сообщение',
        'chat.attach.file': 'Файл',
        'chat.attach.location': 'Геопозиция',
        'chat.attach.liveLocation': 'Живая геопозиция',
        'chat.attach.liveBadge': 'Live',
        'chat.attach.checklist': 'Чек-лист',
        'chat.attach.gift': 'Подарить Premium',
        'chat.checklist.title': 'Чек-лист',
        'chat.checklist.titlePlaceholder': 'Название чек-листа',
        'chat.checklist.addItem': 'Добавить пункт',
        'chat.checklist.addItemPlaceholder': 'Текст пункта',
        'chat.checklist.cancel': 'Отмена',
        'chat.checklist.send': 'Отправить',
        'chat.checklist.othersCanMark': 'Другие могут отмечать',
        'chat.checklist.othersCanAdd': 'Другие могут добавлять',
        'chat.checklist.emptyError': 'Добавьте хотя бы один пункт',
        'chat.checklist.preview': 'Чек-лист',
        'chat.checklist.previewUpdate': 'Чек-лист обновлен',
        'chat.location.loading': 'Определяем геопозицию...',
        'chat.location.permission': 'Нужен доступ к геопозиции',
        'chat.location.unavailable': 'Геопозиция недоступна',
        'chat.location.error': 'Не удалось получить геопозицию',
        'chat.location.openMap': 'Открыть на карте',
        'chat.live.title': 'Живая геопозиция',
        'chat.live.stop': 'Остановить',
        'chat.live.modalTitle': 'Живая геопозиция',
        'chat.live.modalSubtitle': 'Выберите длительность',
        'chat.live.duration.15m': '15 минут',
        'chat.live.duration.1h': '1 час',
        'chat.live.duration.8h': '8 часов',
        'chat.live.remaining.minutes': 'Осталось {minutes} мин',
        'chat.live.remaining.hours': 'Осталось {hours} ч',
        'chat.live.ended': 'Завершено',
        'chat.live.alreadyActive': 'Живая геопозиция уже активна',
        'chat.live.started': 'Живая геопозиция включена',
        'chat.live.stopped': 'Живая геопозиция остановлена',
        'chat.live.label': 'Живая геопозиция',
        'time.never': 'Никогда',
        'time.justNow': 'только что'
    },
    en: {
        'status.online': 'Online',
        'menu.profile': 'Profile',
        'menu.createChannel': 'Create channel',
        'menu.createGroup': 'Create group',
        'menu.calls': 'Calls',
        'menu.saved': 'Saved messages',
        'menu.settings': 'Settings',
        'menu.theme': 'Theme',
        'menu.theme.light': 'Light theme',
        'menu.theme.dark': 'Dark theme',
        'menu.language': 'Language',
        'menu.language.ru': 'Russian',
        'menu.language.en': 'English',
        'menu.premium': 'Xipher Premium',
        'menu.soon': 'Soon',
        'menu.faq': 'Xipher FAQ',
        'settings.title': 'Settings',
        'settings.qrTitle': 'Profile QR',
        'settings.moreTitle': 'Menu',
        'settings.editProfile': 'Edit profile',
        'settings.logout': 'Log out',
        'settings.closeTitle': 'Close',
        'settings.nav.account': 'My account',
        'settings.nav.notifications': 'Notifications & sounds',
        'settings.nav.calls': 'Calls',
        'settings.nav.privacy': 'Privacy & security',
        'settings.nav.sessions': 'Active sessions',
        'settings.nav.blocked': 'Blocked users',
        'settings.nav.login': 'Login email',
        'settings.nav.language': 'Language',
        'settings.nav.premium': 'Xipher Premium',
        'settings.nav.faq': 'Xipher FAQ',
        'settings.premium.open': 'Open Premium',
        'settings.account.profile': 'Profile',
        'settings.account.photoEdit': 'Edit photo',
        'settings.account.changePhoto': 'Change photo',
        'settings.account.basic': 'Basic info',
        'settings.account.firstName': 'First name',
        'settings.account.firstNamePlaceholder': 'First name',
        'settings.account.lastName': 'Last name',
        'settings.account.lastNamePlaceholder': 'Last name',
        'settings.account.bioEdit': 'Edit profile description',
        'settings.account.bioPlaceholder': 'About me',
        'settings.account.username': 'Username',
        'settings.account.usernameNote': 'Username changes will be available later',
        'settings.account.personalChannel': 'Personal channel',
        'settings.account.personalChannelNote': 'Pick a channel you created',
        'settings.account.noChannels': 'No channels yet',
        'settings.account.birthday': 'Birthday',
        'settings.account.birthDayPlaceholder': 'Day',
        'settings.account.birthMonthPlaceholder': 'Month',
        'settings.account.birthYearPlaceholder': 'Year (optional)',
        'settings.account.birthdayNote': 'Leave 0 to hide',
        'settings.save': 'Save',
        'settings.notifications.title': 'Notifications',
        'settings.notifications.desktop': 'Desktop notifications',
        'settings.notifications.sound': 'Message sounds',
        'settings.notifications.preview': 'Show message previews',
        'settings.notifications.callSound': 'Call sounds',
        'settings.notifications.vibration': 'Vibration',
        'settings.notifications.quietHours': 'Quiet hours',
        'settings.notifications.quietRange': 'Quiet time',
        'settings.notifications.quietNote': 'Notifications will be muted in this range',
        'settings.notifications.events': 'Events',
        'settings.notifications.contactJoin': 'New contacts in Xipher chats',
        'settings.notifications.pinned': 'Pinned messages',
        'settings.calls.title': 'Calls',
        'settings.calls.accept': 'Accept calls',
        'settings.calls.who': 'Who can call',
        'settings.calls.qualityTitle': 'Quality',
        'settings.calls.cameraQuality': 'Camera',
        'settings.calls.screenQuality': 'Screen share',
        'settings.calls.qualityPremiumNote': 'HD and 60 FPS are available in Premium.',
        'call.choose.title': 'Choose a call type',
        'call.choose.video': 'With camera',
        'call.choose.audio': 'Without camera',
        'call.choose.groupHint': 'Only audio calls are available in groups',
        'settings.privacy.autoDelete': 'Auto-delete messages',
        'settings.privacy.interval': 'Interval',
        'settings.privacy.off': 'Off',
        'settings.privacy.after1d': 'After 1 day',
        'settings.privacy.after1w': 'After 1 week',
        'settings.privacy.after1m': 'After 1 month',
        'settings.privacy.custom': 'Custom',
        'settings.privacy.customDays': 'Custom time (days)',
        'settings.privacy.customDaysPlaceholder': '30',
        'settings.privacy.personal': 'Personal data',
        'settings.privacy.lastSeen': 'Last seen & online',
        'settings.privacy.forward': 'Forward your messages',
        'settings.privacy.calls': 'Calls to you',
        'settings.privacy.voice': 'Voice messages',
        'settings.privacy.messages': 'Messages to you',
        'settings.privacy.readReceipts': 'Send read receipts',
        'settings.privacy.chatListBlur': 'Blur chat list previews',
        'settings.privacy.birth': 'See your birthday',
        'settings.privacy.bio': 'See your profile bio',
        'settings.privacy.groups': 'Add you to groups and channels',
        'settings.privacy.everyone': 'Everyone',
        'settings.privacy.contacts': 'Friends',
        'settings.privacy.nobody': 'Nobody',
        'settings.privacy.deleteInactive': 'Delete my account if inactive',
        'settings.privacy.period': 'Period',
        'settings.privacy.after1mDelete': 'After 1 month',
        'settings.privacy.after3m': 'After 3 months',
        'settings.privacy.after6m': 'After 6 months',
        'settings.privacy.after12m': 'After 12 months',
        'settings.privacy.after24m': 'After 2 years',
        'settings.privacy.customPeriod': 'Custom time',
        'settings.privacy.customMonths': 'Custom time (from 1 month)',
        'settings.privacy.customMonthsPlaceholder': '6',
        'settings.sessions.title': 'Active sessions',
        'settings.sessions.current': 'Current session (this device)',
        'settings.sessions.browser': 'Browser',
        'settings.sessions.lastActivity': 'Last activity',
        'settings.sessions.other': 'Other devices',
        'settings.sessions.empty': 'No other sessions',
        'settings.sessions.end': 'Terminate',
        'settings.sessions.endSelected': 'Terminate selected',
        'settings.sessions.endAll': 'Terminate all others',
        'settings.sessions.now': 'now',
        'settings.sessions.activePrefix': 'Active',
        'settings.sessions.device': 'Session',
        'settings.blocked.title': 'Blocked users',
        'settings.blocked.note': 'Click a user to see block details',
        'settings.blocked.empty': 'No blocked users',
        'settings.blocked.since': 'Blocked',
        'settings.blocked.unblock': 'Unblock',
        'settings.login.title': 'Login email',
        'settings.login.note': 'Recovery email (suggested after registration)',
        'settings.login.email': 'Email',
        'settings.language.title': 'Language',
        'settings.language.note': 'Switch between Russian and English',
        'settings.language.label': 'Language',
        'settings.language.ru': 'Russian',
        'settings.language.en': 'English',
        'settings.premium.title': 'Xipher Premium',
        'settings.premium.headline': 'More order for your chats',
        'settings.premium.subtitle': 'Upgrade chats, folders, and your profile.',
        'settings.premium.cta.subscribe': 'Subscribe for {price}',
        'settings.premium.cta.active': 'Premium active',
        'settings.premium.cta.price.trial': '9 ₽ / 7 days',
        'settings.premium.cta.price.year': '499 ₽ / year',
        'settings.premium.cta.price.month': '99 ₽ / month',
        'settings.premium.manage': 'Disable Premium',
        'settings.premium.gift.title': 'Gift Premium to a friend',
        'settings.premium.gift.note': '1 month, 6 months, or a year. 6 months — 299 ₽.',
        'settings.premium.gift.username': 'Recipient username',
        'settings.premium.gift.usernamePlaceholder': '@username',
        'settings.premium.gift.plan.month': '1 month',
        'settings.premium.gift.plan.half': '6 months',
        'settings.premium.gift.plan.year': '1 year',
        'settings.premium.gift.send': 'Gift Premium',
        'settings.premium.gift.error.empty': 'Enter the recipient username',
        'settings.premium.gift.error.self': 'You cannot gift Premium to yourself',
        'settings.premium.gift.error.notFound': 'User not found',
        'settings.premium.gift.toast.sent': 'Gift sent to {username}',
        'premium.gift.payment.success': 'Gift payment confirmed. Premium will be granted to the recipient.',
        'premium.gift.payment.cancel': 'Gift payment canceled.',
        'premium.gift.payment.toast.opened': 'Gift payment window opened.',
        'settings.premium.metric.limit': 'Folder limit',
        'settings.premium.metric.used': 'Used',
        'settings.premium.metric.remaining': 'Remaining',
        'settings.premium.plan.trial.title': 'Trial',
        'settings.premium.plan.trial.billing': '7 days',
        'settings.premium.plan.trial.tag': '7 days',
        'settings.premium.plan.month.title': 'Monthly',
        'settings.premium.plan.month.billing': 'per month',
        'settings.premium.plan.month.tag': 'Flexible',
        'settings.premium.plan.year.title': 'Yearly',
        'settings.premium.plan.year.billing': 'per year',
        'settings.premium.plan.year.tag': '-58%',
        'settings.premium.features.title': 'Premium features',
        'settings.premium.features.note': 'Key upgrades for chats and your profile.',
        'settings.premium.feature.double.title': 'x2 limits',
        'settings.premium.feature.double.desc': 'Up to 1000 channels, 10 pinned chats, 20 public links.',
        'settings.premium.feature.video.title': 'Animated video avatars',
        'settings.premium.feature.video.desc': 'Upload GIF avatars that play in chat lists.',
        'settings.premium.feature.quality.title': 'HD calls and screen share',
        'settings.premium.feature.quality.desc': 'Camera and screen share up to 1080p at 60 FPS.',
        'settings.premium.feature.bots.title': 'Bots & Bot IDE',
        'settings.premium.feature.bots.desc': 'Create bots, use templates, and edit code in the built-in IDE.',
        'settings.premium.feature.badge.title': 'Profile Badge',
        'settings.premium.feature.badge.desc': 'A star next to your name shows Premium status.',
        'settings.premium.feature.business.title': 'Xipher for Business',
        'settings.premium.feature.business.desc': 'Set business hours for your profile and contacts.',
        'settings.premium.business.title': 'Xipher for Business',
        'settings.premium.business.note': 'Working hours for every day of the week.',
        'settings.premium.business.save': 'Save hours',
        'settings.premium.business.lock': 'Available with Premium',
        'settings.premium.business.lockedToast': 'Business hours are available with Premium.',
        'settings.premium.business.saved': 'Business hours saved',
        'settings.premium.business.error': 'Failed to save business hours',
        'settings.premium.business.closed': 'Closed',
        'settings.premium.expires': 'Until {date}',
        'settings.premium.payment.title': 'Premium checkout',
        'settings.premium.payment.note.yoomoney': 'Payment happens on a secure YooMoney page.',
        'settings.premium.payment.note.stripe': 'Payment happens on a secure Stripe page.',
        'settings.premium.payment.provider.yoomoney': 'Russian cards (YooMoney)',
        'settings.premium.payment.provider.stripe': 'Stripe (international cards)',
        'settings.premium.payment.method.card': 'Bank card',
        'settings.premium.payment.method.wallet': 'YooMoney wallet',
        'settings.premium.payment.pay': 'Proceed to payment',
        'settings.premium.payment.cancel': 'Cancel',
        'settings.premium.payment.footnote': 'The payment window will open separately.',
        'settings.premium.payment.toast.opened': 'Payment window opened. Premium activates after confirmation.',
        'settings.premium.payment.toast.error': 'Failed to create payment.',
        'settings.premium.payment.toast.success': 'Payment received. Checking Premium status...',
        'settings.premium.payment.status.pending': 'Payment pending',
        'settings.premium.payment.status.paid': 'Payment confirmed',
        'settings.premium.payment.timer': 'Waiting {time}',
        'profile.business.title': 'Business hours',
        'profile.business.status.open': 'Open',
        'profile.business.status.closed': 'Closed',
        'profile.business.until': 'until {time}',
        'profile.business.opensIn': 'opens in {time}',
        'profile.business.opensToday': 'opens at {time}',
        'profile.business.opensDay': 'opens {day} at {time}',
        'settings.premium.cancel.title': 'Disable Premium?',
        'settings.premium.cancel.note': 'Premium stays active until the end of the paid period.',
        'settings.premium.cancel.no': 'Cancel',
        'settings.premium.cancel.yes': 'Disable',
        'settings.premium.status.active': 'Premium active',
        'settings.premium.status.free': 'Free plan',
        'settings.premium.toast.active': 'Premium activated',
        'settings.premium.toast.cancel': 'Cancellation scheduled',
        'settings.premium.toast.error': 'Unable to update subscription',
        'settings.premium.avatar.locked': 'GIF avatars are available with Premium only.',
        'premium.gift.preview': 'Premium gift',
        'premium.gift.received.title': 'You received Premium',
        'premium.gift.sent.title': 'You gifted Premium',
        'premium.gift.from': 'from {username}',
        'premium.gift.to': 'for {username}',
        'premium.badge': 'Profile Badge',
        'pinned.limit.toast': 'Pinned chat limit: {limit}.',
        'settings.business.day.mon': 'Mon',
        'settings.business.day.tue': 'Tue',
        'settings.business.day.wed': 'Wed',
        'settings.business.day.thu': 'Thu',
        'settings.business.day.fri': 'Fri',
        'settings.business.day.sat': 'Sat',
        'settings.business.day.sun': 'Sun',
        'folders.limit.free': 'Folder limit: {limit}. Remaining: {remaining}.',
        'folders.limit.active': 'Premium active: {used}/{limit} folders.',
        'folders.limit.reached': 'Folder limit reached. Premium unlocks up to {limitPremium}.',
        'folders.limit.toast': 'Folder limit reached. Premium increases it to {limitPremium}.',
        'settings.faq.title': 'Xipher FAQ',
        'settings.faq.note': 'Answers about Xipher like in the Android app.',
        'settings.faq.q1': 'How to create a channel or group?',
        'settings.faq.a1': 'Open the menu (☰) and choose “Create channel” or “Create group”.',
        'settings.faq.q2': 'How to change the theme?',
        'settings.faq.a2': 'Switch the theme in the menu or open “Settings” → “Language”.',
        'settings.faq.q3': 'Where to find the profile QR?',
        'settings.faq.a3': 'Open “Settings” and tap the QR button in the top right.',
        'settings.faq.q4': 'Why are bots Premium?',
        'settings.faq.a4': 'We host your projects, so creating bots is a paid feature.',
        'chat.searchPlaceholder': 'Search chats...',
        'chat.emptyTitle': 'Choose a chat',
        'chat.emptySubtitle': 'Select a chat from the left to start messaging',
        'chat.headerTitle': 'Choose a chat',
        'chat.headerSubtitle': 'Start messaging',
        'chat.typing': 'Typing',
        'chat.typingWithName': 'Typing {name}',
        'chat.typingMany': 'Typing {count} people',
        'chat.messagePlaceholder': 'Type a message...',
        'chat.spoiler.preview': 'Spoiler',
        'chat.spoiler.reveal': 'Tap to reveal',
        'chat.spoiler.toggle': 'Spoiler mode',
        'chat.send': 'Send',
        'chat.ttl.toggle': 'Timer',
        'chat.ttl.off': 'Off',
        'chat.ttl.10s': '10s',
        'chat.ttl.1h': '1 hour',
        'chat.ttl.1d': '1 day',
        'chat.replyLabel': 'Reply to message',
        'chat.attach.file': 'File',
        'chat.attach.location': 'Location',
        'chat.attach.liveLocation': 'Live location',
        'chat.attach.liveBadge': 'Live',
        'chat.attach.checklist': 'Checklist',
        'chat.attach.gift': 'Gift Premium',
        'chat.checklist.title': 'Checklist',
        'chat.checklist.titlePlaceholder': 'Checklist title',
        'chat.checklist.addItem': 'Add item',
        'chat.checklist.addItemPlaceholder': 'Item text',
        'chat.checklist.cancel': 'Cancel',
        'chat.checklist.send': 'Send',
        'chat.checklist.othersCanMark': 'Others can check',
        'chat.checklist.othersCanAdd': 'Others can add items',
        'chat.checklist.emptyError': 'Add at least one item',
        'chat.checklist.preview': 'Checklist',
        'chat.checklist.previewUpdate': 'Checklist updated',
        'chat.location.loading': 'Fetching location...',
        'chat.location.permission': 'Location access required',
        'chat.location.unavailable': 'Location unavailable',
        'chat.location.error': 'Failed to get location',
        'chat.location.openMap': 'Open on map',
        'chat.live.title': 'Live location',
        'chat.live.stop': 'Stop',
        'chat.live.modalTitle': 'Live location',
        'chat.live.modalSubtitle': 'Choose duration',
        'chat.live.duration.15m': '15 minutes',
        'chat.live.duration.1h': '1 hour',
        'chat.live.duration.8h': '8 hours',
        'chat.live.remaining.minutes': 'Left {minutes} min',
        'chat.live.remaining.hours': 'Left {hours} h',
        'chat.live.ended': 'Ended',
        'chat.live.alreadyActive': 'Live location is already active',
        'chat.live.started': 'Live location started',
        'chat.live.stopped': 'Live location stopped',
        'chat.live.label': 'Live location',
        'time.never': 'Never',
        'time.justNow': 'just now'
    }
};

function getLanguage() {
    const stored = localStorage.getItem(LANGUAGE_KEY);
    return stored === 'en' ? 'en' : 'ru';
}

function t(key, lang) {
    const locale = lang || getLanguage();
    return (I18N[locale] && I18N[locale][key]) || I18N.ru[key] || key;
}

const CHECKLIST_PREFIX = '[[XIPHER_CHECKLIST]]';
const CHECKLIST_UPDATE_PREFIX = '[[XIPHER_CHECKLIST_UPDATE]]';
const checklistStore = new Map();
const checklistPendingUpdates = new Map();
const checklistSeenUpdateIds = new Set();

function resetChecklistState() {
    checklistStore.clear();
    checklistPendingUpdates.clear();
    checklistSeenUpdateIds.clear();
}

function isChecklistContent(content) {
    return typeof content === 'string' && content.startsWith(CHECKLIST_PREFIX);
}

function isChecklistUpdateContent(content) {
    return typeof content === 'string' && content.startsWith(CHECKLIST_UPDATE_PREFIX);
}

function parseChecklistPayloadContent(content) {
    if (!isChecklistContent(content)) return null;
    const raw = content.slice(CHECKLIST_PREFIX.length).trim();
    if (!raw) return null;
    try {
        const payload = JSON.parse(raw);
        if (!payload || !payload.id) return null;
        return payload;
    } catch (error) {
        return null;
    }
}

function parseChecklistUpdatePayloadContent(content) {
    if (!isChecklistUpdateContent(content)) return null;
    const raw = content.slice(CHECKLIST_UPDATE_PREFIX.length).trim();
    if (!raw) return null;
    try {
        const payload = JSON.parse(raw);
        if (!payload || !payload.checklistId) return null;
        return payload;
    } catch (error) {
        return null;
    }
}

function isPremiumGiftContent(content) {
    return typeof content === 'string' && content.startsWith(PREMIUM_GIFT_PREFIX);
}

function parsePremiumGiftPayloadContent(content) {
    if (!isPremiumGiftContent(content)) return null;
    const raw = content.slice(PREMIUM_GIFT_PREFIX.length).trim();
    if (!raw) return null;
    try {
        const payload = JSON.parse(raw);
        if (!payload || typeof payload !== 'object') return null;
        const plan = normalizePremiumGiftPlan(payload.plan);
        let months = Number(payload.months);
        if (!Number.isFinite(months) || months <= 0) {
            const config = PREMIUM_GIFT_PLANS[plan];
            months = config ? config.months : 0;
        }
        if (!months) return null;
        let price = Number(payload.price);
        if (!Number.isFinite(price) || price <= 0) {
            const priceKey = months === 1 ? 'month' : (months >= 12 ? 'year' : (months === 6 ? 'half' : plan));
            const config = PREMIUM_GIFT_PLANS[priceKey] || PREMIUM_GIFT_PLANS[plan];
            price = config ? config.price : 0;
        }
        return {
            months,
            price,
            from: typeof payload.from === 'string' ? payload.from : '',
            to: typeof payload.to === 'string' ? payload.to : ''
        };
    } catch (error) {
        return null;
    }
}

function getPremiumGiftPreviewTextFromPayload(payload) {
    if (!payload) return '';
    const duration = formatPremiumGiftDuration(payload.months);
    const base = t('premium.gift.preview');
    return duration ? `${base} · ${duration}` : base;
}

function hasProcessedChecklistUpdateId(messageId) {
    if (!messageId) return false;
    return checklistSeenUpdateIds.has(String(messageId));
}

function markChecklistUpdateProcessed(messageId) {
    if (!messageId) return;
    checklistSeenUpdateIds.add(String(messageId));
}

function getChecklistPreviewTextFromPayload(payload) {
    if (!payload) return '';
    const title = (payload.title || '').trim();
    const items = Array.isArray(payload.items) ? payload.items : [];
    const done = items.filter(item => item && item.done).length;
    const total = items.length;
    const base = title ? `${t('chat.checklist.preview')}: ${title}` : t('chat.checklist.preview');
    return total ? `${base} · ${done}/${total}` : base;
}

function getChecklistPreviewTextFromState(state) {
    if (!state) return '';
    const done = Array.from(state.items.values()).filter(item => item && item.done).length;
    const total = state.items.size;
    const base = state.title ? `${t('chat.checklist.preview')}: ${state.title}` : t('chat.checklist.preview');
    return total ? `${base} · ${done}/${total}` : base;
}

function formatMessagePreviewText(messageOrContent) {
    const raw = typeof messageOrContent === 'string'
        ? messageOrContent
        : (messageOrContent?.content || '');
    if (!raw || typeof raw !== 'string') return '';
    if (isSpoilerContent(raw)) {
        return t('chat.spoiler.preview');
    }
    const content = stripSpoilerContent(raw);
    if (isChecklistUpdateContent(content)) {
        return t('chat.checklist.previewUpdate');
    }
    const giftPayload = parsePremiumGiftPayloadContent(content);
    if (giftPayload) {
        return getPremiumGiftPreviewTextFromPayload(giftPayload);
    }
    if (isPremiumGiftContent(content)) {
        return t('premium.gift.preview');
    }
    const payload = parseChecklistPayloadContent(content);
    if (payload) {
        return getChecklistPreviewTextFromPayload(payload);
    }
    if (isChecklistContent(content)) {
        return t('chat.checklist.preview');
    }
    return content;
}

function isMessageFromCurrentUser(msg) {
    if (!msg) return false;
    const currentId = getCurrentUserId();
    const senderId = msg.sender_id || msg.senderId || msg.from_user_id || msg.fromUserId || '';
    if (currentId && senderId) {
        return String(senderId) === String(currentId);
    }
    if (typeof msg.sent === 'boolean') return msg.sent;
    if (msg.sent === 'true' || msg.sent === 1) return true;
    if (msg.sent === 'false' || msg.sent === 0) return false;
    return false;
}

function isTrueish(value) {
    return value === true || value === 'true' || value === 1 || value === '1';
}

function parseReplyMarkupFromMessage(msg) {
    if (!msg || !msg.reply_markup) return null;
    if (typeof msg.reply_markup === 'object') return msg.reply_markup;
    if (typeof msg.reply_markup === 'string') {
        const raw = msg.reply_markup.trim();
        if (!raw) return null;
        try {
            return JSON.parse(raw);
        } catch (_) {
            return null;
        }
    }
    return null;
}

function getReplyKeyboardElements() {
    return {
        container: document.getElementById('replyKeyboard'),
        grid: document.getElementById('replyKeyboardGrid'),
        input: document.getElementById('messageInput')
    };
}

function setReplyKeyboardPlaceholder(placeholder) {
    const { input } = getReplyKeyboardElements();
    if (!input) return;
    if (!replyKeyboardState.originalPlaceholder) {
        replyKeyboardState.originalPlaceholder = input.placeholder || '';
    }
    if (placeholder) {
        input.placeholder = placeholder;
        replyKeyboardState.placeholder = placeholder;
    } else if (replyKeyboardState.originalPlaceholder) {
        input.placeholder = replyKeyboardState.originalPlaceholder;
        replyKeyboardState.placeholder = '';
    }
}

function resetReplyKeyboardState() {
    const { container, grid } = getReplyKeyboardElements();
    if (grid) {
        grid.innerHTML = '';
    }
    if (container) {
        container.style.display = 'none';
        container.classList.remove('is-resize');
    }
    setReplyKeyboardPlaceholder('');
    replyKeyboardState.chatId = null;
    replyKeyboardState.markup = null;
    replyKeyboardState.oneTime = false;
    replyKeyboardState.resize = false;
    replyKeyboardState.active = false;
}

function normalizeReplyKeyboardRows(keyboard) {
    if (!Array.isArray(keyboard)) return [];
    const rows = [];
    keyboard.forEach((row) => {
        if (!Array.isArray(row)) return;
        const buttons = row.map((button) => {
            if (typeof button === 'string') {
                return { text: button };
            }
            if (!button || typeof button !== 'object') return null;
            const text = typeof button.text === 'string' ? button.text : '';
            if (!text) return null;
            return { ...button, text };
        }).filter(Boolean);
        if (buttons.length) {
            rows.push(buttons);
        }
    });
    return rows;
}

function renderReplyKeyboard(markup) {
    const { container, grid } = getReplyKeyboardElements();
    if (!container || !grid) return;

    const rows = normalizeReplyKeyboardRows(markup.keyboard);
    grid.innerHTML = '';
    if (!rows.length) {
        resetReplyKeyboardState();
        return;
    }

    rows.forEach((row) => {
        const rowEl = document.createElement('div');
        rowEl.className = 'reply-keyboard-row';
        row.forEach((button) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'reply-keyboard-button';
            btn.textContent = button.text || '';
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                handleReplyKeyboardButtonClick(button);
            });
            rowEl.appendChild(btn);
        });
        grid.appendChild(rowEl);
    });

    const resize = isTrueish(markup.resize_keyboard);
    const placeholder = typeof markup.input_field_placeholder === 'string'
        ? markup.input_field_placeholder.trim()
        : '';

    container.classList.toggle('is-resize', resize);
    container.style.display = 'flex';

    replyKeyboardState.chatId = currentChat?.id || null;
    replyKeyboardState.markup = markup;
    replyKeyboardState.oneTime = isTrueish(markup.one_time_keyboard);
    replyKeyboardState.resize = resize;
    replyKeyboardState.active = true;

    setReplyKeyboardPlaceholder(placeholder);
}

function applyReplyKeyboardFromMarkup(markup, { isIncoming = true } = {}) {
    if (!markup || typeof markup !== 'object') return;
    if (!currentChat || !currentChat.is_bot) return;
    if (!isIncoming) return;
    if (markup.inline_keyboard) return;
    if (isTrueish(markup.remove_keyboard)) {
        resetReplyKeyboardState();
        return;
    }
    if (Array.isArray(markup.keyboard)) {
        renderReplyKeyboard(markup);
    }
}

function handleChecklistUpdateMessage(msg) {
    const content = typeof msg?.content === 'string' ? msg.content : '';
    if (!isChecklistUpdateContent(content)) return false;
    if (msg?.id && hasProcessedChecklistUpdateId(msg.id)) return true;
    const payload = parseChecklistUpdatePayloadContent(content);
    if (payload) {
        applyChecklistUpdatePayload(payload);
    }
    if (msg?.id) {
        markChecklistUpdateProcessed(msg.id);
    }
    return true;
}

function getMessagePreviewFromElement(el) {
    if (!el) return '';
    const checklistId = el.dataset.checklistId;
    if (checklistId && checklistStore.has(checklistId)) {
        return getChecklistPreviewTextFromState(checklistStore.get(checklistId));
    }
    const giftEl = el.querySelector('.message-gift');
    if (giftEl) {
        return giftEl.dataset.giftPreview || t('premium.gift.preview');
    }
    const checklistEl = el.querySelector('.message-checklist');
    if (checklistEl) {
        const title = checklistEl.dataset.checklistTitle || '';
        return title ? `${t('chat.checklist.preview')}: ${title}` : t('chat.checklist.preview');
    }
    const textEl = el.querySelector('.message-text');
    if (textEl) {
        if (textEl.classList.contains('spoiler-blur') && !textEl.classList.contains('is-revealed')) {
            return t('chat.spoiler.preview');
        }
        return textEl.innerText || textEl.textContent || '';
    }
    const spoilerMedia = el.querySelector('.spoiler-media');
    if (spoilerMedia && !spoilerMedia.classList.contains('is-revealed')) {
        return t('chat.spoiler.preview');
    }
    return '';
}

function updateChecklistProgress(state) {
    if (!state || !state.progressEl) return;
    const done = Array.from(state.items.values()).filter(item => item && item.done).length;
    const total = state.items.size;
    state.progressEl.textContent = `${done}/${total}`;
}

function setChecklistItemDone(state, itemId, done, options = {}) {
    if (!state || !itemId) return;
    const item = state.items.get(itemId);
    if (!item) return;
    const nextValue = Boolean(done);
    if (item.done === nextValue && !options.force) return;
    item.done = nextValue;
    const row = state.itemElements.get(itemId);
    if (row) {
        row.checkbox.checked = nextValue;
        row.root.classList.toggle('is-done', nextValue);
    }
    updateChecklistProgress(state);
    if (!options.silent) {
        sendChecklistUpdatePayload({
            checklistId: state.id,
            updates: [{ id: itemId, done: nextValue }]
        });
    }
}

function buildChecklistItemRow(state, item) {
    const row = document.createElement('label');
    row.className = 'checklist-item';
    row.dataset.itemId = item.id;
    if (item.done) {
        row.classList.add('is-done');
    }

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = Boolean(item.done);
    checkbox.disabled = !state.canMark;
    checkbox.addEventListener('click', (e) => e.stopPropagation());

    const text = document.createElement('span');
    text.className = 'checklist-text';
    text.textContent = item.text || '';

    row.appendChild(checkbox);
    row.appendChild(text);

    if (state.canMark) {
        checkbox.addEventListener('change', (e) => {
            e.stopPropagation();
            setChecklistItemDone(state, item.id, checkbox.checked);
        });
    }

    return { root: row, checkbox, text };
}

function appendChecklistItem(state, item) {
    if (!state || !item || !item.id) return;
    if (state.items.has(item.id)) return;
    const normalized = {
        id: item.id,
        text: item.text || '',
        done: Boolean(item.done)
    };
    state.items.set(normalized.id, normalized);
    state.order.push(normalized.id);
    const row = buildChecklistItemRow(state, normalized);
    state.itemElements.set(normalized.id, row);
    if (state.listEl) {
        state.listEl.appendChild(row.root);
    }
    updateChecklistProgress(state);
}

function queueChecklistUpdate(payload) {
    if (!payload || !payload.checklistId) return;
    const pending = checklistPendingUpdates.get(payload.checklistId) || [];
    pending.push(payload);
    checklistPendingUpdates.set(payload.checklistId, pending);
}

function applyChecklistUpdatePayload(payload) {
    if (!payload || !payload.checklistId) return;
    const state = checklistStore.get(payload.checklistId);
    if (!state) {
        queueChecklistUpdate(payload);
        return;
    }
    const updates = Array.isArray(payload.updates) ? payload.updates : [];
    updates.forEach(update => {
        if (!update || !update.id) return;
        setChecklistItemDone(state, update.id, Boolean(update.done), { silent: true });
    });
    const added = Array.isArray(payload.added) ? payload.added : [];
    added.forEach(item => {
        if (!item || !item.id) return;
        appendChecklistItem(state, {
            id: item.id,
            text: item.text || '',
            done: Boolean(item.done)
        });
    });
    updateChecklistProgress(state);
}

function applyPendingChecklistUpdates(checklistId) {
    if (!checklistId) return;
    const pending = checklistPendingUpdates.get(checklistId);
    if (!pending || pending.length === 0) return;
    pending.forEach(applyChecklistUpdatePayload);
    checklistPendingUpdates.delete(checklistId);
}

function buildChecklistElement(payload, msg, messageDiv) {
    if (!payload || !payload.id) return null;
    const isOwner = isMessageFromCurrentUser(msg);
    const canMark = isOwner || payload.othersCanMark !== false;
    const canAdd = isOwner || payload.othersCanAdd !== false;

    const container = document.createElement('div');
    container.className = 'message-checklist';
    container.dataset.checklistId = payload.id;
    container.dataset.checklistTitle = payload.title || '';

    const header = document.createElement('div');
    header.className = 'checklist-header';

    const titleEl = document.createElement('div');
    titleEl.className = 'checklist-title';
    titleEl.textContent = (payload.title || '').trim() || t('chat.checklist.preview');

    const progressEl = document.createElement('div');
    progressEl.className = 'checklist-progress';

    header.appendChild(titleEl);
    header.appendChild(progressEl);

    const listEl = document.createElement('div');
    listEl.className = 'checklist-items';

    const state = {
        id: payload.id,
        title: payload.title || '',
        canMark,
        canAdd,
        items: new Map(),
        itemElements: new Map(),
        order: [],
        container,
        listEl,
        progressEl
    };

    const items = Array.isArray(payload.items) ? payload.items : [];
    items.forEach(item => appendChecklistItem(state, item));
    updateChecklistProgress(state);

    container.appendChild(header);
    container.appendChild(listEl);

    if (canAdd) {
        const addRow = document.createElement('div');
        addRow.className = 'checklist-add-row';
        addRow.style.display = 'none';

        const addInput = document.createElement('input');
        addInput.type = 'text';
        addInput.className = 'checklist-add-input';
        addInput.placeholder = t('chat.checklist.addItemPlaceholder');

        const addConfirm = document.createElement('button');
        addConfirm.type = 'button';
        addConfirm.className = 'checklist-add-confirm';
        addConfirm.textContent = t('chat.checklist.addItem');

        const addCancel = document.createElement('button');
        addCancel.type = 'button';
        addCancel.className = 'checklist-add-cancel';
        addCancel.textContent = t('chat.checklist.cancel');

        const closeAddRow = () => {
            addInput.value = '';
            addRow.style.display = 'none';
        };

        const submitNewItem = () => {
            const text = addInput.value.trim();
            if (!text) return;
            const newItem = {
                id: generateChecklistItemId(),
                text,
                done: false
            };
            appendChecklistItem(state, newItem);
            sendChecklistUpdatePayload({
                checklistId: state.id,
                added: [newItem]
            });
            closeAddRow();
        };

        addConfirm.addEventListener('click', (e) => {
            e.stopPropagation();
            submitNewItem();
        });
        addCancel.addEventListener('click', (e) => {
            e.stopPropagation();
            closeAddRow();
        });
        addInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitNewItem();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                closeAddRow();
            }
        });
        addRow.addEventListener('click', (e) => e.stopPropagation());

        addRow.appendChild(addInput);
        addRow.appendChild(addConfirm);
        addRow.appendChild(addCancel);

        const addButton = document.createElement('button');
        addButton.type = 'button';
        addButton.className = 'checklist-add';
        addButton.textContent = `+ ${t('chat.checklist.addItem')}`;
        addButton.addEventListener('click', (e) => {
            e.stopPropagation();
            addRow.style.display = 'flex';
            addInput.focus();
        });

        container.appendChild(addRow);
        container.appendChild(addButton);
    }

    if (messageDiv) {
        messageDiv.dataset.checklistId = payload.id;
        messageDiv.dataset.checklistTitle = payload.title || '';
    }

    checklistStore.set(payload.id, state);
    applyPendingChecklistUpdates(payload.id);
    return container;
}

function buildPremiumGiftElement(payload, msg) {
    if (!payload) return null;
    const isSent = isMessageFromCurrentUser(msg);
    const card = document.createElement('div');
    card.className = 'message-gift';
    if (payload.months) {
        card.dataset.giftMonths = String(payload.months);
    }
    if (payload.price) {
        card.dataset.giftPrice = String(payload.price);
    }
    const preview = getPremiumGiftPreviewTextFromPayload(payload);
    if (preview) {
        card.dataset.giftPreview = preview;
    }

    const top = document.createElement('div');
    top.className = 'message-gift-top';
    const icon = document.createElement('div');
    icon.className = 'message-gift-icon';
    icon.innerHTML = `
        <svg viewBox="0 0 64 64" aria-hidden="true" focusable="false">
            <rect class="gift-lid" x="10" y="20" width="44" height="10" rx="4" />
            <rect class="gift-box" x="10" y="28" width="44" height="28" rx="8" />
            <rect class="gift-ribbon" x="30" y="20" width="4" height="36" rx="2" />
            <rect class="gift-ribbon" x="10" y="36" width="44" height="4" rx="2" />
            <path class="gift-bow" d="M24 20c-4 0-6-3-6-6 0-3 2-6 6-6 5 0 8 6 8 6s-3 6-8 6z" />
            <path class="gift-bow" d="M40 20c4 0 6-3 6-6 0-3-2-6-6-6-5 0-8 6-8 6s3 6 8 6z" />
        </svg>
    `;
    top.appendChild(icon);
    card.appendChild(top);

    const body = document.createElement('div');
    body.className = 'message-gift-body';
    const title = document.createElement('div');
    title.className = 'message-gift-title';
    title.textContent = t(isSent ? 'premium.gift.sent.title' : 'premium.gift.received.title');

    const subtitle = document.createElement('div');
    subtitle.className = 'message-gift-subtitle';
    const fromLabel = payload.from ? `@${payload.from}` : '';
    const toLabel = payload.to ? `@${payload.to}` : '';
    const usernameLabel = isSent ? toLabel : fromLabel;
    if (usernameLabel) {
        const key = isSent ? 'premium.gift.to' : 'premium.gift.from';
        subtitle.textContent = formatTemplate(t(key), { username: usernameLabel });
    }

    const meta = document.createElement('div');
    meta.className = 'message-gift-meta';
    const duration = formatPremiumGiftDuration(payload.months);
    const price = formatPremiumGiftPrice(payload.price);
    if (duration) {
        const durationEl = document.createElement('span');
        durationEl.className = 'message-gift-duration';
        durationEl.textContent = duration;
        meta.appendChild(durationEl);
    }
    if (duration && price) {
        const dot = document.createElement('span');
        dot.className = 'message-gift-dot';
        dot.textContent = '•';
        meta.appendChild(dot);
    }
    if (price) {
        const priceEl = document.createElement('span');
        priceEl.className = 'message-gift-price';
        priceEl.textContent = price;
        meta.appendChild(priceEl);
    }

    body.appendChild(title);
    if (usernameLabel) body.appendChild(subtitle);
    if (duration || price) body.appendChild(meta);
    card.appendChild(body);

    return card;
}

function setTheme(isLight) {
    const bodyEl = document.body;
    if (isLight) {
        bodyEl.setAttribute('data-theme', 'light');
    } else {
        bodyEl.removeAttribute('data-theme');
    }
    const menuToggle = document.getElementById('menuThemeToggle');
    if (menuToggle) {
        menuToggle.checked = isLight;
    }
    updateThemeLabel(isLight);
    try {
        localStorage.setItem(THEME_KEY, isLight ? 'light' : 'dark');
    } catch (_) {}
}

function updateThemeLabel(isLight) {
    const menuLabel = document.getElementById('menuThemeLabel');
    if (menuLabel) {
        menuLabel.textContent = t(isLight ? 'menu.theme.light' : 'menu.theme.dark');
    }
}

function syncThemeFromStorage() {
    const stored = localStorage.getItem(THEME_KEY);
    if (stored === 'light') {
        setTheme(true);
    } else if (stored === 'dark') {
        setTheme(false);
    } else {
        const isLight = document.body.getAttribute('data-theme') === 'light';
        const menuToggle = document.getElementById('menuThemeToggle');
        if (menuToggle) {
            menuToggle.checked = isLight;
        }
        updateThemeLabel(isLight);
    }
}

function setLanguage(lang) {
    const normalized = lang === 'en' ? 'en' : 'ru';
    try {
        localStorage.setItem(LANGUAGE_KEY, normalized);
    } catch (_) {}
    applyLanguage(normalized);
    const menuLanguageValue = document.getElementById('menuLanguageValue');
    if (menuLanguageValue) {
        menuLanguageValue.textContent = t(normalized === 'en' ? 'menu.language.en' : 'menu.language.ru', normalized);
    }
    const settingsLanguageSelect = document.getElementById('settingsLanguageSelect');
    if (settingsLanguageSelect) {
        settingsLanguageSelect.value = normalized;
    }
}

function syncLanguageFromStorage() {
    const stored = localStorage.getItem(LANGUAGE_KEY) || 'ru';
    setLanguage(stored);
}

function applyLanguage(lang) {
    const dict = I18N[lang] || I18N.ru;
    document.documentElement.lang = lang === 'en' ? 'en' : 'ru';
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (dict[key]) {
            el.textContent = dict[key];
        }
    });
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if (dict[key]) {
            el.placeholder = dict[key];
        }
    });
    document.querySelectorAll('[data-i18n-title]').forEach(el => {
        const key = el.getAttribute('data-i18n-title');
        if (dict[key]) {
            el.title = dict[key];
        }
    });
    renderBlockedUsers();
    renderSessions();
    updateThemeLabel(document.body.getAttribute('data-theme') === 'light');
    updatePremiumUI();
    updatePremiumGiftUI();
    updateLiveLocationBar();
    updateLiveLocationCards();
}

function formatDateTime(value) {
    const date = value instanceof Date ? value : new Date(value);
    if (!Number.isFinite(date.getTime())) return '';
    const locale = getLanguage() === 'en' ? 'en-US' : 'ru-RU';
    return new Intl.DateTimeFormat(locale, {
        day: '2-digit',
        month: 'short',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    }).format(date);
}

function getBlockedUsers() {
    const raw = localStorage.getItem('xipher_blocked_users');
    if (!raw) return [];
    try {
        const list = JSON.parse(raw);
        return Array.isArray(list) ? list : [];
    } catch (_) {
        return [];
    }
}

function saveBlockedUsers(list) {
    try {
        localStorage.setItem('xipher_blocked_users', JSON.stringify(list));
    } catch (_) {}
}

function renderBlockedUsers() {
    const listEl = document.getElementById('blockedUsersList');
    const emptyEl = document.getElementById('blockedUsersEmpty');
    if (!listEl || !emptyEl) return;

    const blocked = getBlockedUsers();
    listEl.innerHTML = '';

    if (!blocked.length) {
        emptyEl.style.display = 'block';
        return;
    }

    emptyEl.style.display = 'none';

    blocked.forEach((item, index) => {
        const row = document.createElement('div');
        row.className = 'settings-list-item';

        const name = item.display_name || item.name || item.username || item.handle || '—';
        const meta = document.createElement('div');
        meta.className = 'settings-list-meta';
        const blockedAt = item.blocked_at || item.blockedAt || item.date;
        const timeLabel = blockedAt ? formatDateTime(blockedAt) : '';
        meta.textContent = timeLabel ? `${t('settings.blocked.since')} ${timeLabel}` : t('settings.blocked.since');

        const left = document.createElement('div');
        left.innerHTML = `<div style="font-weight:600; color: var(--text-primary);">${escapeHtml(name)}</div>`;
        left.appendChild(meta);

        const right = document.createElement('div');
        right.className = 'settings-list-actions';

        const btn = document.createElement('button');
        btn.className = 'btn-secondary btn-small';
        btn.type = 'button';
        btn.textContent = t('settings.blocked.unblock');
        btn.addEventListener('click', (event) => {
            event.stopPropagation();
            const next = blocked.filter((_, i) => i !== index);
            saveBlockedUsers(next);
            renderBlockedUsers();
        });

        right.appendChild(btn);

        row.appendChild(left);
        row.appendChild(right);
        listEl.appendChild(row);
    });
}

async function getOtherSessions() {
    const token = localStorage.getItem('xipher_token');
    if (!token) return [];
    try {
        const response = await fetch(API_BASE + '/api/get-sessions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token })
        });
        const data = await response.json();
        if (data && data.success && Array.isArray(data.sessions)) {
            return data.sessions;
        }
    } catch (error) {
        console.error('Failed to load sessions:', error);
    }
    return [];
}

async function revokeSessionById(sessionId) {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications?.error && notifications.error('Необходима авторизация');
        return false;
    }
    try {
        const response = await fetch(API_BASE + '/api/revoke-session', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, session_id: sessionId })
        });
        const data = await response.json();
        if (data && data.success) {
            return true;
        }
        notifications?.error && notifications.error(data?.message || 'Ошибка');
    } catch (error) {
        notifications?.error && notifications.error('Ошибка');
        console.error('Failed to revoke session:', error);
    }
    return false;
}

async function revokeOtherSessions() {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications?.error && notifications.error('Необходима авторизация');
        return false;
    }
    try {
        const response = await fetch(API_BASE + '/api/revoke-other-sessions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token })
        });
        const data = await response.json();
        if (data && data.success) {
            return true;
        }
        notifications?.error && notifications.error(data?.message || 'Ошибка');
    } catch (error) {
        notifications?.error && notifications.error('Ошибка');
        console.error('Failed to revoke sessions:', error);
    }
    return false;
}

async function revokeSelectedSessions(sessionIds) {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications?.error && notifications.error('Необходима авторизация');
        return false;
    }
    if (!sessionIds || !sessionIds.length) {
        return false;
    }
    try {
        const response = await fetch(API_BASE + '/api/revoke-selected-sessions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, session_ids: JSON.stringify(sessionIds) })
        });
        const data = await response.json();
        if (data && data.success) {
            return true;
        }
        notifications?.error && notifications.error(data?.message || 'Ошибка');
    } catch (error) {
        notifications?.error && notifications.error('Ошибка');
        console.error('Failed to revoke selected sessions:', error);
    }
    return false;
}

function describeSession(session) {
    const sessionId = session.session_id || session.id || '';
    const ua = session.user_agent || session.userAgent || '';
    const browser = detectBrowser(ua);
    const os = detectOs(ua);
    const shortId = sessionId ? sessionId.slice(0, 6) : '';
    let device = '';
    let location = '';
    if (browser && os) {
        device = browser;
        location = os;
    } else if (browser) {
        device = browser;
    } else if (os) {
        device = os;
    } else {
        device = t('settings.sessions.device');
        if (shortId) {
            device = `${device} ${shortId}`;
        }
    }
    return { sessionId, device, location };
}

function detectBrowser(ua) {
    if (!ua) return 'Web';
    if (ua.includes('Edg/')) return 'Edge';
    if (ua.includes('Chrome') && !ua.includes('Edg/')) return 'Chrome';
    if (ua.includes('Safari') && !ua.includes('Chrome')) return 'Safari';
    if (ua.includes('Firefox')) return 'Firefox';
    if (ua.includes('OPR/') || ua.includes('Opera')) return 'Opera';
    return 'Web';
}

function detectOs(ua) {
    if (!ua) return '';
    if (/Windows/i.test(ua)) return 'Windows';
    if (/Mac OS|Macintosh/i.test(ua)) return 'macOS';
    if (/Android/i.test(ua)) return 'Android';
    if (/iPhone|iPad|iPod/i.test(ua)) return 'iOS';
    if (/Linux/i.test(ua)) return 'Linux';
    return '';
}

async function renderSessions() {
    const browserLabel = document.getElementById('sessionBrowserLabel');
    const lastSeenLabel = document.getElementById('sessionLastSeenLabel');
    if (browserLabel) {
        const ua = navigator.userAgent || '';
        const browser = detectBrowser(ua);
        const os = detectOs(ua);
        browserLabel.textContent = os ? `${browser} · ${os}` : browser;
    }
    if (lastSeenLabel) {
        lastSeenLabel.textContent = t('settings.sessions.now');
    }

    const listEl = document.getElementById('otherSessionsList');
    const emptyEl = document.getElementById('otherSessionsEmpty');
    const endAllBtn = document.getElementById('endOtherSessionsBtn');
    const endSelectedBtn = document.getElementById('endSelectedSessionsBtn');
    if (!listEl || !emptyEl) return;

    const renderId = ++sessionsRenderSeq;
    if (endAllBtn) endAllBtn.disabled = true;
    if (endSelectedBtn) endSelectedBtn.disabled = true;
    listEl.innerHTML = '';
    emptyEl.style.display = 'block';

    const sessions = await getOtherSessions();
    if (renderId !== sessionsRenderSeq) return;

    if (!sessions.length) {
        emptyEl.style.display = 'block';
        if (endAllBtn) endAllBtn.disabled = true;
        if (endSelectedBtn) endSelectedBtn.disabled = true;
        return;
    }

    emptyEl.style.display = 'none';
    if (endAllBtn) endAllBtn.disabled = false;

    const selectedSessionIds = new Set();

    const updateSelectedBtn = () => {
        if (endSelectedBtn) {
            endSelectedBtn.disabled = selectedSessionIds.size === 0;
        }
    };

    sessions.forEach((session) => {
        const { sessionId, device, location } = describeSession(session);
        const row = document.createElement('div');
        row.className = 'settings-list-item';
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '0.75rem';

        // Checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'session-checkbox';
        checkbox.dataset.sessionId = sessionId;
        checkbox.style.marginRight = '0.25rem';
        checkbox.style.cursor = 'pointer';
        checkbox.addEventListener('change', () => {
            if (checkbox.checked) {
                selectedSessionIds.add(sessionId);
            } else {
                selectedSessionIds.delete(sessionId);
            }
            updateSelectedBtn();
        });

        const titleText = [device, location].filter(Boolean).join(' · ') || '—';
        const lastSeenValue = session.last_seen || session.lastSeen || session.created_at || session.createdAt;
        const metaText = [t('settings.sessions.activePrefix'), formatTimeAgo(lastSeenValue)].filter(Boolean).join(' ');
        const clientText = session.client || session.browser;

        const left = document.createElement('div');
        left.style.flex = '1';
        left.innerHTML = `<div style="font-weight:600; color: var(--text-primary);">${escapeHtml(titleText)}</div>`;
        const meta = document.createElement('div');
        meta.className = 'settings-list-meta';
        meta.textContent = clientText ? `${metaText} · ${clientText}` : metaText;
        left.appendChild(meta);

        const right = document.createElement('div');
        right.className = 'settings-list-actions';
        const btn = document.createElement('button');
        btn.className = 'btn-secondary btn-small';
        btn.type = 'button';
        btn.textContent = t('settings.sessions.end');
        btn.addEventListener('click', async (event) => {
            event.stopPropagation();
            if (!sessionId) return;
            btn.disabled = true;
            const ok = await revokeSessionById(sessionId);
            btn.disabled = false;
            if (ok) {
                renderSessions();
            }
        });
        right.appendChild(btn);

        row.appendChild(checkbox);
        row.appendChild(left);
        row.appendChild(right);
        listEl.appendChild(row);
    });

    if (endSelectedBtn) {
        endSelectedBtn.onclick = async () => {
            if (selectedSessionIds.size === 0) return;
            endSelectedBtn.disabled = true;
            const ok = await revokeSelectedSessions(Array.from(selectedSessionIds));
            if (ok) {
                renderSessions();
            } else {
                endSelectedBtn.disabled = selectedSessionIds.size === 0;
            }
        };
    }

    if (endAllBtn) {
        endAllBtn.onclick = async () => {
            endAllBtn.disabled = true;
            const ok = await revokeOtherSessions();
            if (ok) {
                renderSessions();
            } else {
                endAllBtn.disabled = false;
            }
        };
    }
}

function normalizeCallQualityValue(value, kind, isPremium) {
    const fallback = CALL_QUALITY_DEFAULTS[kind] || { resolution: 720, fps: 15 };
    let resolution = fallback.resolution;
    let fps = fallback.fps;
    if (value && typeof value === 'object') {
        const parsedResolution = parseInt(value.resolution, 10);
        const parsedFps = parseInt(value.fps, 10);
        if (CALL_QUALITY_RESOLUTION_OPTIONS.includes(parsedResolution)) {
            resolution = parsedResolution;
        }
        if (CALL_QUALITY_FPS_OPTIONS.includes(parsedFps)) {
            fps = parsedFps;
        }
    }
    const cap = isPremium ? CALL_QUALITY_PREMIUM_CAP : CALL_QUALITY_FREE_CAP;
    resolution = Math.min(resolution, cap.resolution);
    fps = Math.min(fps, cap.fps);
    return { resolution, fps };
}

function readCallQualitySetting(kind, isPremium) {
    const key = CALL_QUALITY_STORAGE_KEYS[kind];
    const fallback = CALL_QUALITY_DEFAULTS[kind] || { resolution: 720, fps: 15 };
    if (!key) return normalizeCallQualityValue(fallback, kind, isPremium);
    try {
        const raw = localStorage.getItem(key);
        if (!raw) return normalizeCallQualityValue(fallback, kind, isPremium);
        const parsed = JSON.parse(raw);
        return normalizeCallQualityValue(parsed, kind, isPremium);
    } catch (_) {
        return normalizeCallQualityValue(fallback, kind, isPremium);
    }
}

function writeCallQualitySetting(kind, value) {
    const key = CALL_QUALITY_STORAGE_KEYS[kind];
    if (!key) return;
    try {
        localStorage.setItem(key, JSON.stringify(value));
    } catch (_) {}
}

function updateCallQualityControls() {
    const isPremium = isPremiumActive();
    const cameraResolution = document.getElementById('callCameraQualitySelect');
    const cameraFps = document.getElementById('callCameraFpsSelect');
    const screenResolution = document.getElementById('callScreenQualitySelect');
    const screenFps = document.getElementById('callScreenFpsSelect');
    const premiumNote = document.getElementById('callQualityPremiumNote');

    const togglePremiumOptions = (select) => {
        if (!select) return;
        select.querySelectorAll('[data-premium]').forEach(option => {
            option.disabled = !isPremium;
        });
    };

    togglePremiumOptions(cameraResolution);
    togglePremiumOptions(cameraFps);
    togglePremiumOptions(screenResolution);
    togglePremiumOptions(screenFps);

    const cameraValue = readCallQualitySetting('camera', isPremium);
    const screenValue = readCallQualitySetting('screen', isPremium);
    if (cameraResolution) cameraResolution.value = String(cameraValue.resolution);
    if (cameraFps) cameraFps.value = String(cameraValue.fps);
    if (screenResolution) screenResolution.value = String(screenValue.resolution);
    if (screenFps) screenFps.value = String(screenValue.fps);

    writeCallQualitySetting('camera', cameraValue);
    writeCallQualitySetting('screen', screenValue);

    if (premiumNote) {
        premiumNote.style.display = isPremium ? 'none' : 'block';
    }
}

function bindCallQualityControls() {
    const cameraResolution = document.getElementById('callCameraQualitySelect');
    const cameraFps = document.getElementById('callCameraFpsSelect');
    const screenResolution = document.getElementById('callScreenQualitySelect');
    const screenFps = document.getElementById('callScreenFpsSelect');

    const handleChange = (kind, resolutionEl, fpsEl) => {
        if (!resolutionEl || !fpsEl) return;
        const isPremium = isPremiumActive();
        const next = {
            resolution: parseInt(resolutionEl.value, 10),
            fps: parseInt(fpsEl.value, 10)
        };
        const normalized = normalizeCallQualityValue(next, kind, isPremium);
        if (resolutionEl.value !== String(normalized.resolution)) {
            resolutionEl.value = String(normalized.resolution);
        }
        if (fpsEl.value !== String(normalized.fps)) {
            fpsEl.value = String(normalized.fps);
        }
        writeCallQualitySetting(kind, normalized);
    };

    cameraResolution?.addEventListener('change', () => handleChange('camera', cameraResolution, cameraFps));
    cameraFps?.addEventListener('change', () => handleChange('camera', cameraResolution, cameraFps));
    screenResolution?.addEventListener('change', () => handleChange('screen', screenResolution, screenFps));
    screenFps?.addEventListener('change', () => handleChange('screen', screenResolution, screenFps));
}

function loadLocalSettings() {
    const extraRaw = localStorage.getItem('xipher_privacy_extra');
    if (extraRaw) {
        try {
            const extra = JSON.parse(extraRaw);
            const forwardSelect = document.getElementById('privacyForwardSelect');
            const callsSelect = document.getElementById('privacyCallsSelect');
            const voiceSelect = document.getElementById('privacyVoiceSelect');
            const messagesSelect = document.getElementById('privacyMessagesSelect');
            const groupsSelect = document.getElementById('privacyGroupsSelect');
            if (forwardSelect && extra.forward) forwardSelect.value = extra.forward;
            if (callsSelect && extra.calls) callsSelect.value = extra.calls;
            if (voiceSelect && extra.voice) voiceSelect.value = extra.voice;
            if (messagesSelect && extra.messages) messagesSelect.value = extra.messages;
            if (groupsSelect && extra.groups) groupsSelect.value = extra.groups;
        } catch (_) {}
    }
    const readReceiptsToggle = document.getElementById('privacyReadReceiptsToggle');
    if (readReceiptsToggle) {
        readReceiptsToggle.checked = isReadReceiptsEnabled();
    }
    const chatListPrivacyToggle = document.getElementById('privacyChatListBlurToggle');
    if (chatListPrivacyToggle) {
        chatListPrivacyToggle.checked = isChatListPrivacyEnabled();
    }
    applyChatListPrivacyState(isChatListPrivacyEnabled());

    const autoDeleteSelect = document.getElementById('autoDeleteSelect');
    const autoDeleteCustom = document.getElementById('autoDeleteCustom');
    const autoDeleteCustomRow = document.getElementById('autoDeleteCustomRow');
    if (autoDeleteSelect) {
        const stored = localStorage.getItem('xipher_auto_delete') || 'off';
        autoDeleteSelect.value = stored;
        if (autoDeleteCustomRow) {
            autoDeleteCustomRow.style.display = stored === 'custom' ? 'flex' : 'none';
        }
    }
    if (autoDeleteCustom) {
        autoDeleteCustom.value = localStorage.getItem('xipher_auto_delete_custom') || '';
    }

    const deleteAccountSelect = document.getElementById('deleteAccountSelect');
    const deleteAccountCustom = document.getElementById('deleteAccountCustom');
    const deleteAccountCustomRow = document.getElementById('deleteAccountCustomRow');
    if (deleteAccountSelect) {
        const stored = localStorage.getItem('xipher_delete_account') || '12m';
        deleteAccountSelect.value = stored;
        if (deleteAccountCustomRow) {
            deleteAccountCustomRow.style.display = stored === 'custom' ? 'flex' : 'none';
        }
    }
    if (deleteAccountCustom) {
        deleteAccountCustom.value = localStorage.getItem('xipher_delete_account_custom') || '';
    }

    const quietFrom = document.getElementById('quietHoursFrom');
    const quietTo = document.getElementById('quietHoursTo');
    if (quietFrom) {
        quietFrom.value = localStorage.getItem(QUIET_HOURS_FROM_KEY) || quietFrom.value;
    }
    if (quietTo) {
        quietTo.value = localStorage.getItem(QUIET_HOURS_TO_KEY) || quietTo.value;
    }
}

function openAppMenu() {
    const menu = document.getElementById('appMenu');
    const overlay = document.getElementById('appMenuOverlay');
    if (!menu || !overlay) return;
    menu.classList.add('show');
    overlay.classList.add('show');
    menu.setAttribute('aria-hidden', 'false');
    document.body.classList.add('menu-open');
}

function closeAppMenu() {
    const menu = document.getElementById('appMenu');
    const overlay = document.getElementById('appMenuOverlay');
    if (!menu || !overlay) return;
    menu.classList.remove('show');
    overlay.classList.remove('show');
    menu.setAttribute('aria-hidden', 'true');
    document.body.classList.remove('menu-open');
}

window.openAppMenu = openAppMenu;
window.closeAppMenu = closeAppMenu;

function openSettingsPanel(sectionId = 'account') {
    const overlay = document.getElementById('settingsOverlay');
    if (!overlay) return;
    overlay.classList.add('show');
    overlay.setAttribute('aria-hidden', 'false');
    document.body.classList.add('settings-open');
    selectSettingsSection(sectionId);
    populateSettingsProfile();
    renderPersonalChannels();
    loadLocalSettings();
    renderBlockedUsers();
    renderSessions();
    syncLanguageFromStorage();
}

function closeSettingsPanel() {
    const overlay = document.getElementById('settingsOverlay');
    if (!overlay) return;
    overlay.classList.remove('show');
    overlay.setAttribute('aria-hidden', 'true');
    document.body.classList.remove('settings-open');
    const moreMenu = document.getElementById('settingsMoreMenu');
    if (moreMenu) moreMenu.classList.remove('show');
}

window.openSettingsPanel = openSettingsPanel;
window.closeSettingsPanel = closeSettingsPanel;

function selectSettingsSection(sectionId) {
    const navItems = document.querySelectorAll('.settings-nav-item');
    const sections = document.querySelectorAll('.settings-section');
    navItems.forEach(item => {
        item.classList.toggle('active', item.dataset.section === sectionId);
    });
    sections.forEach(section => {
        section.classList.toggle('active', section.dataset.section === sectionId);
    });
}

function openQrOverlay() {
    const overlay = document.getElementById('qrOverlay');
    if (!overlay) return;
    const username = localStorage.getItem('xipher_username') || 'user';
    const qrImage = document.getElementById('qrImage');
    const qrSubtitle = document.getElementById('qrSubtitle');
    const profileUrl = `${window.location.origin}/@${encodeURIComponent(username)}`;
    if (qrImage) {
        const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=220x220&data=${encodeURIComponent(profileUrl)}`;
        qrImage.src = qrUrl;
    }
    if (qrSubtitle) {
        qrSubtitle.textContent = profileUrl;
    }
    overlay.classList.add('show');
    overlay.setAttribute('aria-hidden', 'false');
    document.body.classList.add('qr-open');
}

function closeQrOverlay() {
    const overlay = document.getElementById('qrOverlay');
    if (!overlay) return;
    overlay.classList.remove('show');
    overlay.setAttribute('aria-hidden', 'true');
    document.body.classList.remove('qr-open');
}

function openSavedMessages() {
    const saved = chats.find(item => item.is_saved_messages || item.type === 'saved_messages');
    if (saved) {
        selectChat(saved);
        return;
    }
    if (currentUser && currentUser.id) {
        selectChat({
            id: currentUser.id,
            name: 'Избранные сообщения',
            avatar: '⭐',
            lastMessage: '',
            time: '',
            unread: 0,
            online: false,
            is_saved_messages: true,
            type: 'saved_messages'
        });
    } else {
        notifications.warning('Сохраненные сообщения недоступны');
    }
}

async function updatePersonalChannelSelection(channelId) {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications.error('Необходима авторизация');
        return false;
    }
    const body = { token };
    if (channelId) {
        body.channel_id = channelId;
    } else {
        body.channel_id = '';
    }
    try {
        const response = await fetch(API_BASE + '/api/set-personal-channel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        const data = await response.json();
        if (!data.success) {
            notifications.error(data.message || 'Не удалось обновить персональный канал');
            return false;
        }
        return true;
    } catch (error) {
        console.error('Failed to update personal channel:', error);
        notifications.error('Не удалось обновить персональный канал');
        return false;
    }
}

async function syncPersonalChannelSelection() {
    const token = localStorage.getItem('xipher_token');
    const userId = localStorage.getItem('xipher_user_id');
    if (!token || !userId) return;
    try {
        const response = await fetch(API_BASE + '/api/get-user-profile', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, user_id: userId })
        });
        const data = await response.json();
        if (!data.success || !data.user) return;
        const personal = data.user.personal_channel;
        if (personal && personal.id) {
            localStorage.setItem(PERSONAL_CHANNEL_KEY, personal.id);
        } else {
            localStorage.removeItem(PERSONAL_CHANNEL_KEY);
        }
    } catch (error) {
        console.error('Failed to sync personal channel:', error);
    }
}

function renderPersonalChannels() {
    const container = document.getElementById('personalChannelList');
    if (!container) return;
    container.innerHTML = '';
    const channelItems = getVisibleChats().filter(item => item.type === 'channel');
    if (!channelItems.length) {
        container.innerHTML = '<div class="settings-note">Пока нет каналов</div>';
        return;
    }
    const selectedId = localStorage.getItem(PERSONAL_CHANNEL_KEY);
    channelItems.forEach(item => {
        const card = document.createElement('div');
        card.className = 'channel-card';
        const isSelected = selectedId && String(item.id) === String(selectedId);
        if (isSelected) {
            card.classList.add('active');
        }
        const subtitle = item.data?.custom_link ? `@${escapeHtml(item.data.custom_link)}` : 'Без username';
        card.innerHTML = `
            <div style="font-weight:600; color: var(--text-primary); margin-bottom: 0.25rem;">${escapeHtml(item.name)}</div>
            <div class="settings-note">${subtitle}</div>
        `;
        card.addEventListener('click', async () => {
            const nextId = isSelected ? '' : item.id;
            const ok = await updatePersonalChannelSelection(nextId);
            if (!ok) return;
            if (nextId) {
                localStorage.setItem(PERSONAL_CHANNEL_KEY, nextId);
            } else {
                localStorage.removeItem(PERSONAL_CHANNEL_KEY);
            }
            renderPersonalChannels();
            notifications.success('Персональный канал обновлен');
        });
        container.appendChild(card);
    });
}

async function populateSettingsProfile() {
    const username = localStorage.getItem('xipher_username') || '';
    const token = localStorage.getItem('xipher_token');
    const userId = localStorage.getItem('xipher_user_id');
    const settingsUsername = document.getElementById('settingsUsername');
    if (settingsUsername) {
        settingsUsername.value = username ? `@${username}` : '';
    }

    const settingsAvatar = document.getElementById('settingsAvatar');
    const avatarUrl = getStoredAvatarUrl(userId);
    const initials = (username || 'U').charAt(0).toUpperCase();
    if (settingsAvatar) {
        if (avatarUrl) {
            settingsAvatar.innerHTML = `<img src="${avatarUrl}" style="width:100%;height:100%;object-fit:cover;" onerror="this.remove();">`;
        } else {
            settingsAvatar.textContent = initials;
        }
    }

    if (!token || !userId) {
        return;
    }
    try {
        const res = await fetch(API_BASE + '/api/get-user-profile', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, user_id: userId })
        });
        const data = await res.json();
        if (!data.success || !data.user) return;
        const u = data.user;
        const serverAvatarUrl = u.avatar_url || '';
        if (serverAvatarUrl !== avatarUrl) {
            setStoredAvatarUrl(userId, serverAvatarUrl);
            updateAvatarDisplay(serverAvatarUrl);
        }
        const firstName = document.getElementById('settingsFirstName');
        const lastName = document.getElementById('settingsLastName');
        const bio = document.getElementById('settingsBio');
        const birthDay = document.getElementById('settingsBirthDay');
        const birthMonth = document.getElementById('settingsBirthMonth');
        const birthYear = document.getElementById('settingsBirthYear');
        if (firstName) firstName.value = u.first_name || '';
        if (lastName) lastName.value = u.last_name || '';
        if (bio) bio.value = u.bio || '';
        if (birthDay) birthDay.value = u.birth_day || 0;
        if (birthMonth) birthMonth.value = u.birth_month || 0;
        if (birthYear) birthYear.value = u.birth_year || 0;

        const privacy = u.privacy || {};
        const lastSeenSelect = document.getElementById('privacyLastSeenSelect');
        const birthSelect = document.getElementById('privacyBirthSelect');
        const bioSelect = document.getElementById('privacyBioSelect');
        if (lastSeenSelect && privacy.last_seen_visibility) {
            lastSeenSelect.value = privacy.last_seen_visibility;
        }
        if (birthSelect && privacy.birth_visibility) {
            birthSelect.value = privacy.birth_visibility;
        }
        if (bioSelect && privacy.bio_visibility) {
            bioSelect.value = privacy.bio_visibility;
        }
        const readReceiptsToggle = document.getElementById('privacyReadReceiptsToggle');
        if (readReceiptsToggle && typeof privacy.send_read_receipts !== 'undefined') {
            readReceiptsToggle.checked = Boolean(privacy.send_read_receipts);
            setReadReceiptsEnabled(readReceiptsToggle.checked);
        }
    } catch (e) {
        console.error('populateSettingsProfile error', e);
    }
}

async function saveAccountSettings() {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications.error('Необходима авторизация');
        return;
    }
    const first_name = (document.getElementById('settingsFirstName')?.value || '').trim();
    const last_name = (document.getElementById('settingsLastName')?.value || '').trim();
    const bio = (document.getElementById('settingsBio')?.value || '').trim();
    const birth_day = parseInt(document.getElementById('settingsBirthDay')?.value || '0', 10) || 0;
    const birth_month = parseInt(document.getElementById('settingsBirthMonth')?.value || '0', 10) || 0;
    const birth_year = parseInt(document.getElementById('settingsBirthYear')?.value || '0', 10) || 0;
    try {
        const res = await fetch(API_BASE + '/api/update-my-profile', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, first_name, last_name, bio, birth_day, birth_month, birth_year })
        });
        const data = await res.json();
        if (data.success) {
            notifications.success('Профиль сохранён');
            refreshMyDisplayName();
        } else {
            notifications.error(data.error || 'Не удалось сохранить профиль');
        }
    } catch (e) {
        console.error('saveAccountSettings error', e);
        notifications.error('Ошибка сохранения профиля');
    }
}

async function savePrivacySettings() {
    const token = localStorage.getItem('xipher_token');
    const last_seen_visibility = document.getElementById('privacyLastSeenSelect')?.value || 'contacts';
    const birth_visibility = document.getElementById('privacyBirthSelect')?.value || 'contacts';
    const bio_visibility = document.getElementById('privacyBioSelect')?.value || 'contacts';
    const readReceiptsEnabled = document.getElementById('privacyReadReceiptsToggle')?.checked ?? isReadReceiptsEnabled();

    const extra = {
        forward: document.getElementById('privacyForwardSelect')?.value || 'contacts',
        calls: document.getElementById('privacyCallsSelect')?.value || 'contacts',
        voice: document.getElementById('privacyVoiceSelect')?.value || 'contacts',
        messages: document.getElementById('privacyMessagesSelect')?.value || 'contacts',
        groups: document.getElementById('privacyGroupsSelect')?.value || 'contacts'
    };

    try {
        localStorage.setItem('xipher_privacy_extra', JSON.stringify(extra));
    } catch (_) {}
    setReadReceiptsEnabled(readReceiptsEnabled);

    const autoDeleteValue = document.getElementById('autoDeleteSelect')?.value || 'off';
    const autoDeleteCustom = document.getElementById('autoDeleteCustom')?.value || '';
    const deleteAccountValue = document.getElementById('deleteAccountSelect')?.value || '6m';
    const deleteAccountCustom = document.getElementById('deleteAccountCustom')?.value || '';
    const quietFrom = document.getElementById('quietHoursFrom')?.value || '';
    const quietTo = document.getElementById('quietHoursTo')?.value || '';
    try {
        localStorage.setItem('xipher_auto_delete', autoDeleteValue);
        localStorage.setItem('xipher_auto_delete_custom', autoDeleteCustom);
        localStorage.setItem('xipher_delete_account', deleteAccountValue);
        localStorage.setItem('xipher_delete_account_custom', deleteAccountCustom);
        localStorage.setItem(QUIET_HOURS_FROM_KEY, quietFrom);
        localStorage.setItem(QUIET_HOURS_TO_KEY, quietTo);
    } catch (_) {}

    if (!token) {
        notifications.error('Необходима авторизация');
        return;
    }

    try {
        const res = await fetch(API_BASE + '/api/update-my-privacy', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, last_seen_visibility, birth_visibility, bio_visibility, send_read_receipts: readReceiptsEnabled })
        });
        const data = await res.json();
        if (data.success) {
            notifications.success('Приватность сохранена');
        } else {
            notifications.error(data.error || 'Не удалось сохранить приватность');
        }
    } catch (e) {
        console.error('savePrivacySettings error', e);
        notifications.error('Ошибка сохранения приватности');
    }
}

function setupAppMenu() {
    const openBtn = document.getElementById('openAppMenuBtn');
    const closeBtn = document.getElementById('closeAppMenuBtn');
    const overlay = document.getElementById('appMenuOverlay');
    openBtn?.addEventListener('click', openAppMenu);
    closeBtn?.addEventListener('click', closeAppMenu);
    overlay?.addEventListener('click', closeAppMenu);

    const themeToggle = document.getElementById('menuThemeToggle');
    themeToggle?.addEventListener('change', (e) => {
        setTheme(Boolean(e.target.checked));
    });

    document.getElementById('menuProfileBtn')?.addEventListener('click', () => {
        openSettingsPanel('account');
        closeAppMenu();
    });
    document.getElementById('menuSettingsBtn')?.addEventListener('click', () => {
        openSettingsPanel('account');
        closeAppMenu();
    });
    document.getElementById('menuCallsBtn')?.addEventListener('click', () => {
        openSettingsPanel('calls');
        closeAppMenu();
    });
    document.getElementById('menuSavedBtn')?.addEventListener('click', () => {
        openSavedMessages();
        closeAppMenu();
    });
    document.getElementById('menuLanguageBtn')?.addEventListener('click', () => {
        openSettingsPanel('language');
        closeAppMenu();
    });
    document.getElementById('menuPremiumBtn')?.addEventListener('click', () => {
        openSettingsPanel('premium');
        closeAppMenu();
    });
    document.getElementById('menuFaqBtn')?.addEventListener('click', () => {
        openSettingsPanel('faq');
        closeAppMenu();
    });

    document.getElementById('createGroupBtn')?.addEventListener('click', () => {
        closeAppMenu();
    });
    document.getElementById('createChannelBtn')?.addEventListener('click', () => {
        closeAppMenu();
    });

    document.addEventListener('keydown', (e) => {
        if (e.key !== 'Escape') return;
        closeAppMenu();
        closeSettingsPanel();
        closeQrOverlay();
    });
}

function setupSettingsPanel() {
    const overlay = document.getElementById('settingsOverlay');
    if (!overlay) return;
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            closeSettingsPanel();
        }
    });
    document.getElementById('settingsCloseBtn')?.addEventListener('click', closeSettingsPanel);

    overlay.querySelectorAll('.settings-nav-item').forEach(btn => {
        btn.addEventListener('click', () => {
            selectSettingsSection(btn.dataset.section);
        });
    });

    const moreBtn = document.getElementById('settingsMoreBtn');
    const moreMenu = document.getElementById('settingsMoreMenu');
    moreBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        if (moreMenu) moreMenu.classList.toggle('show');
    });
    document.addEventListener('click', () => {
        if (moreMenu) moreMenu.classList.remove('show');
    });

    document.getElementById('settingsQrBtn')?.addEventListener('click', openQrOverlay);
    document.getElementById('qrCloseBtn')?.addEventListener('click', closeQrOverlay);
    document.getElementById('qrOverlay')?.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'qrOverlay') {
            closeQrOverlay();
        }
    });

    document.getElementById('settingsEditProfileBtn')?.addEventListener('click', () => {
        selectSettingsSection('account');
    });

    document.getElementById('settingsLogoutBtn')?.addEventListener('click', async () => {
        await window.xipherSession?.logout();
        window.location.href = '/login';
    });

    document.getElementById('settingsChangeAvatarBtn')?.addEventListener('click', () => {
        const input = document.getElementById('avatarInput');
        if (input) input.click();
    });

    document.getElementById('saveAccountSettingsBtn')?.addEventListener('click', saveAccountSettings);
    document.getElementById('savePrivacySettingsBtn')?.addEventListener('click', savePrivacySettings);
    const readReceiptsToggle = document.getElementById('privacyReadReceiptsToggle');
    readReceiptsToggle?.addEventListener('change', (e) => {
        setReadReceiptsEnabled(Boolean(e.target.checked));
    });
    const chatListPrivacyToggle = document.getElementById('privacyChatListBlurToggle');
    chatListPrivacyToggle?.addEventListener('change', (e) => {
        setChatListPrivacyEnabled(Boolean(e.target.checked));
    });
    document.getElementById('saveLoginEmailBtn')?.addEventListener('click', () => {
        const email = document.getElementById('loginEmailInput')?.value.trim() || '';
        try {
            localStorage.setItem('xipher_login_email', email);
        } catch (_) {}
        notifications.success('Email сохранен');
    });

    const autoDeleteSelect = document.getElementById('autoDeleteSelect');
    const autoDeleteCustomRow = document.getElementById('autoDeleteCustomRow');
    autoDeleteSelect?.addEventListener('change', () => {
        if (!autoDeleteCustomRow) return;
        autoDeleteCustomRow.style.display = autoDeleteSelect.value === 'custom' ? 'flex' : 'none';
        try { localStorage.setItem('xipher_auto_delete', autoDeleteSelect.value); } catch (_) {}
    });
    const autoDeleteCustom = document.getElementById('autoDeleteCustom');
    autoDeleteCustom?.addEventListener('change', () => {
        try { localStorage.setItem('xipher_auto_delete_custom', autoDeleteCustom.value || ''); } catch (_) {}
    });

    const deleteAccountSelect = document.getElementById('deleteAccountSelect');
    const deleteAccountCustomRow = document.getElementById('deleteAccountCustomRow');
    deleteAccountSelect?.addEventListener('change', () => {
        if (!deleteAccountCustomRow) return;
        deleteAccountCustomRow.style.display = deleteAccountSelect.value === 'custom' ? 'flex' : 'none';
        try { localStorage.setItem('xipher_delete_account', deleteAccountSelect.value); } catch (_) {}
    });
    const deleteAccountCustom = document.getElementById('deleteAccountCustom');
    deleteAccountCustom?.addEventListener('change', () => {
        try { localStorage.setItem('xipher_delete_account_custom', deleteAccountCustom.value || ''); } catch (_) {}
    });

    document.getElementById('settingsLanguageSelect')?.addEventListener('change', (e) => {
        setLanguage(e.target.value);
    });

    const notifDesktop = document.getElementById('notifDesktopToggle');
    const notifSound = document.getElementById('notifSoundToggle');
    const notifPreview = document.getElementById('notifPreviewToggle');
    const notifCallSound = document.getElementById('notifCallSoundToggle');
    const notifVibration = document.getElementById('notifVibrationToggle');
    const notifContactJoin = document.getElementById('notifContactJoinToggle');
    const notifPinned = document.getElementById('notifPinnedToggle');

    if (notifDesktop) {
        const stored = localStorage.getItem(NOTIF_DESKTOP_KEY);
        if (stored !== null) {
            notifDesktop.checked = stored === 'true';
        }
        notifDesktop.addEventListener('change', async () => {
            if (!notifDesktop.checked) {
                localStorage.setItem(NOTIF_DESKTOP_KEY, 'false');
                return;
            }
            if (typeof Notification === 'undefined') {
                notifications?.warning && notifications.warning('Уведомления рабочего стола не поддерживаются в этом браузере');
                notifDesktop.checked = false;
                localStorage.setItem(NOTIF_DESKTOP_KEY, 'false');
                return;
            }
            let permission = Notification.permission;
            if (permission === 'default') {
                try {
                    permission = await Notification.requestPermission();
                } catch (_) {
                    permission = 'denied';
                }
            }
            if (permission !== 'granted') {
                notifications?.error && notifications.error('Разрешение на уведомления не предоставлено');
                notifDesktop.checked = false;
                localStorage.setItem(NOTIF_DESKTOP_KEY, 'false');
                return;
            }
            localStorage.setItem(NOTIF_DESKTOP_KEY, 'true');
        });
    }

    const notifKeys = [
        [notifSound, NOTIF_SOUND_KEY],
        [notifPreview, NOTIF_PREVIEW_KEY],
        [notifCallSound, NOTIF_CALL_SOUND_KEY],
        [notifVibration, NOTIF_VIBRATION_KEY],
        [notifContactJoin, 'xipher_notif_contact_join'],
        [notifPinned, 'xipher_notif_pinned']
    ];
    notifKeys.forEach(([el, key]) => {
        if (!el) return;
        const stored = localStorage.getItem(key);
        if (stored !== null) {
            el.checked = stored === 'true';
        }
        el.addEventListener('change', () => {
            localStorage.setItem(key, el.checked ? 'true' : 'false');
        });
    });

    const loginEmailInput = document.getElementById('loginEmailInput');
    if (loginEmailInput) {
        loginEmailInput.value = localStorage.getItem('xipher_login_email') || '';
    }

    const quietFrom = document.getElementById('quietHoursFrom');
    const quietTo = document.getElementById('quietHoursTo');
    quietFrom?.addEventListener('change', () => {
        try { localStorage.setItem(QUIET_HOURS_FROM_KEY, quietFrom.value); } catch (_) {}
    });
    quietTo?.addEventListener('change', () => {
        try { localStorage.setItem(QUIET_HOURS_TO_KEY, quietTo.value); } catch (_) {}
    });

    loadLocalSettings();

    const callsAllowToggle = document.getElementById('callsAllowToggle');
    const callsWhoSelect = document.getElementById('callsWhoSelect');
    if (callsAllowToggle) {
        const stored = localStorage.getItem('xipher_calls_allow');
        if (stored !== null) callsAllowToggle.checked = stored === 'true';
        callsAllowToggle.addEventListener('change', () => {
            localStorage.setItem('xipher_calls_allow', callsAllowToggle.checked ? 'true' : 'false');
        });
    }
    if (callsWhoSelect) {
        const stored = localStorage.getItem('xipher_calls_who');
        if (stored) callsWhoSelect.value = stored;
        callsWhoSelect.addEventListener('change', () => {
            localStorage.setItem('xipher_calls_who', callsWhoSelect.value);
        });
    }
    bindCallQualityControls();
    updateCallQualityControls();

    const sessionBrowserLabel = document.getElementById('sessionBrowserLabel');
    if (sessionBrowserLabel) {
        sessionBrowserLabel.textContent = navigator.platform || 'Web';
    }

    const privacyStorage = localStorage.getItem('xipher_privacy_settings');
    if (privacyStorage) {
        try {
            const parsed = JSON.parse(privacyStorage);
            if (parsed.last_seen) document.getElementById('privacyLastSeenSelect').value = parsed.last_seen;
            if (parsed.forward) document.getElementById('privacyForwardSelect').value = parsed.forward;
            if (parsed.calls) document.getElementById('privacyCallsSelect').value = parsed.calls;
            if (parsed.voice) document.getElementById('privacyVoiceSelect').value = parsed.voice;
            if (parsed.messages) document.getElementById('privacyMessagesSelect').value = parsed.messages;
            if (parsed.birth) document.getElementById('privacyBirthSelect').value = parsed.birth;
            if (parsed.bio) document.getElementById('privacyBioSelect').value = parsed.bio;
            if (parsed.groups) document.getElementById('privacyGroupsSelect').value = parsed.groups;
        } catch (_) {}
    }

    const autoDeleteStored = localStorage.getItem('xipher_auto_delete');
    if (autoDeleteStored) {
        if (autoDeleteSelect) autoDeleteSelect.value = autoDeleteStored;
        if (autoDeleteCustomRow) {
            autoDeleteCustomRow.style.display = autoDeleteStored === 'custom' ? 'flex' : 'none';
        }
        const customValue = localStorage.getItem('xipher_auto_delete_custom');
        if (customValue && document.getElementById('autoDeleteCustom')) {
            document.getElementById('autoDeleteCustom').value = customValue;
        }
    }

    const deleteAccountStored = localStorage.getItem('xipher_delete_account');
    if (deleteAccountStored) {
        if (deleteAccountSelect) deleteAccountSelect.value = deleteAccountStored;
        if (deleteAccountCustomRow) {
            deleteAccountCustomRow.style.display = deleteAccountStored === 'custom' ? 'flex' : 'none';
        }
        const customValue = localStorage.getItem('xipher_delete_account_custom');
        if (customValue && document.getElementById('deleteAccountCustom')) {
            document.getElementById('deleteAccountCustom').value = customValue;
        }
    }

    document.querySelectorAll('input[name="premiumPlan"]').forEach(input => {
        input.addEventListener('change', () => {
            selectedPremiumPlan = normalizePremiumPlan(input.value);
            updatePremiumUI();
        });
    });
    document.querySelectorAll('.premium-plan-option').forEach(option => {
        option.addEventListener('click', () => {
            const plan = option.dataset.plan;
            if (!plan) return;
            selectedPremiumPlan = normalizePremiumPlan(plan);
            const input = option.querySelector('input[name="premiumPlan"]');
            if (input) input.checked = true;
            updatePremiumUI();
        });
    });

    document.getElementById('premiumSubscribeBtn')?.addEventListener('click', () => {
        activatePremium(selectedPremiumPlan || 'month');
    });
    document.getElementById('premiumManageBtn')?.addEventListener('click', cancelPremium);

    const premiumCancelModal = document.getElementById('premiumCancelModal');
    if (premiumCancelModal) {
        premiumCancelModal.addEventListener('click', (e) => {
            if (e.target === premiumCancelModal) closePremiumCancelModal();
        });
    }
    document.getElementById('premiumCancelCloseBtn')?.addEventListener('click', closePremiumCancelModal);
    document.getElementById('premiumCancelNoBtn')?.addEventListener('click', closePremiumCancelModal);
    document.getElementById('premiumCancelYesBtn')?.addEventListener('click', confirmPremiumCancel);

    const premiumPaymentModal = document.getElementById('premiumPaymentModal');
    if (premiumPaymentModal) {
        premiumPaymentModal.addEventListener('click', (e) => {
            if (e.target === premiumPaymentModal) closePremiumPaymentModal();
        });
    }
    document.getElementById('premiumPaymentCloseBtn')?.addEventListener('click', closePremiumPaymentModal);
    document.getElementById('premiumPaymentCancelBtn')?.addEventListener('click', closePremiumPaymentModal);
    document.getElementById('premiumPaymentSubmitBtn')?.addEventListener('click', submitPremiumPayment);
    document.querySelectorAll('input[name="premiumPaymentProvider"]').forEach(input => {
        input.addEventListener('change', updatePremiumPaymentProviderUI);
    });
    const premiumPaymentStatus = document.getElementById('premiumPaymentStatus');
    if (premiumPaymentStatus) {
        premiumPaymentStatus.addEventListener('click', resetPendingPremiumPaymentState);
    }
    const premiumPaymentTimer = document.getElementById('premiumPaymentTimer');
    if (premiumPaymentTimer) {
        premiumPaymentTimer.addEventListener('click', resetPendingPremiumPaymentState);
    }

    setupBusinessHours();
    updatePremiumUI();
    updatePremiumGiftUI();
}

function waitForWebSocketReady(timeout = 5000) {
    if (isWsAuthed && ws && ws.readyState === WebSocket.OPEN) return Promise.resolve();
    return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
            reject(new Error('WebSocket not ready within timeout'));
        }, timeout);
        wsReadyResolvers.push(() => {
            clearTimeout(timer);
            resolve();
        });
    });
}

// Делаем helper доступным глобально
window.waitForWebSocketReady = waitForWebSocketReady;

function formatVoicePlaybackRate(rate) {
    if (!isFinite(rate)) return '1x';
    const fixed = Number.isInteger(rate) ? rate.toFixed(0) : rate.toFixed(1);
    return `${fixed}x`;
}

function getNextVoicePlaybackRate(rate) {
    const idx = VOICE_PLAYBACK_RATES.indexOf(rate);
    const nextIndex = idx === -1 ? 0 : (idx + 1) % VOICE_PLAYBACK_RATES.length;
    return VOICE_PLAYBACK_RATES[nextIndex];
}

function applyVoicePlaybackRate(audio, rate) {
    if (!audio || !isFinite(rate)) return;
    audio.playbackRate = rate;
    audio.defaultPlaybackRate = rate;
}

function parseWebSocketJsonSafe(raw) {
    if (typeof raw !== 'string') return raw;
    try {
        return JSON.parse(raw);
    } catch (e) {
        // Попытка вытащить первое/последнее вхождение фигурных скобок
        const first = raw.indexOf('{');
        const last = raw.lastIndexOf('}');
        if (first !== -1 && last > first) {
            const sliced = raw.slice(first, last + 1);
            try {
                console.warn('[WebSocket] Recovering JSON via slice');
                return JSON.parse(sliced);
            } catch (e2) {
                // Попытка распарсить как несколько объектов без разделителя
                const split = raw.split(/}\s*{/).filter(Boolean);
                if (split.length > 1) {
                    const recovered = [];
                    for (let i = 0; i < split.length; i++) {
                        let chunk = split[i];
                        if (!chunk.startsWith('{')) chunk = '{' + chunk;
                        if (!chunk.endsWith('}')) chunk = chunk + '}';
                        try {
                            console.warn('[WebSocket] Recovering JSON via chunk', i);
                            recovered.push(JSON.parse(chunk));
                        } catch (_e3) {
                            continue;
                        }
                    }
                    if (recovered.length) return recovered;
                }
            }
        }
        console.error('[WebSocket] JSON parse failed:', e.message);
        return null;
    }
}

// Выделение одного или нескольких JSON-объектов из потока (учитывая, что сервер может склеивать несколько объектов подряд)
function extractJsonObjectsFromBuffer(buffer) {
    const objects = [];
    let remainder = buffer;
    let idx = 0;
    let depth = 0;
    let inString = false;
    let escapeNext = false;
    let start = -1;

    while (idx < remainder.length) {
        const ch = remainder[idx];

        if (escapeNext) {
            escapeNext = false;
        } else if (ch === '\\') {
            escapeNext = true;
        } else if (ch === '"') {
            inString = !inString;
        } else if (!inString) {
            if (ch === '{') {
                if (depth === 0) {
                    start = idx;
                }
                depth++;
            } else if (ch === '}') {
                depth--;
                if (depth === 0 && start !== -1) {
                    const jsonSlice = remainder.slice(start, idx + 1);
                    objects.push(jsonSlice);
                    remainder = remainder.slice(idx + 1);
                    // reset counters for new search
                    idx = -1;
                    start = -1;
                    inString = false;
                    escapeNext = false;
                }
            }
        }
        idx++;
    }

    return { objects, remainder };
}

// Функция форматирования времени "сколько времени назад"
function formatTimeAgo(timestamp) {
    if (!timestamp) return t('time.never');
    
    const now = new Date();
    const past = new Date(timestamp);
    const diffMs = now - past;
    const diffSeconds = Math.floor(diffMs / 1000);
    
    if (diffSeconds < 60) {
        return t('time.justNow');
    }
    
    const diffMinutes = Math.floor(diffSeconds / 60);
    const lang = getLanguage();
    if (diffMinutes < 60) {
        if (lang === 'en') {
            return diffMinutes === 1 ? '1 minute ago' : `${diffMinutes} minutes ago`;
        }
        const word = diffMinutes === 1 ? 'минуту' : (diffMinutes < 5 ? 'минуты' : 'минут');
        return `${diffMinutes} ${word} назад`;
    }
    
    const diffHours = Math.floor(diffMinutes / 60);
    if (diffHours < 24) {
        if (lang === 'en') {
            return diffHours === 1 ? '1 hour ago' : `${diffHours} hours ago`;
        }
        const word = diffHours === 1 ? 'час' : (diffHours < 5 ? 'часа' : 'часов');
        return `${diffHours} ${word} назад`;
    }
    
    const diffDays = Math.floor(diffHours / 24);
    if (diffDays < 7) {
        if (lang === 'en') {
            return diffDays === 1 ? '1 day ago' : `${diffDays} days ago`;
        }
        const word = diffDays === 1 ? 'день' : (diffDays < 5 ? 'дня' : 'дней');
        return `${diffDays} ${word} назад`;
    }
    
    const diffWeeks = Math.floor(diffDays / 7);
    if (diffWeeks < 52) {
        if (lang === 'en') {
            return diffWeeks === 1 ? '1 week ago' : `${diffWeeks} weeks ago`;
        }
        const word = diffWeeks === 1 ? 'неделю' : (diffWeeks < 5 ? 'недели' : 'недель');
        return `${diffWeeks} ${word} назад`;
    }
    
    const diffYears = Math.floor(diffDays / 365);
    if (lang === 'en') {
        return diffYears === 1 ? '1 year ago' : `${diffYears} years ago`;
    }
    const word = diffYears === 1 ? 'год' : (diffYears < 5 ? 'года' : 'лет');
    return `${diffYears} ${word} назад`;
}

// Инициализация
document.addEventListener('DOMContentLoaded', async () => {
    const session = window.xipherSession ? await window.xipherSession.requireSessionOrRedirect() : null;
    if (!session) {
        notifications.error('Необходима авторизация');
        return;
    }

    const tokenPayload = session.data || {};
    const token = localStorage.getItem('xipher_token') || (window.xipherSession?.SESSION_TOKEN_PLACEHOLDER || '');
    const username = tokenPayload.username || localStorage.getItem('xipher_username') || '';
    const userId = tokenPayload.user_id || localStorage.getItem('xipher_user_id') || '';
    if (!userId || !username) {
        await window.xipherSession?.logout();
        window.location.href = '/login';
        return;
    }

    const premiumActive = tokenPayload.is_premium === true || tokenPayload.is_premium === 'true';
    const premiumPlan = typeof tokenPayload.premium_plan === 'string' ? tokenPayload.premium_plan : '';
    const premiumExpiresAt = typeof tokenPayload.premium_expires_at === 'string' ? tokenPayload.premium_expires_at : '';

    currentUser = {
        id: userId,
        username: username,
        token: token,
        is_premium: premiumActive,
        premium_plan: premiumPlan,
        premium_expires_at: premiumExpiresAt
    };
    setPremiumState({ active: premiumActive, plan: premiumPlan, expiresAt: premiumExpiresAt });
    setupPushMessageHandlers();
    if (window.xipherPush?.init) {
        window.xipherPush.init({ authToken: token });
    }

    const urlParams = new URLSearchParams(window.location.search);
    let shouldReplaceUrl = false;
    if (urlParams.get('premium') === 'success') {
        notifications.success(t('settings.premium.payment.toast.success'));
        startPremiumPaymentPolling({ force: true });
        urlParams.delete('premium');
        shouldReplaceUrl = true;
    }
    if (urlParams.get('gift') === 'success') {
        notifications.success(t('premium.gift.payment.success'));
        urlParams.delete('gift');
        shouldReplaceUrl = true;
    }
    if (urlParams.get('gift') === 'cancel') {
        notifications.info(t('premium.gift.payment.cancel'));
        urlParams.delete('gift');
        shouldReplaceUrl = true;
    }
    if (shouldReplaceUrl) {
        const nextQuery = urlParams.toString();
        const nextUrl = `${window.location.pathname}${nextQuery ? `?${nextQuery}` : ''}`;
        window.history.replaceState({}, document.title, nextUrl);
    }

    // Установка информации о пользователе
    const savedDisplayName = localStorage.getItem('xipher_display_name');
    document.getElementById('username').textContent = savedDisplayName || username;
    // Загружаем аватар пользователя (будет показана буква, если нет аватара)
    loadUserAvatar();
    // Подтягиваем профиль (first/last) и обновляем отображаемое имя, не трогая username
    refreshMyDisplayName();

    // Инициализация типа просмотра
    window.currentViewType = 'all'; // Все в одном списке
    
    // Загрузка данных
    loadChatStateSets();
    loadChatFolders();
    await syncPersonalChannelSelection();
    await syncPinnedChatsFromServer(true);
    await syncChatFoldersFromServer(true);
    await loadChats(); // Загружаем чаты
    await handleChatDeepLink();
    loadFriends();
    loadFriendRequests();

    // Обработчики
    setupEventHandlers();
    setupTtlMenu();
    setupTabs();
    setupAddFriend();
    setupFileUpload();
    setupDragAndDropUpload();
    setupAttachMenu();
    setupChecklistComposer();
    setupPremiumGiftModal();
    setupLiveLocationModal();
    setupLiveLocationControls();
    startLiveLocationCardTicker();
    setupAvatarUpload();
    setupUserSettingsEntry();
    setupFolderUI();
    setupAppMenu();
    setupSettingsPanel();
    setupPinnedPanelClick();
    setupEmojiPicker();
    setupVoiceRecording();
    setupReply();
    setupReportModal();
    setupDeleteChatModal();

    syncThemeFromStorage();
    syncLanguageFromStorage();
    applyChatListPrivacyState(isChatListPrivacyEnabled());
    // Контекстное меню теперь управляется ContextMenuManager

    // Поиск чатов
    const searchInput = document.getElementById('chatSearch');
    searchInput.addEventListener('input', (e) => {
        filterChats(e.target.value);
    });

    // Автоматическое обновление сообщений и чатов
    startAutoRefresh();
    
    // Периодическое обновление активности пользователя (каждые 30 секунд)
    startActivityUpdate();
    
    // Подключение WebSocket для звонков
    connectWebSocket();
    
    // Обработка URL вида /@username
    handleChannelUrl();
    handleGroupInviteUrl();
    
    // Обработка параметра channel в URL (?channel=id)
    const channelId = urlParams.get('channel');
    if (channelId) {
        openChannelById(channelId);
    }
});

async function refreshMyDisplayName() {
    const token = localStorage.getItem('xipher_token');
    const userId = localStorage.getItem('xipher_user_id');
    const username = localStorage.getItem('xipher_username') || '';
    if (!token || !userId) return;
    try {
        const res = await fetch(API_BASE + '/api/get-user-profile', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, user_id: userId })
        });
        const data = await res.json();
        if (data.success && data.user) {
            const display = data.user.display_name || username;
            localStorage.setItem('xipher_display_name', display);
            const nameEl = document.getElementById('username');
            if (nameEl) nameEl.textContent = display;
            updateAvatarDisplay(data.user.avatar_url || '');

            if (currentUser) {
                currentUser.is_premium = data.user.is_premium === true || data.user.is_premium === 'true';
                currentUser.premium_plan = typeof data.user.premium_plan === 'string' ? data.user.premium_plan : '';
                currentUser.premium_expires_at = typeof data.user.premium_expires_at === 'string'
                    ? data.user.premium_expires_at
                    : '';
                currentUser.business_hours = data.user.business_hours || {};
                setPremiumState({
                    active: currentUser.is_premium,
                    plan: currentUser.premium_plan,
                    expiresAt: currentUser.premium_expires_at
                });
                applyBusinessHoursToForm(currentUser.business_hours);
            }
        }
    } catch (e) {
        console.warn('refreshMyDisplayName failed', e);
    }
}

// Подключение WebSocket
function connectWebSocket() {
    // Закрываем существующее соединение, если оно есть
    if (ws && ws.readyState !== WebSocket.CLOSED) {
        console.log('[WebSocket] Closing existing connection before reconnecting');
        ws.onclose = null;
        ws.close();
    }
    
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws`;
    
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        console.log('[WebSocket] No token available, skipping WebSocket connection');
        return;
    }
    
    try {
        console.log('[WebSocket] Attempting to connect...');
        ws = new WebSocket(wsUrl);
        
        const connectTimeout = setTimeout(() => {
            if (ws && ws.readyState === WebSocket.CONNECTING) {
                console.error('[WebSocket] Connection timeout');
                ws.close();
            }
        }, 10000);
        
        ws.onopen = () => {
            clearTimeout(connectTimeout);
            console.log('[WebSocket] Connected successfully');
            isWsAuthed = false;
            if (token && ws.readyState === WebSocket.OPEN) {
                try {
                    ws.send(JSON.stringify({
                        type: 'auth',
                        token: token
                    }));
                    console.log('[WebSocket] Auth message sent');
                } catch (e) {
                    console.error('[WebSocket] Error sending auth:', e);
                }
            }
        };
        
        ws.onmessage = (event) => {
            try {
                const raw = event.data;
                wsBuffer += raw;
                if (wsBufferTimer) clearTimeout(wsBufferTimer);

                const { objects, remainder } = extractJsonObjectsFromBuffer(wsBuffer);
                wsBuffer = remainder;

                if (wsBuffer.length) {
                    wsBufferTimer = setTimeout(() => {
                        // сбрасываем просроченный буфер
                        wsBuffer = '';
                        wsBufferTimer = null;
                    }, WS_BUFFER_TIMEOUT_MS);
                }

                if (!objects.length) {
                    console.warn('[WebSocket] Buffered data, waiting for complete JSON');
                    return;
                }

                objects.forEach((chunk, idx) => {
                    console.log('[WebSocket] Received chunk:', chunk);
                    const parsed = parseWebSocketJsonSafe(chunk);
                    if (!parsed) {
                        console.error('[WebSocket] Message parse failed after recovery attempts');
                        return;
                    }
                    const messages = Array.isArray(parsed) ? parsed : [parsed];
                    messages.forEach((data, midx) => {
                        console.log('[WebSocket] Parsed data', messages.length > 1 ? `#${midx}` : '', data);
                        handleWebSocketMessage(data);
                    });
                });
            } catch (e) {
                console.error('[WebSocket] Message parse error:', e, 'Raw data:', event.data);
            }
        };
        
        ws.onerror = (error) => {
            clearTimeout(connectTimeout);
            console.error('[WebSocket] Error:', error);
        };
        
        ws.onclose = (event) => {
            clearTimeout(connectTimeout);
            console.log('[WebSocket] Closed, code:', event.code, 'reason:', event.reason);
            isWsAuthed = false;
            wsBuffer = '';
            if (wsBufferTimer) {
                clearTimeout(wsBufferTimer);
                wsBufferTimer = null;
            }
            if (token && event.code !== 1000) {
                console.log('[WebSocket] Will attempt to reconnect in 3 seconds...');
                setTimeout(() => {
                    if (token && (!ws || ws.readyState === WebSocket.CLOSED)) {
                        connectWebSocket();
                    }
                }, 3000);
            }
        };
    } catch (error) {
        console.error('[WebSocket] Connection error:', error);
        if (token) {
            setTimeout(() => {
                if (token) {
                    connectWebSocket();
                }
            }, 5000);
        }
    }
}

// Обработка /join/{code} или ?join=code
async function handleGroupInviteUrl() {
    const path = window.location.pathname;
    let inviteCode = null;
    const joinMatch = path.match(/^\/join\/([A-Za-z0-9_-]+)/);
    if (joinMatch && joinMatch[1]) {
        inviteCode = joinMatch[1];
    }
    if (!inviteCode) {
        const urlParams = new URLSearchParams(window.location.search);
        inviteCode = urlParams.get('join');
    }
    if (!inviteCode) return;
    
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        // Сохраняем код, редирект на логин
        localStorage.setItem('pending_group_invite', inviteCode);
        window.location.href = '/login';
        return;
    }
    
    try {
        const channelResp = await fetch('/api/join-channel-by-invite', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, invite_token: inviteCode })
        });
        const channelData = await channelResp.json();
        if (channelData.success) {
            const msg = (channelData.message || '').toLowerCase();
            const requested = channelData.requested === 'true' || channelData.requested === true || msg.includes('request');
            if (requested) {
                notifications.success('Заявка отправлена');
                return;
            }
            const channelId = channelData.channel_id;
            notifications.success('Вы присоединились к каналу');
            await loadAllChats();
            if (channelId && window.channelsModule) {
                await window.channelsModule.loadChannels();
                const channelsList = window.channelsModule.channels();
                const channel = channelsList?.find(c => c.id === channelId);
                if (channel) {
                    window.channelsModule.selectChannel(channel);
                }
            }
            return;
        }
        const channelError = (channelData.error || channelData.message || '').toLowerCase();
        const shouldFallback = channelError.includes('invalid') || channelError.includes('expired') || channelError.includes('not found');
        if (!shouldFallback) {
            notifications.error(channelData.error || channelData.message || 'Не удалось присоединиться по ссылке');
            return;
        }

        const resp = await fetch('/api/join-group', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, invite_link: inviteCode })
        });
        const data = await resp.json();
        if (data.success) {
            const groupId = data.group_id;
            notifications.success('Вы присоединились к группе');
            await loadAllChats();
            if (groupId && window.groupsModule) {
                // ищем группу в данных
                const group = groups.find(g => g.id === groupId);
                if (group) {
                    window.groupsModule.selectGroup(group);
                }
            }
        } else {
            notifications.error(data.message || 'Не удалось присоединиться по ссылке');
        }
    } catch (e) {
        console.error('Join group error', e);
        notifications.error('Ошибка присоединения к группе');
    }
}

// Обработка WebSocket сообщений
function handleWebSocketMessage(data) {
    switch (data.type) {
        case 'auth_success':
            console.log('WebSocket authenticated');
            isWsAuthed = true;
            resolveWsReady();
            if (wsSendQueue.length && ws && ws.readyState === WebSocket.OPEN) {
                console.log('[WebSocket] Flushing send queue, size:', wsSendQueue.length);
                while (wsSendQueue.length && ws && ws.readyState === WebSocket.OPEN) {
                    const msg = wsSendQueue.shift();
                    try {
                        ws.send(msg);
                    } catch (e) {
                        console.error('[WebSocket] Error sending queued message:', e);
                        // если не получилось — кладём обратно и выходим
                        wsSendQueue.unshift(msg);
                        break;
                    }
                }
            }
            break;
        case 'auth_error':
            console.error('WebSocket auth failed:', data.error);
            break;
        case 'new_message': {
            const messagePayload = data.message || data;
            const currentUserId = currentUser?.id || localStorage.getItem('xipher_user_id');
            const senderId = messagePayload.sender_id || messagePayload.senderId || '';
            const receiverId = messagePayload.receiver_id || messagePayload.receiverId || '';
            const isSentByCurrent = senderId && currentUserId ? String(senderId) === String(currentUserId) : false;
            const normalizedChatType = normalizeChatType(messagePayload.chat_type || messagePayload.chatType || 'chat');
            let resolvedChatId = messagePayload.chat_id || messagePayload.chatId || '';
            if (!resolvedChatId && (normalizedChatType === 'chat' || normalizedChatType === 'saved')) {
                resolvedChatId = isSentByCurrent ? receiverId : senderId;
            }
            const messageTime = messagePayload.time || formatServerTimeToLocal(messagePayload.created_at);
            const resolvedStatus = isSentByCurrent
                ? (messagePayload.status
                    || (messagePayload.is_read || messagePayload.read_timestamp ? 'read' : '')
                    || (messagePayload.is_delivered ? 'delivered' : '')
                    || (messagePayload.temp_id ? 'sent' : 'sent'))
                : '';
            const preparedMessage = {
                id: messagePayload.id || messagePayload.message_id || '',
                temp_id: messagePayload.temp_id,
                sent: isSentByCurrent,
                status: resolvedStatus,
                sender_id: senderId,
                receiver_id: receiverId,
                chat_id: resolvedChatId,
                chat_type: normalizedChatType,
                content: messagePayload.content,
                time: messageTime,
                message_type: messagePayload.message_type || 'text',
                file_path: messagePayload.file_path,
                file_name: messagePayload.file_name,
                file_size: messagePayload.file_size,
                reply_to_message_id: messagePayload.reply_to_message_id,
                reply_content: messagePayload.reply_content,
                ttl_seconds: messagePayload.ttl_seconds,
                read_timestamp: messagePayload.read_timestamp
            };

            const isActiveTarget = (() => {
                if (!resolvedChatId) return false;
                if (normalizedChatType === 'channel') {
                    const channel = window.channelsModule?.currentChannel?.();
                    const channelActive = window.channelsModule?.isChannelActive?.() ?? false;
                    return channelActive && channel?.id && String(channel.id) === String(resolvedChatId);
                }
                if (normalizedChatType === 'group') {
                    const group = window.groupsModule?.currentGroup?.() || window.currentGroup;
                    const groupActive = window.groupsModule?.isGroupActive?.() ?? Boolean(window.currentGroup);
                    return groupActive && group?.id && String(group.id) === String(resolvedChatId);
                }
                if (normalizedChatType === 'saved') {
                    return currentChat?.is_saved_messages && currentChat.id && String(currentChat.id) === String(resolvedChatId);
                }
                return currentChat && currentChat.id && !currentChat.is_saved_messages && String(currentChat.id) === String(resolvedChatId);
            })();

            if (normalizedChatType === 'group') {
                if (isActiveTarget && typeof addGroupMessageToUI === 'function') {
                    addGroupMessageToUI({
                        ...messagePayload,
                        id: preparedMessage.id,
                        sent: isSentByCurrent,
                        sender_id: senderId,
                        sender_username: messagePayload.sender_username || messagePayload.sender_name || messagePayload.from_username || '',
                        time: messageTime
                    });
                }
            } else if (normalizedChatType === 'channel') {
                if (isActiveTarget && typeof addChannelMessageToUI === 'function') {
                    addChannelMessageToUI({
                        ...messagePayload,
                        id: preparedMessage.id,
                        sent: isSentByCurrent,
                        time: messageTime
                    });
                }
            } else if (isActiveTarget) {
                if (isSentByCurrent && preparedMessage.temp_id) {
                    reconcileTempMessage(preparedMessage.temp_id, {
                        id: preparedMessage.id,
                        temp_id: preparedMessage.temp_id,
                        time: preparedMessage.time,
                        status: preparedMessage.status,
                        content: preparedMessage.content,
                        message_type: preparedMessage.message_type,
                        file_path: preparedMessage.file_path,
                        file_name: preparedMessage.file_name,
                        file_size: preparedMessage.file_size,
                        reply_to_message_id: preparedMessage.reply_to_message_id,
                        ttl_seconds: preparedMessage.ttl_seconds,
                        read_timestamp: preparedMessage.read_timestamp
                    });
                }

                addMessageToUI(preparedMessage, true);
            }
            if (isActiveTarget) {
                clearTypingForMessageSender(messagePayload, normalizedChatType, resolvedChatId, isSentByCurrent);
            }
            if (!isSentByCurrent) {
                notifyIncomingMessageFromPayload(messagePayload, {
                    chatId: resolvedChatId || undefined,
                    chatType: normalizedChatType || undefined
                });
            }
            break;
        }
        case 'message_delivered':
        case 'message_read': {
            const messageId = data.message_id || '';
            if (messageId) {
                setMessageStatus(messageId, data.type === 'message_read' ? 'read' : 'delivered');
            }
            break;
        }
        case 'typing':
            handleTypingEvent(data);
            break;
        case 'call_offer':
            notifyIncomingCall(data);
            console.log('[WebSocket] ========== call_offer received ==========');
            console.log('[WebSocket] Full data:', JSON.stringify(data, null, 2));
            console.log('[WebSocket] Checking handleCallOffer function...');
            console.log('[WebSocket] typeof handleCallOffer:', typeof handleCallOffer);
            console.log('[WebSocket] window.handleCallOffer exists:', typeof window.handleCallOffer !== 'undefined');
            
            if (typeof handleCallOffer === 'function') {
                console.log('[WebSocket] Calling handleCallOffer...');
                try {
                handleCallOffer(data);
                    console.log('[WebSocket] handleCallOffer called successfully');
                } catch (error) {
                    console.error('[WebSocket] Error in handleCallOffer:', error);
                    console.error('[WebSocket] Error stack:', error.stack);
                }
            } else if (typeof window.handleCallOffer === 'function') {
                console.log('[WebSocket] Using window.handleCallOffer...');
                try {
                    window.handleCallOffer(data);
                    console.log('[WebSocket] window.handleCallOffer called successfully');
                } catch (error) {
                    console.error('[WebSocket] Error in window.handleCallOffer:', error);
                    console.error('[WebSocket] Error stack:', error.stack);
                }
            } else {
                console.error('[WebSocket] handleCallOffer function not found!');
                console.error('[WebSocket] Available window functions:', Object.keys(window).filter(k => k.includes('Call')));
            }
            break;
        case 'call_answer':
            if (typeof handleCallAnswer === 'function') {
                handleCallAnswer(data);
            }
            break;
        case 'call_ice_candidate':
            if (typeof handleCallIceCandidate === 'function') {
                handleCallIceCandidate(data);
            }
            break;
        case 'call_end':
            if (typeof handleCallEnd === 'function') {
                handleCallEnd();
            }
            break;
        case 'group_call_offer':
            console.log('[WebSocket] Received group_call_offer:', data);
            if (typeof handleGroupCallOffer === 'function') {
                handleGroupCallOffer(data);
            }
            break;
        case 'group_call_answer':
            console.log('[WebSocket] Received group_call_answer:', data);
            if (typeof handleGroupCallAnswer === 'function') {
                handleGroupCallAnswer(data);
            }
            break;
        case 'group_call_ice_candidate':
            console.log('[WebSocket] Received group_call_ice_candidate:', data);
            if (typeof handleGroupCallIceCandidate === 'function') {
                handleGroupCallIceCandidate(data);
            }
            break;
        case 'group_call_end':
            console.log('[WebSocket] Received group_call_end:', data);
            if (typeof handleGroupCallEnd === 'function') {
                handleGroupCallEnd(data);
            }
            break;
        case 'group_call_notification':
            console.log('[WebSocket] Received group_call_notification:', data);
            notifyIncomingGroupCall(data);
            if (typeof handleGroupCallNotification === 'function') {
                handleGroupCallNotification(data);
            }
            break;
        case 'call_media_state':
        case 'group_call_media_state':
            console.log('[WebSocket] Received media state:', data);
            if (typeof handleRemoteMediaState === 'function') {
                handleRemoteMediaState(data);
            }
            break;
        case 'avatar_updated':
            console.log('[WebSocket] Received avatar_updated:', data);
            handleAvatarUpdated(data);
            break;
        case 'topic_message':
            console.log('[WebSocket] Received topic_message:', data);
            if (window.topicsModule && typeof window.topicsModule.handleTopicWebSocketMessage === 'function') {
                window.topicsModule.handleTopicWebSocketMessage(data);
            }
            break;
        case 'topic_created':
        case 'topic_updated':
        case 'topic_deleted':
            console.log('[WebSocket] Received topic event:', data.type, data);
            if (window.topicsModule && typeof window.topicsModule.handleTopicWebSocketMessage === 'function') {
                window.topicsModule.handleTopicWebSocketMessage(data);
            }
            break;
    }
}

// Отправка WebSocket сообщения
function sendWebSocketMessage(message) {
    const payload = JSON.stringify(message);
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(payload);
        return;
    }
    console.error('WebSocket not connected, enqueue message');
    wsSendQueue.push(payload);
}

// Открытие канала по ID
async function openChannelById(channelId) {
    if (!window.channelsModule) return;

    await window.channelsModule.loadChannels();
    const channelsList = window.channelsModule.channels();
    let channel = channelsList?.find(c => c.id === channelId);

    // Fallback: если канал не в списке (не подписан), пробуем запросить info по id
    if (!channel) {
        const token = localStorage.getItem('xipher_token');
        if (!token) return;
        try {
            const resp = await fetch('/api/get-channel-info', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ token, channel_id: channelId })
            });
            const data = await resp.json();
            if (data.success && data.channel) {
                channel = {
                    id: data.channel.id,
                    name: data.channel.name,
                    description: data.channel.description,
                    custom_link: data.channel.custom_link,
                    avatar_url: data.channel.avatar_url,
                    is_private: data.channel.is_private,
                    show_author: data.channel.show_author,
                    type: 'channel'
                };
            }
        } catch (e) {
            console.error('openChannelById fallback failed', e);
        }
    }

    if (channel) {
        window.channelsModule.selectChannel(channel);
        updatePremiumGiftAvailability();
        closePremiumGiftModal();
        // Переключаемся на вкладку каналов
        const channelsTab = document.querySelector('[data-tab="channels"]');
        if (channelsTab) {
            channelsTab.click();
        }
        // Очищаем URL
        window.history.replaceState({}, '', '/chat');
    }
}

// Парсинг упоминаний в тексте сообщения
function parseMentions(text) {
    if (!text) return '';
    
    // Экранируем HTML для безопасности
    const escaped = escapeHtml(text);
    
    // Регулярное выражение для поиска @mentions
    // Формат: @username или @channel (3-50 символов, буквы, цифры, подчеркивания)
    const mentionRegex = /@([a-zA-Z0-9_]{3,50})/g;
    
    return escaped.replace(mentionRegex, (match, username) => {
        return `<span class="mention-link" data-username="${escapeHtml(username)}" style="color: var(--purple-primary); cursor: pointer; text-decoration: underline;">${match}</span>`;
    });
}

function isLocationMessageType(type) {
    return type === 'location' || type === 'live_location';
}

function isLikelyLocationContent(content) {
    if (!content || typeof content !== 'string') return false;
    const text = content.trim();
    if (!text) return false;
    if (/^geo:/i.test(text)) return true;
    if (/yandex\.(ru|com)\/maps/i.test(text)) return true;
    if (/maps\?pt=|maps\?ll=/i.test(text)) return true;
    if (/^-?\d+(\.\d+)?\s*,\s*-?\d+(\.\d+)?$/.test(text)) return true;
    return false;
}

function parseLocationPayload(content) {
    if (!isLikelyLocationContent(content)) return null;
    const text = content.trim();
    let lat = null;
    let lon = null;
    let liveId = null;
    let expiresAt = null;

    const parseLonLat = (value) => {
        if (!value) return null;
        const parts = value.split(',');
        if (parts.length < 2) return null;
        const lonValue = parseFloat(parts[0]);
        const latValue = parseFloat(parts[1]);
        if (!Number.isFinite(latValue) || !Number.isFinite(lonValue)) return null;
        return { lat: latValue, lon: lonValue };
    };

    const parseLatLon = (value) => {
        if (!value) return null;
        const parts = value.split(',');
        if (parts.length < 2) return null;
        const latValue = parseFloat(parts[0]);
        const lonValue = parseFloat(parts[1]);
        if (!Number.isFinite(latValue) || !Number.isFinite(lonValue)) return null;
        return { lat: latValue, lon: lonValue };
    };

    if (text.startsWith('geo:')) {
        const coordPart = text.slice(4).split('?')[0];
        const parsed = parseLatLon(coordPart);
        if (parsed) {
            lat = parsed.lat;
            lon = parsed.lon;
        }
    }

    try {
        const url = new URL(text, window.location.origin);
        const pt = url.searchParams.get('pt');
        const ll = url.searchParams.get('ll');
        if ((lat === null || lon === null) && pt) {
            const cleaned = pt.split(',').slice(0, 2).join(',');
            const parsed = parseLonLat(cleaned);
            if (parsed) {
                lat = parsed.lat;
                lon = parsed.lon;
            }
        }
        if ((lat === null || lon === null) && ll) {
            const parsed = parseLonLat(ll);
            if (parsed) {
                lat = parsed.lat;
                lon = parsed.lon;
            }
        }
        if (url.hash) {
            const hashParams = new URLSearchParams(url.hash.replace(/^#/, ''));
            liveId = hashParams.get('xipher_id') || liveId;
            const expires = hashParams.get('xipher_expires');
            if (expires) {
                const parsedExpires = parseInt(expires, 10);
                if (Number.isFinite(parsedExpires)) {
                    expiresAt = parsedExpires;
                }
            }
        }
    } catch (e) {
        // ignore URL parsing issues
    }

    if (lat === null || lon === null) {
        const coordsMatch = text.match(/(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)/);
        if (coordsMatch) {
            const parsed = parseLatLon(`${coordsMatch[1]},${coordsMatch[2]}`);
            if (parsed) {
                lat = parsed.lat;
                lon = parsed.lon;
            }
        }
    }

    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
    return { lat, lon, liveId, expiresAt };
}

function formatLiveLocationRemaining(expiresAt) {
    if (!expiresAt || !Number.isFinite(expiresAt)) return t('chat.live.label');
    const remaining = expiresAt - Date.now();
    if (remaining <= 0) return t('chat.live.ended');
    const minutes = Math.max(1, Math.ceil(remaining / 60000));
    if (minutes < 60) {
        return formatTemplate(t('chat.live.remaining.minutes'), { minutes });
    }
    const hours = Math.max(1, Math.floor(minutes / 60));
    return formatTemplate(t('chat.live.remaining.hours'), { hours });
}

function buildLocationCard(message) {
    const payload = parseLocationPayload(message?.content || '');
    if (!payload) return null;
    const isLive = message?.message_type === 'live_location' || Boolean(payload.liveId);
    const titleText = isLive ? t('chat.live.title') : t('chat.attach.location');
    const subtitleText = isLive ? formatLiveLocationRemaining(payload.expiresAt) : t('chat.location.openMap');
    const lon = payload.lon.toFixed(6);
    const lat = payload.lat.toFixed(6);
    const mapUrl = `https://static-maps.yandex.ru/1.x/?ll=${lon},${lat}&size=450,250&z=15&l=map&pt=${lon},${lat},pm2rdm`;
    const openUrl = isValidUrl(message?.content || '')
        ? new URL(message.content, window.location.origin).href
        : `https://yandex.ru/maps/?pt=${lon},${lat}&z=16&l=map`;

    const card = document.createElement('div');
    card.className = 'message-location';
    if (isLive && payload.liveId) {
        card.dataset.liveId = payload.liveId;
    }
    if (isLive && payload.expiresAt) {
        card.dataset.liveExpires = String(payload.expiresAt);
    }

    const mapImg = document.createElement('img');
    mapImg.className = 'message-location-map';
    mapImg.src = mapUrl;
    mapImg.alt = titleText;

    const info = document.createElement('div');
    info.className = 'message-location-info';

    const title = document.createElement('div');
    title.className = 'message-location-title';
    title.textContent = titleText;

    const subtitle = document.createElement('div');
    subtitle.className = 'message-location-subtitle';
    subtitle.textContent = subtitleText;

    info.appendChild(title);
    info.appendChild(subtitle);
    card.appendChild(mapImg);
    card.appendChild(info);

    card.addEventListener('click', (e) => {
        e.stopPropagation();
        const opened = window.open(openUrl, '_blank', 'noopener,noreferrer');
        if (opened) opened.opener = null;
    });

    return card;
}

window.isLocationMessageType = isLocationMessageType;
window.parseLocationPayload = parseLocationPayload;
window.buildLocationCard = buildLocationCard;

let liveLocationCardTicker = null;

function updateLiveLocationCards() {
    const cards = document.querySelectorAll('.message-location[data-live-expires]');
    cards.forEach(card => {
        const expiresAt = parseInt(card.dataset.liveExpires || '0', 10);
        if (!Number.isFinite(expiresAt)) return;
        const subtitle = card.querySelector('.message-location-subtitle');
        if (!subtitle) return;
        const nextText = formatLiveLocationRemaining(expiresAt);
        if (nextText && subtitle.textContent !== nextText) {
            subtitle.textContent = nextText;
        }
    });
}

function startLiveLocationCardTicker() {
    if (liveLocationCardTicker) return;
    updateLiveLocationCards();
    liveLocationCardTicker = setInterval(updateLiveLocationCards, 30000);
}

// Функция для экранирования HTML
function escapeHtml(text) {
    if (typeof text !== 'string') {
        return '';
    }
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Функция для валидации URL (безопасность)
function isValidUrl(url) {
    if (typeof url !== 'string' || url.length === 0) {
        return false;
    }
    try {
        const urlObj = new URL(url, window.location.origin);
        // Разрешаем только http/https протоколы
        return urlObj.protocol === 'http:' || urlObj.protocol === 'https:';
    } catch (e) {
        return false;
    }
}

// Функция для санитизации пути к файлу (защита от path traversal)
function sanitizeFilePath(filePath) {
    if (typeof filePath !== 'string') {
        return '';
    }
    // Удаляем опасные символы и пути
    return filePath
        .replace(/\.\./g, '') // Удаляем ..
        .replace(/[<>:"|?*\x00-\x1f]/g, '') // Удаляем недопустимые символы
        .replace(/^\/+/, '/') // Нормализуем начальный слэш
        .substring(0, 500); // Ограничиваем длину
}

function getSafeFileUrl(filePath) {
    const sanitized = sanitizeFilePath(filePath);
    return sanitized ? API_BASE + sanitized : '';
}

const TRANSFER_STATES = {
    IDLE: 'idle',
    LOADING: 'loading',
    DONE: 'done'
};

const TRANSFER_ICON_DOWNLOAD = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5 20h14v-2H5v2zm7-16v8h4l-4 4-4-4h4V4z" fill="currentColor"/></svg>';
const TRANSFER_ICON_CANCEL = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M18.3 5.7 12 12l6.3 6.3-1.4 1.4L10.6 13.4 4.3 19.7 2.9 18.3 9.2 12 2.9 5.7 4.3 4.3l6.3 6.3 6.3-6.3 1.4 1.4z" fill="currentColor"/></svg>';
const TRANSFER_ICON_FILE = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M6 2h8l6 6v14H6V2zm8 1.5V9h5.5L14 3.5zM8 13h8v2H8v-2zm0 4h8v2H8v-2z" fill="currentColor"/></svg>';
const uploadTransfers = new Map();
const downloadTransfers = new Map();
const pendingAttachments = [];
let isSendingAttachments = false;

function createTransferRing({ state = TRANSFER_STATES.IDLE, progress = 0, kind = 'file', size = 36 } = {}) {
    const ring = document.createElement('button');
    ring.type = 'button';
    ring.className = 'file-transfer-ring';
    ring.dataset.state = state;
    ring.dataset.kind = kind;
    ring.style.setProperty('--transfer-ring-size', `${size}px`);
    ring.setAttribute('aria-label', 'File transfer');

    ring.innerHTML = `
        <svg class="transfer-ring-svg" viewBox="0 0 44 44" aria-hidden="true">
            <circle class="transfer-ring-track" cx="22" cy="22" r="18"></circle>
            <circle class="transfer-ring-progress" cx="22" cy="22" r="18"></circle>
        </svg>
        <span class="transfer-ring-button">
            <span class="transfer-ring-icon"></span>
        </span>
    `;

    setTransferRingProgress(ring, progress);
    setTransferRingState(ring, state, progress);
    return ring;
}

function setTransferRingIcon(ring) {
    if (!ring) return;
    const icon = ring.querySelector('.transfer-ring-icon');
    if (!icon) return;
    const state = ring.dataset.state || TRANSFER_STATES.IDLE;
    const kind = ring.dataset.kind || 'file';
    if (state === TRANSFER_STATES.DONE && kind === 'file') {
        icon.innerHTML = TRANSFER_ICON_FILE;
    } else if (state === TRANSFER_STATES.LOADING) {
        icon.innerHTML = TRANSFER_ICON_CANCEL;
    } else {
        icon.innerHTML = TRANSFER_ICON_DOWNLOAD;
    }
}

function setTransferRingProgress(ring, progress) {
    if (!ring) return;
    const circle = ring.querySelector('.transfer-ring-progress');
    if (!circle) return;
    const safe = Math.max(0, Math.min(100, Number(progress) || 0));
    const radius = Number(circle.getAttribute('r')) || 0;
    const circumference = circle.dataset.circumference
        ? Number(circle.dataset.circumference)
        : 2 * Math.PI * radius;
    circle.dataset.circumference = String(circumference);
    circle.style.strokeDasharray = `${circumference}`;
    circle.style.strokeDashoffset = `${circumference - (safe / 100) * circumference}`;
    ring.dataset.progress = String(safe);
}

function stopTransferSimulation(ring) {
    if (!ring || !ring._transferRaf) return;
    cancelAnimationFrame(ring._transferRaf);
    ring._transferRaf = null;
}

function startTransferSimulation(ring, targetProgress = 92, durationMs = 1400) {
    if (!ring) return;
    stopTransferSimulation(ring);
    const start = performance.now();
    const startProgress = Number(ring.dataset.progress || 0);
    const target = Math.max(startProgress, Math.min(100, targetProgress));

    const tick = (now) => {
        if (ring.dataset.state !== TRANSFER_STATES.LOADING) {
            stopTransferSimulation(ring);
            return;
        }
        const elapsed = now - start;
        const ratio = Math.min(1, elapsed / durationMs);
        const next = startProgress + (target - startProgress) * ratio;
        setTransferRingProgress(ring, next);
        if (ratio < 1) {
            ring._transferRaf = requestAnimationFrame(tick);
        } else {
            ring._transferRaf = null;
        }
    };
    ring._transferRaf = requestAnimationFrame(tick);
}

function setTransferRingState(ring, state, progress) {
    if (!ring) return;
    ring.dataset.state = state;
    if (typeof progress === 'number') {
        setTransferRingProgress(ring, progress);
    }
    if (state !== TRANSFER_STATES.LOADING) {
        stopTransferSimulation(ring);
    }
    setTransferRingIcon(ring);

    const kind = ring.dataset.kind || 'file';
    if (state === TRANSFER_STATES.DONE && kind === 'image') {
        ring.classList.add('is-hidden');
    } else {
        ring.classList.remove('is-hidden');
    }
}

function resolveTransferState(msg, isSent) {
    if (msg && typeof msg.transfer_state === 'string') return msg.transfer_state;
    if (isSent) return TRANSFER_STATES.DONE;
    return TRANSFER_STATES.IDLE;
}

function getMessageKeyFromElement(messageDiv) {
    if (!messageDiv) return '';
    return messageDiv.dataset.messageId || messageDiv.dataset.tempId || '';
}

function removeMessageByTempId(tempId) {
    if (!tempId) return;
    const el = document.querySelector(`[data-temp-id="${tempId}"]`);
    if (el) {
        el.remove();
    }
}

function cancelUploadTransfer(tempId) {
    if (!tempId) return;
    const task = uploadTransfers.get(tempId);
    if (!task) return;
    task.canceled = true;
    if (task.xhr) {
        task.xhr.abort();
    }
    uploadTransfers.delete(tempId);
    if (task.ring) {
        setTransferRingState(task.ring, TRANSFER_STATES.IDLE, 0);
    }
    if (task.messageEl) {
        task.messageEl.remove();
    }
    notifications.info('Загрузка отменена');
}

function cancelDownloadTransfer(key) {
    if (!key) return;
    const task = downloadTransfers.get(key);
    if (!task) return;
    if (task.xhr) {
        task.xhr.abort();
    }
    downloadTransfers.delete(key);
    if (task.ring) {
        setTransferRingState(task.ring, TRANSFER_STATES.IDLE, 0);
    }
}

function startDownloadTransfer({ messageDiv, ring, fileUrl, fileName, isImage }) {
    if (!fileUrl || !ring || !messageDiv) return;
    const key = getMessageKeyFromElement(messageDiv);
    if (!key || downloadTransfers.has(key)) return;
    const xhr = new XMLHttpRequest();
    xhr.open('GET', fileUrl, true);
    xhr.responseType = 'blob';

    xhr.onprogress = (event) => {
        if (!event.lengthComputable) return;
        const progress = Math.min(100, Math.round((event.loaded / event.total) * 100));
        setTransferRingProgress(ring, progress);
    };

    xhr.onload = () => {
        downloadTransfers.delete(key);
        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
            const blobUrl = URL.createObjectURL(xhr.response);
            messageDiv.dataset.downloadUrl = blobUrl;
            if (isImage) {
                const img = messageDiv.querySelector('.message-image img');
                if (img) {
                    img.src = blobUrl;
                }
            } else {
                const link = document.createElement('a');
                link.href = blobUrl;
                link.download = fileName || 'file';
                link.click();
            }
            setTransferRingState(ring, TRANSFER_STATES.DONE, 100);
        } else {
            setTransferRingState(ring, TRANSFER_STATES.IDLE, 0);
            notifications.error('Ошибка загрузки файла');
        }
    };

    xhr.onerror = () => {
        downloadTransfers.delete(key);
        setTransferRingState(ring, TRANSFER_STATES.IDLE, 0);
        notifications.error('Ошибка загрузки файла');
    };

    xhr.onabort = () => {
        downloadTransfers.delete(key);
        setTransferRingState(ring, TRANSFER_STATES.IDLE, 0);
    };

    downloadTransfers.set(key, { xhr, ring, messageEl: messageDiv });
    setTransferRingState(ring, TRANSFER_STATES.LOADING, Number(ring.dataset.progress || 0));
    xhr.send();
}

// Обработка клика на упоминание
async function handleMentionClick(username) {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications.error('Необходима авторизация');
        return;
    }
    
    try {
        // Сначала ищем канал
        const channelResponse = await fetch('/api/search-channel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ custom_link: username })
        });
        
        let channelData;
        try {
            channelData = await channelResponse.json();
        } catch (e) {
            channelData = { success: false };
        }
        
        if (channelData.success && channelData.channel) {
            // Найден канал - открываем его
            if (window.channelsModule) {
                await window.channelsModule.loadChannels();
                const channelsList = window.channelsModule.channels();
                let foundChannel = channelsList?.find(c => c.id === channelData.channel.id);
                
                if (!foundChannel) {
                    // Если канал не найден в списке, подписываемся (если публичный)
                    if (!channelData.channel.is_private) {
                        await subscribeToChannel(channelData.channel.id);
                        await window.channelsModule.loadChannels();
                        const updatedChannelsList = window.channelsModule.channels();
                        foundChannel = updatedChannelsList?.find(c => c.id === channelData.channel.id);
                    } else {
                        notifications.info('Это приватный канал. Нужно подать заявку на вступление.');
                        return;
                    }
                }
                
                if (foundChannel) {
                    window.channelsModule.selectChannel(foundChannel);
                    // Переключаемся на вкладку каналов (если есть)
                    const channelsTab = document.querySelector('[data-tab="channels"]');
                    if (channelsTab) {
                        channelsTab.click();
                    }
                }
            }
            return;
        }
        
        // Канал не найден - ищем пользователя
        const userResponse = await fetch(API_BASE + '/api/check-username', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username })
        });
        
        const userData = await userResponse.json();
        
        if (userData.success) {
            // Найден пользователь - открываем чат с ним
            // Ищем пользователя в списке друзей
            const friend = friends.find(f => f.username === username);
            if (friend) {
                selectChat({
                    id: friend.id,
                    name: friend.username,
                    display_name: friend.display_name,
                    type: 'user'
                });
            } else {
                // Если не в друзьях, открываем модальное окно добавления друга
                document.getElementById('addFriendModal').style.display = 'flex';
                document.getElementById('friendSearchInput').value = username;
                searchUser();
            }
        } else {
            notifications.warning('Пользователь или канал не найдены');
        }
    } catch (error) {
        console.error('Error handling mention click:', error);
        notifications.error('Ошибка при обработке упоминания');
    }
}

async function subscribeToChannel(channelId) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return;
    
    try {
        const response = await fetch('/api/subscribe-channel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, channel_id: channelId })
        });
        
        const data = await response.json();
        if (data.success) {
            const msg = (data.message || '').toLowerCase();
            const requested = msg.includes('request');
            notifications.success(requested ? 'Заявка отправлена' : 'Подписка на канал успешна');
            if (!requested && window.channelsModule) {
                await window.channelsModule.loadChannels();
                const channelsList = window.channelsModule.channels();
                const channel = channelsList?.find(c => c.id === channelId);
                if (channel) {
                    window.channelsModule.selectChannel(channel);
                }
            }
        } else {
            notifications.error(data.error || 'Ошибка подписки на канал');
        }
    } catch (error) {
        console.error('Subscribe error:', error);
        notifications.error('Ошибка подписки на канал');
    }
}

// Обработка URL вида /@username:
// - если это канал -> открываем канал
// - если это бот/пользователь -> открываем ЛС (если бот или уже в друзьях), иначе предлагаем добавить в друзья
async function handleChannelUrl() {
    const path = window.location.pathname;
    const match = path.match(/^\/(@[^\/]+)$/);
    
    if (match) {
        const username = match[1].substring(1); // Убираем @
        
        try {
            const token = localStorage.getItem('xipher_token');
            if (!token) {
                notifications.error('Необходима авторизация');
                return;
            }

            const response = await fetch('/api/resolve-username', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ token, username })
            });

            const data = await response.json();
            if (!data.success || !data.data || !data.data.type) {
                notifications.error(data.message || 'Не найдено');
                return;
            }

            const info = data.data;
            if (info.type === 'channel') {
                const channelId = info.id;
                if (!channelId) {
                    notifications.error('Канал не найден');
                    return;
                }

                if (window.channelsModule) {
                    await window.channelsModule.loadChannels();
                    const channelsList = window.channelsModule.channels();
                    let foundChannel = channelsList?.find(c => c.id === channelId);

                    if (!foundChannel) {
                        await subscribeToChannel(channelId);
                        await window.channelsModule.loadChannels();
                        const updatedChannelsList = window.channelsModule.channels();
                        foundChannel = updatedChannelsList?.find(c => c.id === channelId);
                    }

                    if (foundChannel) {
                        window.channelsModule.selectChannel(foundChannel);
                        const channelsTab = document.querySelector('[data-tab="channels"]');
                        if (channelsTab) channelsTab.click();
                        window.history.replaceState({}, '', '/chat');
                    }
                }
                return;
            }

            if (info.type === 'user' || info.type === 'bot') {
                const targetId = info.id;
                const targetUsername = info.username || username;
                const isFriend = info.is_friend === 'true';

                if (info.type === 'bot' || isFriend) {
                    const chatObj = {
                        id: targetId,
                        name: targetUsername,
                        avatar: (targetUsername || 'U').charAt(0).toUpperCase(),
                        avatar_url: info.avatar_url || '',
                        lastMessage: '',
                        time: '',
                        unread: 0,
                        online: false,
                        last_activity: null
                    };
                    selectChat(chatObj);
                    document.querySelector('[data-tab="chats"]')?.click();
                    window.history.replaceState({}, '', '/chat');
                    return;
                }

                // Not friend -> offer to add
                const ok = confirm(`@${targetUsername} не в друзьях. Отправить запрос в друзья?`);
                if (ok) {
                    const fr = await fetch('/api/friend-request', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token, username: targetUsername })
                    });
                    const frData = await fr.json();
                    if (frData.success) {
                        notifications.success('Запрос в друзья отправлен');
                    } else {
                        notifications.error(frData.message || 'Не удалось отправить запрос');
                    }
                }
                window.history.replaceState({}, '', '/chat');
                return;
            }
        } catch (error) {
            console.error('Error loading channel from URL:', error);
            notifications.error('Ошибка загрузки канала');
            window.history.replaceState({}, '', '/chat');
        }
    }
}

function setupEventHandlers() {
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');

    // Автоматическое изменение высоты textarea
    messageInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 150) + 'px';
        handleTypingInput(this.value);
    });

    messageInput.addEventListener('blur', () => {
        stopTypingForCurrentTarget();
    });

    // Отправка по Enter (Shift+Enter для новой строки)
    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });

    messageInput.addEventListener('paste', handleClipboardImagePaste);

    sendButton.addEventListener('click', sendMessage);
}

async function handleClipboardImagePaste(event) {
    const clipboard = event.clipboardData;
    if (!clipboard || !clipboard.items) return;
    const imageItems = Array.from(clipboard.items).filter(
        (item) => item.kind === 'file' && item.type && item.type.startsWith('image/')
    );
    if (imageItems.length === 0) return;

    event.preventDefault();
    event.stopPropagation();

    if (!resolveMessageTarget()) {
        notifications.warning('Выберите чат для отправки изображения');
        return;
    }

    const files = imageItems.map(item => item.getAsFile()).filter(Boolean);
    if (files.length > 0) {
        queueFiles(files);
    }
}

function setupTtlMenu() {
    const button = document.getElementById('ttlToggleBtn');
    const menu = document.getElementById('ttlMenu');
    if (!button || !menu) return;
    const items = Array.from(menu.querySelectorAll('.ttl-menu-item'));

    const applyState = (seconds) => {
        selectedTtlSeconds = Number.isFinite(seconds) && seconds > 0 ? seconds : 0;
        const active = selectedTtlSeconds > 0;
        button.classList.toggle('is-active', active);
        button.setAttribute('aria-pressed', active ? 'true' : 'false');
        items.forEach((item) => {
            const value = Number(item.dataset.ttl || 0);
            item.classList.toggle('is-selected', value === selectedTtlSeconds);
        });
        const labelKey = TTL_OPTIONS.find((opt) => opt.seconds === selectedTtlSeconds)?.key;
        const label = labelKey ? t(labelKey) : `${selectedTtlSeconds}s`;
        button.title = active ? `${t('chat.ttl.toggle')}: ${label}` : t('chat.ttl.toggle');
    };

    const positionMenu = () => {
        const container = button.closest('.chat-input-area');
        if (!container) return;
        menu.style.visibility = 'hidden';
        menu.classList.add('show');
        menu.setAttribute('aria-hidden', 'false');
        const containerRect = container.getBoundingClientRect();
        const btnRect = button.getBoundingClientRect();
        const menuRect = menu.getBoundingClientRect();
        let left = btnRect.left - containerRect.left;
        const maxLeft = containerRect.width - menuRect.width - 12;
        if (left > maxLeft) left = maxLeft;
        if (left < 12) left = 12;
        const bottom = Math.max(12, containerRect.bottom - btnRect.top + 8);
        menu.style.left = `${left}px`;
        menu.style.bottom = `${bottom}px`;
        menu.style.visibility = '';
    };

    const closeMenu = () => {
        menu.classList.remove('show');
        menu.setAttribute('aria-hidden', 'true');
    };

    button.addEventListener('click', (e) => {
        e.stopPropagation();
        if (menu.classList.contains('show')) {
            closeMenu();
            return;
        }
        positionMenu();
    });

    items.forEach((item) => {
        item.addEventListener('click', (e) => {
            e.stopPropagation();
            applyState(Number(item.dataset.ttl || 0));
            closeMenu();
        });
    });

    document.addEventListener('click', (e) => {
        if (!menu.classList.contains('show')) return;
        if (menu.contains(e.target) || e.target === button) return;
        closeMenu();
    });

    window.addEventListener('resize', () => {
        if (menu.classList.contains('show')) {
            positionMenu();
        }
    });

    applyState(selectedTtlSeconds);
}

function getPendingAttachmentsContainer() {
    let container = document.getElementById('pendingAttachments');
    if (container) return container;
    const chatInputArea = document.getElementById('chatInputArea');
    if (!chatInputArea) return null;
    const wrapper = chatInputArea.querySelector('.chat-input-wrapper');
    container = document.createElement('div');
    container.id = 'pendingAttachments';
    container.className = 'pending-attachments';
    container.style.display = 'none';
    if (wrapper && wrapper.parentNode) {
        wrapper.parentNode.insertBefore(container, wrapper);
    } else {
        chatInputArea.appendChild(container);
    }
    return container;
}

function validateQueuedFile(file) {
    if (!file) return false;
    const maxSize = 10 * 1024 * 1024 * 1024;
    if (file.size > maxSize) {
        notifications.error('Файл слишком большой. Максимальный размер: 10 ГБ');
        return false;
    }
    return true;
}

function enqueueAttachment(file) {
    if (!validateQueuedFile(file)) return false;
    const safeName = normalizeUploadFileName(file);
    const isImage = file.type ? file.type.startsWith('image/') : isImageFileName(safeName);
    let previewUrl = '';
    if (isImage) {
        try {
            previewUrl = URL.createObjectURL(file);
        } catch (_) {
            previewUrl = '';
        }
    }
    pendingAttachments.push({
        id: generateTempId(),
        file,
        name: safeName,
        size: file.size,
        isImage,
        previewUrl
    });
    return true;
}

function queueFiles(files) {
    const list = Array.from(files || []);
    if (list.length === 0) return;
    let added = false;
    list.forEach((file) => {
        if (enqueueAttachment(file)) {
            added = true;
        }
    });
    if (added) {
        renderPendingAttachments();
        document.getElementById('messageInput')?.focus();
    }
}

function removePendingAttachment(id) {
    const idx = pendingAttachments.findIndex(item => item.id === id);
    if (idx === -1) return;
    const [removed] = pendingAttachments.splice(idx, 1);
    if (removed.previewUrl && removed.previewUrl.startsWith('blob:')) {
        URL.revokeObjectURL(removed.previewUrl);
    }
    renderPendingAttachments();
}

function clearPendingAttachments() {
    while (pendingAttachments.length > 0) {
        const removed = pendingAttachments.pop();
        if (removed.previewUrl && removed.previewUrl.startsWith('blob:')) {
            URL.revokeObjectURL(removed.previewUrl);
        }
    }
    renderPendingAttachments();
}

function renderPendingAttachments() {
    const container = getPendingAttachmentsContainer();
    if (!container) return;
    container.innerHTML = '';
    if (pendingAttachments.length === 0) {
        container.style.display = 'none';
        return;
    }
    container.style.display = 'flex';
    pendingAttachments.forEach((item) => {
        const card = document.createElement('div');
        card.className = 'pending-attachment';
        if (item.isImage) {
            card.classList.add('is-image');
        }

        const thumb = document.createElement('div');
        thumb.className = 'pending-attachment-thumb';
        if (item.isImage && item.previewUrl) {
            const img = document.createElement('img');
            img.src = item.previewUrl;
            img.alt = item.name;
            thumb.appendChild(img);
        } else {
            const icon = document.createElement('span');
            icon.className = 'app-icon app-icon-lg';
            icon.innerHTML = typeof appIconSvg === 'function' ? appIconSvg('file') : '📄';
            thumb.appendChild(icon);
        }

        const showMeta = !item.isImage || !item.previewUrl;
        let meta = null;
        if (showMeta) {
            meta = document.createElement('div');
            meta.className = 'pending-attachment-meta';
            const name = document.createElement('div');
            name.className = 'pending-attachment-name';
            name.textContent = item.name;
            const size = document.createElement('div');
            size.className = 'pending-attachment-size';
            size.textContent = formatFileSize(item.size || 0);
            meta.appendChild(name);
            meta.appendChild(size);
        }

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'pending-attachment-remove';
        removeBtn.setAttribute('aria-label', 'Удалить файл');
        removeBtn.textContent = '×';
        removeBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            removePendingAttachment(item.id);
        });

        card.appendChild(thumb);
        if (meta) {
            card.appendChild(meta);
        }
        card.appendChild(removeBtn);
        container.appendChild(card);
    });
}

function setupFileUpload() {
    const fileInput = document.getElementById('fileInput');
    if (!fileInput) return;
    
    fileInput.addEventListener('change', (e) => {
        queueFiles(e.target.files);
        fileInput.value = ''; // Сброс input
    });
}

function setupDragAndDropUpload() {
    const chatInputArea = document.getElementById('chatInputArea');
    const chatMessages = document.getElementById('chatMessages');
    const messageInput = document.getElementById('messageInput');
    const dropZones = [chatMessages, chatInputArea, messageInput].filter(Boolean);
    if (!dropZones.length) return;

    let dragCounter = 0;
    const hasFiles = (event) => {
        const types = event.dataTransfer?.types;
        if (!types) return false;
        return Array.from(types).includes('Files');
    };

    const setDropState = (active) => {
        dropZones.forEach((zone) => {
            zone.classList.toggle('is-drop-target', active);
        });
    };

    const handleDragEnter = (event) => {
        if (!hasFiles(event)) return;
        dragCounter += 1;
        setDropState(true);
        event.preventDefault();
    };

    const handleDragOver = (event) => {
        if (!hasFiles(event)) return;
        event.preventDefault();
        if (event.dataTransfer) {
            event.dataTransfer.dropEffect = 'copy';
        }
    };

    const handleDragLeave = (event) => {
        if (!hasFiles(event)) return;
        dragCounter = Math.max(0, dragCounter - 1);
        if (dragCounter === 0) {
            setDropState(false);
        }
    };

    const handleDrop = (event) => {
        if (!hasFiles(event)) return;
        event.preventDefault();
        dragCounter = 0;
        setDropState(false);
        const files = Array.from(event.dataTransfer?.files || []);
        if (files.length === 0) return;
        queueFiles(files);
    };

    dropZones.forEach((zone) => {
        zone.addEventListener('dragenter', handleDragEnter);
        zone.addEventListener('dragover', handleDragOver);
        zone.addEventListener('dragleave', handleDragLeave);
        zone.addEventListener('drop', handleDrop);
    });
}

function setupAttachMenu() {
    const attachBtn = document.getElementById('attachFileBtn');
    const fileInput = document.getElementById('fileInput');
    const menu = document.getElementById('attachMenu');
    const fileBtn = document.getElementById('attachMenuFile');
    const locationBtn = document.getElementById('attachMenuLocation');
    const liveLocationBtn = document.getElementById('attachMenuLiveLocation');
    const checklistBtn = document.getElementById('attachMenuChecklist');
    const giftBtn = document.getElementById('attachMenuPremiumGift');

    if (!attachBtn || !fileInput) return;

    if (!menu || !fileBtn || !locationBtn) {
        attachBtn.addEventListener('click', () => {
            fileInput.click();
        });
        return;
    }

    const positionMenu = () => {
        const container = attachBtn.closest('.chat-input-area');
        if (!container) return;
        menu.style.visibility = 'hidden';
        menu.classList.add('show');
        menu.setAttribute('aria-hidden', 'false');
        const containerRect = container.getBoundingClientRect();
        const btnRect = attachBtn.getBoundingClientRect();
        const menuRect = menu.getBoundingClientRect();
        let left = btnRect.left - containerRect.left;
        const maxLeft = containerRect.width - menuRect.width - 12;
        if (left > maxLeft) left = maxLeft;
        if (left < 12) left = 12;
        const bottom = Math.max(12, containerRect.bottom - btnRect.top + 8);
        menu.style.left = `${left}px`;
        menu.style.bottom = `${bottom}px`;
        menu.style.visibility = '';
    };

    const closeMenu = () => {
        menu.classList.remove('show');
        menu.setAttribute('aria-hidden', 'true');
    };

    attachBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (menu.classList.contains('show')) {
            closeMenu();
            return;
        }
        updatePremiumGiftAvailability();
        positionMenu();
    });

    fileBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        closeMenu();
        fileInput.click();
    });

    locationBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        closeMenu();
        sendLocationMessage();
    });

    if (liveLocationBtn) {
        liveLocationBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeMenu();
            openLiveLocationModal();
        });
    }

    if (checklistBtn) {
        checklistBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeMenu();
            openChecklistModal();
        });
    }

    if (giftBtn) {
        giftBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeMenu();
            openPremiumGiftModal();
        });
    }

    document.addEventListener('click', (e) => {
        if (!menu.classList.contains('show')) return;
        if (menu.contains(e.target) || e.target === attachBtn) return;
        closeMenu();
    });

    window.addEventListener('resize', () => {
        if (menu.classList.contains('show')) {
            positionMenu();
        }
    });

    updatePremiumGiftAvailability();
}

let premiumGiftModalApi = null;

function openPremiumGiftModal() {
    if (window.channelsModule?.isChannelActive?.() || window.groupsModule?.isGroupActive?.()) return;
    if (!canGiftPremiumInChat()) return;
    if (premiumGiftModalApi && typeof premiumGiftModalApi.open === 'function') {
        premiumGiftModalApi.open();
    }
}

function closePremiumGiftModal() {
    if (premiumGiftModalApi && typeof premiumGiftModalApi.close === 'function') {
        premiumGiftModalApi.close();
    }
}

function updatePremiumGiftAvailability() {
    const giftBtn = document.getElementById('attachMenuPremiumGift');
    if (!giftBtn) return;
    const channelActive = window.channelsModule?.isChannelActive?.();
    const groupActive = window.groupsModule?.isGroupActive?.();
    const allow = !channelActive && !groupActive && canGiftPremiumInChat();
    giftBtn.style.display = allow ? 'flex' : 'none';
}

let checklistModalApi = null;

function openChecklistModal() {
    if (checklistModalApi && typeof checklistModalApi.open === 'function') {
        checklistModalApi.open();
    }
}

function setupChecklistComposer() {
    const modal = document.getElementById('checklistModal');
    if (!modal) return;

    const closeBtn = document.getElementById('checklistModalClose');
    const cancelBtn = document.getElementById('checklistCancelBtn');
    const sendBtn = document.getElementById('checklistSendBtn');
    const addItemBtn = document.getElementById('checklistAddItemBtn');
    const titleInput = document.getElementById('checklistTitleInput');
    const itemsContainer = document.getElementById('checklistItemsEditor');
    const othersCanMark = document.getElementById('checklistOthersCanMark');
    const othersCanAdd = document.getElementById('checklistOthersCanAdd');

    if (!sendBtn || !addItemBtn || !titleInput || !itemsContainer) return;

    const buildRow = (value = '') => {
        const row = document.createElement('div');
        row.className = 'checklist-editor-row';

        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'checklist-editor-input';
        input.placeholder = t('chat.checklist.addItemPlaceholder');
        input.value = value;

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'checklist-editor-remove';
        removeBtn.textContent = '×';
        removeBtn.addEventListener('click', () => {
            row.remove();
        });

        row.appendChild(input);
        row.appendChild(removeBtn);
        return row;
    };

    const reset = () => {
        itemsContainer.innerHTML = '';
        itemsContainer.appendChild(buildRow());
        itemsContainer.appendChild(buildRow());
        titleInput.value = '';
        if (othersCanMark) othersCanMark.checked = true;
        if (othersCanAdd) othersCanAdd.checked = true;
    };

    const open = () => {
        reset();
        modal.style.display = 'flex';
        setTimeout(() => titleInput.focus(), 0);
    };

    const close = () => {
        modal.style.display = 'none';
    };

    addItemBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const row = buildRow();
        itemsContainer.appendChild(row);
        row.querySelector('input')?.focus();
    });

    sendBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const title = titleInput.value.trim();
        const itemInputs = Array.from(itemsContainer.querySelectorAll('.checklist-editor-input'));
        const items = itemInputs
            .map(input => input.value.trim())
            .filter(text => text.length > 0)
            .map(text => ({
                id: generateChecklistItemId(),
                text,
                done: false
            }));

        if (items.length === 0) {
            notifications.error(t('chat.checklist.emptyError'));
            return;
        }

        const payload = {
            id: generateChecklistId(),
            title,
            othersCanMark: othersCanMark ? othersCanMark.checked : true,
            othersCanAdd: othersCanAdd ? othersCanAdd.checked : true,
            items
        };

        const ok = await sendChecklistPayload(payload);
        if (ok) {
            close();
        }
    });

    closeBtn?.addEventListener('click', close);
    cancelBtn?.addEventListener('click', close);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            close();
        }
    });

    checklistModalApi = { open, close };
}

function setupPremiumGiftModal() {
    const modal = document.getElementById('premiumGiftModal');
    if (!modal) return;

    const closeBtn = document.getElementById('premiumGiftCloseBtn');
    const sendBtn = document.getElementById('premiumGiftSendBtn');
    const input = document.getElementById('premiumGiftUsername');

    const open = () => {
        if (!canGiftPremiumInChat()) return;
        const chatTarget = getPremiumGiftChatTarget();
        if (input) {
            input.value = chatTarget?.username ? `@${chatTarget.username}` : '';
        }
        updatePremiumGiftUI();
        modal.style.display = 'flex';
        setTimeout(() => input?.focus(), 0);
    };

    const close = () => {
        modal.style.display = 'none';
    };

    document.querySelectorAll('input[name="premiumGiftPlan"]').forEach(planInput => {
        planInput.addEventListener('change', () => {
            selectedPremiumGiftPlan = normalizePremiumGiftPlan(planInput.value);
            updatePremiumGiftUI();
        });
    });
    document.querySelectorAll('.premium-gift-plan').forEach(option => {
        option.addEventListener('click', () => {
            const plan = option.dataset.plan;
            if (!plan) return;
            selectedPremiumGiftPlan = normalizePremiumGiftPlan(plan);
            const planInput = option.querySelector('input[name="premiumGiftPlan"]');
            if (planInput) planInput.checked = true;
            updatePremiumGiftUI();
        });
    });

    sendBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        sendPremiumGift();
    });
    input?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            sendPremiumGift();
        }
    });
    closeBtn?.addEventListener('click', close);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            close();
        }
    });

    premiumGiftModalApi = { open, close };
}

function openLiveLocationModal() {
    const modal = document.getElementById('liveLocationModal');
    if (!modal) return;
    modal.style.display = 'flex';
}

function closeLiveLocationModal() {
    const modal = document.getElementById('liveLocationModal');
    if (!modal) return;
    modal.style.display = 'none';
}

function setupLiveLocationModal() {
    const modal = document.getElementById('liveLocationModal');
    if (!modal) return;
    const closeBtn = document.getElementById('liveLocationCloseBtn');
    closeBtn?.addEventListener('click', closeLiveLocationModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeLiveLocationModal();
        }
    });
    modal.querySelectorAll('.live-location-option').forEach(btn => {
        btn.addEventListener('click', () => {
            const duration = parseInt(btn.dataset.duration || '0', 10);
            closeLiveLocationModal();
            if (duration > 0) {
                startLiveLocationSharing(duration);
            }
        });
    });
}

function setupLiveLocationControls() {
    const stopBtn = document.getElementById('liveLocationStop');
    stopBtn?.addEventListener('click', () => {
        stopLiveLocationSharing('user');
    });
}

function setupAvatarUpload() {
    const avatar = document.getElementById('userAvatar');
    const avatarInput = document.getElementById('avatarInput');
    
    if (!avatar || !avatarInput) return;
    
    // Клик по аватару открывает file picker
    avatar.addEventListener('click', () => {
        avatarInput.click();
    });
    
    // Обработка выбора файла
    avatarInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        // Проверка типа файла
        if (!file.type.startsWith('image/')) {
            notifications.error('Пожалуйста, выберите изображение');
            avatarInput.value = '';
            return;
        }

        if (file.type === 'image/gif' && !isPremiumActive()) {
            notifications.warning(t('settings.premium.avatar.locked'));
            avatarInput.value = '';
            openSettingsPanel('premium');
            return;
        }
        
        // Проверка размера файла (10 MB)
        if (file.size > 10 * 1024 * 1024) {
            notifications.error('Размер файла не должен превышать 10 МБ');
            avatarInput.value = '';
            return;
        }
        
        // Preview изображения перед загрузкой
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = document.createElement('img');
            img.src = event.target.result;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            img.style.borderRadius = '50%';
            
            // Очищаем содержимое аватара и добавляем изображение
            avatar.innerHTML = '';
            avatar.appendChild(img);
            
            // Загружаем аватар
            uploadAvatar(file);
        };
        reader.readAsDataURL(file);
    });
}

// Open Settings from the app menu user card
function setupUserSettingsEntry() {
    const menuUser = document.querySelector('.app-menu-user');
    if (!menuUser) return;
    menuUser.style.cursor = 'pointer';
    menuUser.title = 'Открыть настройки профиля';
    menuUser.addEventListener('click', () => {
        openSettingsPanel('account');
        closeAppMenu();
    });
}

function setupPinnedPanelClick() {
    const panel = document.getElementById('pinnedPanel');
    if (!panel) return;
    panel.addEventListener('click', () => {
        const targetId = panel.dataset.messageId;
        if (!targetId) return;
        const el = document.getElementById(`msg-${targetId}`) || document.querySelector(`[data-message-id="${targetId}"]`);
        if (el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            el.classList.add('highlight');
            setTimeout(() => el.classList.remove('highlight'), 1500);
        }
    });
}

function createVisibilitySelect(id, value) {
    const sel = document.createElement('select');
    sel.id = id;
    sel.className = 'modal-input';
    ['everyone', 'contacts', 'nobody'].forEach(v => {
        const o = document.createElement('option');
        o.value = v;
        o.textContent = v === 'everyone' ? 'Все' : (v === 'contacts' ? 'Контакты' : 'Никто');
        if (v === value) o.selected = true;
        sel.appendChild(o);
    });
    return sel;
}

async function openMySettingsModal() {
    const token = localStorage.getItem('xipher_token');
    const userId = localStorage.getItem('xipher_user_id');
    if (!token || !userId) {
        notifications.error('Необходима авторизация');
        return;
    }

    const existing = document.getElementById('mySettingsModal');
    if (existing) existing.remove();

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.id = 'mySettingsModal';
    overlay.style.display = 'flex';
    overlay.innerHTML = `
        <div class="modal-content" style="max-width: 760px; width: 95%;">
            <div class="modal-header">
                <h2 style="margin:0;">Настройки</h2>
                <button class="close-btn" id="closeMySettingsModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-tabs" style="display:flex; gap: 0.5rem; border-bottom: 1px solid var(--border-color); margin-bottom: 1rem;">
                    <button class="settings-tab active" data-tab="profile" type="button">Профиль</button>
                    <button class="settings-tab" data-tab="privacy" type="button">Конфиденциальность</button>
                </div>
                <div class="settings-tab-content" id="mySettingsTabProfile" style="display:block;">
                    <div style="display:flex; gap: 14px; align-items:center; margin-bottom: 12px;">
                        <div id="mySettingsAvatar" style="width:64px;height:64px;border-radius:50%;background: var(--gradient-purple);display:flex;align-items:center;justify-content:center;overflow:hidden;flex:0 0 64px;"></div>
                        <div style="flex:1; min-width:0;">
                            <div style="color: var(--text-secondary); font-size: 0.85rem;">Фото профиля</div>
                            <button class="btn-secondary btn-small" id="mySettingsChangeAvatarBtn" type="button" style="margin-top:6px;">Сменить фото</button>
                        </div>
                    </div>

                    <div class="input-group">
                        <label>Имя</label>
                        <input id="myProfileFirstName" class="modal-input" type="text" placeholder="Имя">
                    </div>
                    <div class="input-group">
                        <label>Фамилия</label>
                        <input id="myProfileLastName" class="modal-input" type="text" placeholder="Фамилия">
                    </div>
                    <div class="input-group">
                        <label>Bio</label>
                        <textarea id="myProfileBio" class="modal-textarea" rows="3" placeholder="О себе"></textarea>
                    </div>
                    <div class="input-group">
                        <label>Дата рождения</label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap;">
                            <input id="myProfileBirthDay" class="modal-input" type="number" min="0" max="31" placeholder="День" style="width: 110px;">
                            <input id="myProfileBirthMonth" class="modal-input" type="number" min="0" max="12" placeholder="Месяц" style="width: 110px;">
                            <input id="myProfileBirthYear" class="modal-input" type="number" min="0" max="2100" placeholder="Год (опц.)" style="width: 140px;">
                        </div>
                        <small style="color: var(--text-muted);">Оставь 0, чтобы не указывать</small>
                    </div>
                    <div class="modal-actions">
                        <button class="btn-primary" id="saveMyProfileBtn" type="button">Сохранить профиль</button>
                    </div>
                </div>

                <div class="settings-tab-content" id="mySettingsTabPrivacy" style="display:none;">
                    <div style="color: var(--text-secondary); margin-bottom: 10px;">Кто видит ваши данные</div>
                    <div class="input-group" id="privacyBioRow">
                        <label>Bio</label>
                    </div>
                    <div class="input-group" id="privacyBirthRow">
                        <label>Дата рождения</label>
                    </div>
                    <div class="input-group" id="privacyLastSeenRow">
                        <label>Последняя активность</label>
                    </div>
                    <div class="input-group" id="privacyAvatarRow">
                        <label>Фото профиля</label>
                    </div>
                    <div class="input-group toggle-row">
                        <label for="privacyReadReceiptsToggleModal">Отправлять прочтения</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="privacyReadReceiptsToggleModal">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="modal-actions">
                        <button class="btn-primary" id="saveMyPrivacyBtn" type="button">Сохранить приватность</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(overlay);

    const close = () => overlay.remove();
    overlay.querySelector('#closeMySettingsModal')?.addEventListener('click', close);
    overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });

    // tabs
    overlay.querySelectorAll('.settings-tab').forEach(btn => {
        btn.addEventListener('click', () => {
            overlay.querySelectorAll('.settings-tab').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const tab = btn.dataset.tab;
            overlay.querySelector('#mySettingsTabProfile').style.display = (tab === 'profile') ? 'block' : 'none';
            overlay.querySelector('#mySettingsTabPrivacy').style.display = (tab === 'privacy') ? 'block' : 'none';
        });
    });

    // Load my data
    try {
        const res = await fetch(API_BASE + '/api/get-user-profile', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, user_id: userId })
        });
        const data = await res.json();
        if (!data.success || !data.user) {
            notifications.error(data.error || 'Не удалось загрузить настройки');
            close();
            return;
        }
        const u = data.user;
        const storedAvatarUrl = getStoredAvatarUrl(userId);
        const serverAvatarUrl = u.avatar_url || '';
        if (serverAvatarUrl !== storedAvatarUrl) {
            setStoredAvatarUrl(userId, serverAvatarUrl);
            updateAvatarDisplay(serverAvatarUrl);
        }

        // Avatar preview
        const av = overlay.querySelector('#mySettingsAvatar');
        if (av) {
            const initials = (localStorage.getItem('xipher_username') || 'U').charAt(0).toUpperCase();
            const url = serverAvatarUrl || storedAvatarUrl || '';
            av.innerHTML = url
                ? `<img src="${url}" style="width:100%;height:100%;object-fit:cover;" onerror="this.remove();">`
                : `<span style="font-weight:700; font-size:24px; color:#fff;">${escapeHtml(initials)}</span>`;
        }

        overlay.querySelector('#myProfileFirstName').value = u.first_name || '';
        overlay.querySelector('#myProfileLastName').value = u.last_name || '';
        overlay.querySelector('#myProfileBio').value = u.bio || '';
        overlay.querySelector('#myProfileBirthDay').value = u.birth_day || 0;
        overlay.querySelector('#myProfileBirthMonth').value = u.birth_month || 0;
        overlay.querySelector('#myProfileBirthYear').value = u.birth_year || 0;

        const priv = u.privacy || {};
        overlay.querySelector('#privacyBioRow').appendChild(createVisibilitySelect('myPrivacyBio', priv.bio_visibility || 'everyone'));
        overlay.querySelector('#privacyBirthRow').appendChild(createVisibilitySelect('myPrivacyBirth', priv.birth_visibility || 'contacts'));
        overlay.querySelector('#privacyLastSeenRow').appendChild(createVisibilitySelect('myPrivacyLastSeen', priv.last_seen_visibility || 'contacts'));
        overlay.querySelector('#privacyAvatarRow').appendChild(createVisibilitySelect('myPrivacyAvatar', priv.avatar_visibility || 'everyone'));
        const readToggle = overlay.querySelector('#privacyReadReceiptsToggleModal');
        if (readToggle) {
            if (typeof priv.send_read_receipts !== 'undefined') {
                readToggle.checked = Boolean(priv.send_read_receipts);
                setReadReceiptsEnabled(readToggle.checked);
            } else {
                readToggle.checked = isReadReceiptsEnabled();
            }
        }
    } catch (e) {
        console.error('openMySettingsModal load error', e);
        notifications.error('Ошибка загрузки настроек');
        close();
        return;
    }

    // Change avatar (reuse file input)
    overlay.querySelector('#mySettingsChangeAvatarBtn')?.addEventListener('click', () => {
        const inp = document.getElementById('avatarInput');
        if (inp) inp.click();
    });

    // Save profile
    overlay.querySelector('#saveMyProfileBtn')?.addEventListener('click', async () => {
        const first_name = (overlay.querySelector('#myProfileFirstName')?.value || '').trim();
        const last_name = (overlay.querySelector('#myProfileLastName')?.value || '').trim();
        const bio = (overlay.querySelector('#myProfileBio')?.value || '').trim();
        const birth_day = parseInt(overlay.querySelector('#myProfileBirthDay')?.value || '0', 10) || 0;
        const birth_month = parseInt(overlay.querySelector('#myProfileBirthMonth')?.value || '0', 10) || 0;
        const birth_year = parseInt(overlay.querySelector('#myProfileBirthYear')?.value || '0', 10) || 0;
        try {
            const res = await fetch(API_BASE + '/api/update-my-profile', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ token, first_name, last_name, bio, birth_day, birth_month, birth_year })
            });
            const data = await res.json();
            if (data.success) {
                notifications.success('Профиль сохранён');
                refreshMyDisplayName();
            } else {
                notifications.error(data.error || 'Не удалось сохранить профиль');
            }
        } catch (e) {
            console.error('save profile error', e);
            notifications.error('Ошибка сохранения профиля');
        }
    });

    // Save privacy
    overlay.querySelector('#saveMyPrivacyBtn')?.addEventListener('click', async () => {
        const bio_visibility = overlay.querySelector('#myPrivacyBio')?.value || 'everyone';
        const birth_visibility = overlay.querySelector('#myPrivacyBirth')?.value || 'contacts';
        const last_seen_visibility = overlay.querySelector('#myPrivacyLastSeen')?.value || 'contacts';
        const avatar_visibility = overlay.querySelector('#myPrivacyAvatar')?.value || 'everyone';
        const sendReadReceipts = overlay.querySelector('#privacyReadReceiptsToggleModal')?.checked;
        setReadReceiptsEnabled(sendReadReceipts !== false);
        try {
            const res = await fetch(API_BASE + '/api/update-my-privacy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ token, bio_visibility, birth_visibility, last_seen_visibility, avatar_visibility, send_read_receipts: sendReadReceipts !== false })
            });
            const data = await res.json();
            if (data.success) {
                notifications.success('Приватность сохранена');
            } else {
                notifications.error(data.error || 'Не удалось сохранить приватность');
            }
        } catch (e) {
            console.error('save privacy error', e);
            notifications.error('Ошибка сохранения приватности');
        }
    });
}

async function uploadAvatar(file) {
    try {
        const token = localStorage.getItem('xipher_token');
        if (!token) {
            notifications.error('Необходима авторизация');
            return;
        }
        
        // Создаем FormData для multipart/form-data
        const formData = new FormData();
        formData.append('token', token);
        formData.append('avatar', file);
        
        // Показываем индикатор загрузки
        const avatar = document.getElementById('userAvatar');
        if (avatar) {
            avatar.style.opacity = '0.5';
            avatar.style.pointerEvents = 'none';
        }
        
        const response = await fetch(API_BASE + '/api/upload_avatar', {
            method: 'POST',
            body: formData
        });
        
        const data = await response.json();
        
        if (data.status === 'ok' && data.url) {
            // Обновляем аватар с сервера
            updateAvatarDisplay(data.url);
            notifications.success('Аватар успешно обновлен');
        } else {
            notifications.error(data.error || 'Ошибка загрузки аватара');
            // Восстанавливаем предыдущий аватар
            loadUserAvatar();
        }
        
        if (avatar) {
            avatar.style.opacity = '1';
            avatar.style.pointerEvents = 'auto';
        }
        
        // Очищаем input
        document.getElementById('avatarInput').value = '';
        
    } catch (error) {
        console.error('Error uploading avatar:', error);
        notifications.error('Ошибка загрузки аватара');
        
        const avatar = document.getElementById('userAvatar');
        if (avatar) {
            avatar.style.opacity = '1';
            avatar.style.pointerEvents = 'auto';
        }
        
        // Восстанавливаем предыдущий аватар
        loadUserAvatar();
    }
}

function updateAvatarDisplay(avatarUrl) {
    const avatar = document.getElementById('userAvatar');
    const settingsAvatar = document.getElementById('settingsAvatar');
    const username = localStorage.getItem('xipher_username') || 'U';
    const fallback = username.charAt(0).toUpperCase();

    const applyAvatar = (target) => {
        if (!target) return;
        if (avatarUrl) {
            const img = document.createElement('img');
            img.src = avatarUrl;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            img.style.borderRadius = '50%';
            img.onerror = () => {
                target.innerHTML = fallback;
            };
            target.innerHTML = '';
            target.appendChild(img);
        } else {
            target.textContent = fallback;
        }
    };

    applyAvatar(avatar);
    applyAvatar(settingsAvatar);

    setStoredAvatarUrl(getCurrentUserId(), avatarUrl);
}

function loadUserAvatar() {
    // Загружаем аватар пользователя из БД (можно добавить API endpoint для получения информации о пользователе)
    // Пока используем сохраненный URL или отображаем букву
    const savedAvatarUrl = getStoredAvatarUrl(getCurrentUserId());
    if (savedAvatarUrl) {
        updateAvatarDisplay(savedAvatarUrl);
    } else {
        updateAvatarDisplay('');
    }
}

// Обработка обновления аватара пользователя
function handleAvatarUpdated(data) {
    if (!data.user_id || !data.avatar_url) {
        console.error('Invalid avatar_updated message:', data);
        return;
    }
    
    const currentUserId = currentUser?.id || localStorage.getItem('xipher_user_id');
    
    // Если обновился собственный аватар
    if (data.user_id === currentUserId) {
        updateAvatarDisplay(data.avatar_url);
    }
    
    // Обновляем аватар в списках чатов и друзей
    updateAvatarInChats(data.user_id, data.avatar_url);
    updateAvatarInFriends(data.user_id, data.avatar_url);
    
    // Обновляем аватар в текущем чате, если он открыт
    if (currentChat && currentChat.id === data.user_id) {
        currentChat.avatar_url = data.avatar_url;
        const chatHeaderAvatar = document.getElementById('chatHeaderAvatar');
        if (chatHeaderAvatar) {
            if (data.avatar_url) {
                const img = document.createElement('img');
                img.src = data.avatar_url;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                img.style.borderRadius = '50%';
                img.onerror = () => {
                    chatHeaderAvatar.textContent = currentChat.name?.charAt(0).toUpperCase() || 'F';
                };
                chatHeaderAvatar.innerHTML = '';
                chatHeaderAvatar.appendChild(img);
            }
        }
    }
}

// Обновление аватара в списке чатов
function updateAvatarInChats(userId, avatarUrl) {
    const chatsList = document.getElementById('chatsList');
    if (!chatsList) return;
    
    const chatItems = chatsList.querySelectorAll('[data-chat-id="' + userId + '"]');
    chatItems.forEach(item => {
        const avatarElement = item.querySelector('.chat-avatar');
        if (avatarElement) {
            if (avatarUrl) {
                const img = document.createElement('img');
                img.src = avatarUrl;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                img.style.borderRadius = '50%';
                img.onerror = () => {
                    // Fallback к тексту при ошибке загрузки
                    const chatName = item.querySelector('.chat-name')?.textContent || 'U';
                    avatarElement.textContent = chatName.charAt(0).toUpperCase();
                };
                avatarElement.innerHTML = '';
                avatarElement.appendChild(img);
            } else {
                const chatName = item.querySelector('.chat-name')?.textContent || 'U';
                avatarElement.textContent = chatName.charAt(0).toUpperCase();
            }
        }
    });
}

// Обновление аватара в списке друзей
function updateAvatarInFriends(userId, avatarUrl) {
    const friendsList = document.getElementById('friendsList');
    if (!friendsList) return;
    
    const friendItems = friendsList.querySelectorAll('[data-friend-id="' + userId + '"]');
    friendItems.forEach(item => {
        const avatarElement = item.querySelector('.friend-avatar');
        if (avatarElement) {
            if (avatarUrl) {
                const img = document.createElement('img');
                img.src = avatarUrl;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                img.style.borderRadius = '50%';
                img.onerror = () => {
                    // Fallback к тексту при ошибке загрузки
                    const friendName = item.querySelector('.friend-name')?.textContent || 'U';
                    avatarElement.textContent = friendName.charAt(0).toUpperCase();
                };
                avatarElement.innerHTML = '';
                avatarElement.appendChild(img);
            } else {
                const friendName = item.querySelector('.friend-name')?.textContent || 'U';
                avatarElement.textContent = friendName.charAt(0).toUpperCase();
            }
        }
    });
}

function setupEmojiPicker() {
    const emojiBtn = document.getElementById('emojiBtn');
    const emojiPicker = document.getElementById('emojiPicker');
    const emojiPickerClose = document.getElementById('emojiPickerClose');
    const emojiGrid = document.getElementById('emojiGrid');
    const emojiSearch = document.getElementById('emojiSearch');
    
    // Используем emoji-picker-element для поддержки 100000+ эмодзи
    let emojiPickerElement = null;
    
    // Проверяем доступность библиотеки (веб-компонент регистрируется автоматически)
    // Ждем, пока веб-компонент загрузится
    const initEmojiPicker = () => {
        if (customElements.get('emoji-picker')) {
            // Создаем элемент пикера
            emojiPickerElement = document.createElement('emoji-picker');
            emojiPickerElement.setAttribute('locale', 'ru');
            emojiPickerElement.setAttribute('skin-tone-visible', 'true');
            emojiPickerElement.setAttribute('native', 'true');
            
            // Обработчик выбора эмодзи
            emojiPickerElement.addEventListener('emoji-click', (event) => {
                const emoji = event.detail.unicode || event.detail.emoji.unicode;
                if (emoji) {
                    insertEmoji(emoji);
                    emojiPicker.style.display = 'none';
                }
            });
            
            // Добавляем в контейнер
            const pickerContainer = emojiPicker.querySelector('.emoji-picker');
            if (pickerContainer) {
                // Очищаем старый контент
                emojiGrid.innerHTML = '';
                pickerContainer.insertBefore(emojiPickerElement, emojiGrid);
            }
            return true;
        }
        return false;
    };
    
    // Пытаемся инициализировать сразу, если компонент уже загружен
    if (!initEmojiPicker()) {
        // Если не загружен, ждем и пробуем снова
        setTimeout(() => {
            if (!initEmojiPicker()) {
                // Если все еще не загружен, используем fallback
                initFallbackEmojiPicker();
            }
        }, 500);
    }
    
    function initFallbackEmojiPicker() {
        // Fallback на базовый набор эмодзи
        const emojis = ['😀', '😃', '😄', '😁', '😆', '😅', '🤣', '😂', '🙂', '🙃', '😉', '😊', '😇', '🥰', '😍', '🤩', '😘', '😗', '😚', '😙', '😋', '😛', '😜', '🤪', '😝', '🤑', '🤗', '🤭', '🤫', '🤔', '🤐', '🤨', '😐', '😑', '😶', '😏', '😒', '🙄', '😬', '🤥', '😌', '😔', '😪', '🤤', '😴', '😷', '🤒', '🤕', '🤢', '🤮', '🤧', '🥵', '🥶', '😶‍🌫️', '😵', '😵‍💫', '🤯', '🤠', '🥳', '😎', '🤓', '🧐', '😕', '😟', '🙁', '☹️', '😮', '😯', '😲', '😳', '🥺', '😦', '😧', '😨', '😰', '😥', '😢', '😭', '😱', '😖', '😣', '😞', '😓', '😩', '😫', '🥱', '😤', '😡', '😠', '🤬', '😈', '👿', '💀', '☠️', '💩', '🤡', '👹', '👺', '👻', '👽', '👾', '🤖', '😺', '😸', '😹', '😻', '😼', '😽', '🙀', '😿', '😾'];
        
        emojis.forEach(emoji => {
            const emojiItem = document.createElement('div');
            emojiItem.className = 'emoji-item';
            emojiItem.textContent = emoji;
            emojiItem.addEventListener('click', () => {
                insertEmoji(emoji);
                emojiPicker.style.display = 'none';
            });
            emojiGrid.appendChild(emojiItem);
        });
    }
    
    emojiBtn.addEventListener('click', () => {
        emojiPicker.style.display = emojiPicker.style.display === 'none' ? 'block' : 'none';
    });
    
    emojiPickerClose.addEventListener('click', () => {
        emojiPicker.style.display = 'none';
    });
    
    // Поиск эмодзи (если используется fallback)
    if (emojiSearch) {
        emojiSearch.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            if (emojiPickerElement) {
                // Для emoji-picker-element поиск встроен
                emojiPickerElement.search = query;
            } else {
                // Fallback поиск
                const items = emojiGrid.querySelectorAll('.emoji-item');
                items.forEach(item => {
                    item.style.display = query === '' || item.textContent.includes(query) ? 'block' : 'none';
                });
            }
        });
    }
    
    // Закрытие при клике вне пикера
    document.addEventListener('click', (e) => {
        if (emojiPicker && !emojiPicker.contains(e.target) && e.target !== emojiBtn) {
            emojiPicker.style.display = 'none';
        }
    });
}

function insertEmoji(emoji) {
    const messageInput = document.getElementById('messageInput');
    const cursorPos = messageInput.selectionStart;
    const textBefore = messageInput.value.substring(0, cursorPos);
    const textAfter = messageInput.value.substring(cursorPos);
    messageInput.value = textBefore + emoji + textAfter;
    messageInput.selectionStart = messageInput.selectionEnd = cursorPos + emoji.length;
    messageInput.focus();
    messageInput.dispatchEvent(new Event('input'));
}

function setupVoiceRecording() {
    const voiceBtn = document.getElementById('voiceBtn');
    const chatInputArea = document.getElementById('chatInputArea');
    const recordingOverlay = document.getElementById('voiceRecordingOverlay');
    const recordingTimer = document.getElementById('voiceRecordingTimer');
    const recordingHint = document.getElementById('voiceRecordingHint');
    const recordingStop = document.getElementById('voiceRecordingStop');
    let isRecording = false;
    let isLocked = false;
    let mediaStream = null;
    let pointerId = null;
    let pressStartY = 0;
    let recordStartTime = 0;
    let timerInterval = null;
    const LOCK_THRESHOLD_PX = 42;
    
    // Проверяем доступность MediaRecorder API
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        voiceBtn.style.opacity = '0.5';
        voiceBtn.title = 'Голосовые сообщения не поддерживаются в этом браузере';
        return;
    }

    if (recordingStop) {
        recordingStop.addEventListener('click', (e) => {
            e.stopPropagation();
            stopRecording();
        });
    }

    voiceBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        if (isRecording) {
            if (isLocked) {
                stopRecording();
            }
            return;
        }
        pointerId = e.pointerId;
        pressStartY = e.clientY;
        if (voiceBtn.setPointerCapture) {
            voiceBtn.setPointerCapture(pointerId);
        }
        startRecording();
    });

    voiceBtn.addEventListener('pointermove', (e) => {
        if (!isRecording || isLocked) return;
        if (pointerId !== null && e.pointerId !== pointerId) return;
        const deltaY = e.clientY - pressStartY;
        if (deltaY < -LOCK_THRESHOLD_PX) {
            setLocked(true);
        }
    });

    voiceBtn.addEventListener('pointerup', (e) => {
        if (!isRecording) return;
        if (pointerId !== null && e.pointerId !== pointerId) return;
        if (!isLocked) {
            stopRecording();
        }
        pointerId = null;
    });

    voiceBtn.addEventListener('pointercancel', () => {
        if (!isRecording) return;
        if (!isLocked) {
            stopRecording();
        }
        pointerId = null;
    });

    voiceBtn.addEventListener('click', (e) => {
        if (isRecording && isLocked) {
            e.preventDefault();
            stopRecording();
        }
    });

    function startTimer() {
        if (!recordingTimer) return;
        clearInterval(timerInterval);
        recordStartTime = Date.now();
        const update = () => {
            const elapsed = Math.max(0, Date.now() - recordStartTime);
            const totalSeconds = Math.floor(elapsed / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            recordingTimer.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        };
        update();
        timerInterval = setInterval(update, 250);
    }

    function stopTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
        if (recordingTimer) {
            recordingTimer.textContent = '00:00';
        }
    }

    function setRecordingUI(active) {
        if (recordingOverlay) {
            recordingOverlay.classList.toggle('is-active', active);
        }
        if (chatInputArea) {
            chatInputArea.classList.toggle('is-voice-recording', active);
        }
        voiceBtn.classList.toggle('is-recording', active);
    }

    function setLocked(locked) {
        isLocked = locked;
        if (recordingOverlay) {
            recordingOverlay.classList.toggle('is-locked', locked);
        }
        voiceBtn.classList.toggle('is-locked', locked);
        if (recordingHint) {
            recordingHint.textContent = locked ? 'Запись закреплена' : 'Потяните вверх, чтобы закрепить';
        }
        voiceBtn.title = locked ? 'Нажмите для остановки записи' : 'Отпустите для завершения записи';
    }

    async function startRecording() {
        if (isRecording) return;
        
        try {
            // Запрашиваем разрешение на микрофон
            mediaStream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            });
            
            // Определяем поддерживаемый MIME тип
            let mimeType = 'audio/webm';
            if (MediaRecorder.isTypeSupported('audio/ogg; codecs=opus')) {
                mimeType = 'audio/ogg; codecs=opus';
            } else if (MediaRecorder.isTypeSupported('audio/webm; codecs=opus')) {
                mimeType = 'audio/webm; codecs=opus';
            } else if (MediaRecorder.isTypeSupported('audio/webm')) {
                mimeType = 'audio/webm';
            } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                mimeType = 'audio/mp4';
            }
            
            mediaRecorder = new MediaRecorder(mediaStream, { mimeType: mimeType });
            audioChunks = [];
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data && event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = async () => {
                if (audioChunks.length === 0) {
                    notifications.warning('Запись пуста');
                    if (mediaStream) {
                        mediaStream.getTracks().forEach(track => track.stop());
                        mediaStream = null;
                    }
                    return;
                }
                
                const audioBlob = new Blob(audioChunks, { type: mimeType });
                await uploadVoiceMessage(audioBlob, mimeType);
                
                // Останавливаем все треки
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                    mediaStream = null;
                }
            };
            
            mediaRecorder.onerror = (event) => {
                console.error('MediaRecorder error:', event);
                notifications.error('Ошибка записи');
                stopRecording();
            };
            
            mediaRecorder.start(100); // Собираем данные каждые 100мс
            isRecording = true;
            setLocked(false);
            setRecordingUI(true);
            startTimer();
            voiceBtn.textContent = '⏺';
            voiceBtn.title = 'Отпустите для завершения записи';
        } catch (error) {
            console.error('Error starting recording:', error);
            isRecording = false;
            mediaStream = null;
            
            if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                notifications.error('Доступ к микрофону запрещен. Разрешите доступ в настройках браузера.');
            } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                notifications.error('Микрофон не найден. Проверьте подключение устройства.');
            } else {
                notifications.error('Не удалось начать запись: ' + error.message);
            }
        }
    }
    
    function stopRecording() {
        if (!isRecording || !mediaRecorder) return;
        
        if (mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }
        
        isRecording = false;
        setRecordingUI(false);
        setLocked(false);
        stopTimer();
        voiceBtn.innerHTML = typeof appIcon === 'function' ? appIcon('mic') : '🎤';
        voiceBtn.title = 'Голосовое сообщение';
        
        // Если запись уже остановлена, не показываем уведомление
        if (mediaRecorder.state !== 'inactive') {
            notifications.info('Запись завершена, отправка...');
        }
    }
}

function setupReply() {
    const replyPreviewClose = document.getElementById('replyPreviewClose');
    
    replyPreviewClose.addEventListener('click', () => {
        clearReplyState();
    });
}

function setupReportModal() {
    const modal = document.getElementById('reportModal');
    if (!modal) return;
    const closeBtn = document.getElementById('closeReportModal');
    const cancelBtn = document.getElementById('cancelReportBtn');
    const submitBtn = document.getElementById('submitReportBtn');

    const close = () => closeReportModal();
    if (closeBtn) closeBtn.addEventListener('click', close);
    if (cancelBtn) cancelBtn.addEventListener('click', close);
    if (submitBtn) submitBtn.addEventListener('click', submitReport);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeReportModal();
        }
    });
}

function setupDeleteChatModal() {
    const modal = document.getElementById('deleteChatModal');
    if (!modal) return;
    const closeBtn = document.getElementById('closeDeleteChatModal');
    const cancelBtn = document.getElementById('deleteChatCancelBtn');
    const deleteMeBtn = document.getElementById('deleteChatMeBtn');
    const deleteAllBtn = document.getElementById('deleteChatAllBtn');

    const close = () => closeDeleteChatModal();
    if (closeBtn) closeBtn.addEventListener('click', close);
    if (cancelBtn) cancelBtn.addEventListener('click', close);
    if (deleteMeBtn) {
        deleteMeBtn.addEventListener('click', () => {
            if (!pendingDeleteChat) return;
            hideChatForMe(pendingDeleteChat);
            notifications.success('Чат удалён у вас');
            closeDeleteChatModal();
        });
    }
    if (deleteAllBtn) {
        deleteAllBtn.addEventListener('click', async () => {
            if (!pendingDeleteChat) return;
            await deleteChatForAll(pendingDeleteChat);
        });
    }
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeDeleteChatModal();
        }
    });
}

function getFileExtensionFromMime(mimeType) {
    const normalized = (mimeType || '').toLowerCase();
    if (normalized === 'image/jpeg' || normalized === 'image/jpg') return 'jpg';
    if (normalized === 'image/png') return 'png';
    if (normalized === 'image/gif') return 'gif';
    if (normalized === 'image/webp') return 'webp';
    if (normalized === 'image/bmp') return 'bmp';
    if (normalized === 'image/svg+xml') return 'svg';
    if (normalized === 'image/apng') return 'apng';
    if (normalized === 'image/tiff') return 'tiff';
    return '';
}

function normalizeUploadFileName(file) {
    const rawName = (file?.name || '').trim();
    const sanitized = rawName.split(/[\\/]/).pop();
    const hasExt = sanitized.includes('.') && sanitized.lastIndexOf('.') > 0 && sanitized.lastIndexOf('.') < sanitized.length - 1;
    const ext = getFileExtensionFromMime(file?.type);
    if (sanitized && (hasExt || !ext)) {
        return sanitized;
    }
    const unique = `${Date.now()}_${Math.random().toString(16).slice(2, 6)}`;
    const base = sanitized && !hasExt ? sanitized : `clipboard_${unique}`;
    return ext ? `${base}.${ext}` : base;
}

function getAttachmentMessageContent(messageType, fileName, isImage) {
    if (messageType === 'voice') {
        return (typeof appIcon === 'function' ? appIcon('mic') : '🎤') + ' Голосовое сообщение';
    }
    if (messageType === 'image' || isImage) {
        return 'Фото';
    }
    const safeName = fileName || 'file';
    return (typeof appIcon === 'function' ? appIcon('attachment') : '📎') + ` ${safeName}`;
}

async function sendFileMessageToTarget({
    target,
    filePath,
    fileName,
    fileSize,
    messageType,
    isImage,
    ttlSeconds,
    caption,
    useSpoiler
}) {
    if (!target) return false;
    if (target.type === 'dm') {
        return sendMessageWithFile(filePath, fileName, fileSize, messageType, {
            caption,
            isImage,
            spoiler: useSpoiler,
            ttlSeconds
        });
    }

    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications.error('Необходима авторизация');
        window.location.href = '/login';
        return false;
    }

    const safeName = fileName || 'file';
    const baseContent = (typeof caption === 'string' && caption.trim())
        ? caption.trim()
        : getAttachmentMessageContent(messageType, safeName, isImage);
    const endpoint = target.type === 'group' ? '/api/send-group-message' : '/api/send-channel-message';
    const body = {
        token,
        content: baseContent,
        message_type: messageType,
        file_path: filePath,
        file_name: safeName,
        file_size: fileSize || 0
    };
    if (target.type === 'group') {
        body.group_id = target.id;
    } else if (target.type === 'channel') {
        body.channel_id = target.id;
    }
    if (Number.isFinite(ttlSeconds) && ttlSeconds > 0) {
        body.ttl_seconds = ttlSeconds;
    }

    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        let data = {};
        try {
            data = await response.json();
        } catch (_) {
            data = {};
        }
        if (!data || !data.success) {
            const msg = (data && (data.message || data.error)) || 'Ошибка отправки сообщения';
            notifications.error(msg);
            if (typeof msg === 'string' && msg.toLowerCase().includes('invalid token')) {
                await window.xipherSession?.logout();
                setTimeout(() => {
                    window.location.href = '/login';
                }, 300);
            }
            return false;
        }

        if (target.type === 'group') {
            if (typeof loadGroupMessages === 'function') {
                await loadGroupMessages(target.id);
            }
        } else if (target.type === 'channel') {
            if (typeof loadChannelMessages === 'function') {
                await loadChannelMessages(target.id);
            }
        }
        if (typeof loadAllChats === 'function') {
            loadAllChats();
        } else if (typeof loadChats === 'function') {
            loadChats();
        }
        replyToMessage = null;
        const replyPreview = document.getElementById('replyPreview');
        if (replyPreview) replyPreview.style.display = 'none';
        return true;
    } catch (error) {
        console.error('Error sending attachment message:', error);
        notifications.error('Ошибка отправки сообщения');
        return false;
    }
}

async function uploadFile(file, options = {}) {
    if (!file) return false;
    const target = options.target || resolveMessageTarget();
    if (!target) {
        notifications.warning('Выберите чат для отправки файла');
        return false;
    }
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications.error('Необходима авторизация');
        window.location.href = '/login';
        return false;
    }

    // Проверка размера (10 ГБ = 10 * 1024 * 1024 * 1024 байт)
    const maxSize = 10 * 1024 * 1024 * 1024;
    if (file.size > maxSize) {
        notifications.error('Файл слишком большой. Максимальный размер: 10 ГБ');
        return false;
    }

    const rawCaption = typeof options.caption === 'string' ? options.caption : '';
    const parsedCaption = parseSpoilerMarkup(rawCaption, { allowEmpty: true });
    const caption = parsedCaption.content.trim();
    const mediaGroupId = typeof options.mediaGroupId === 'string' ? options.mediaGroupId : '';
    const safeName = normalizeUploadFileName(file);
    const isImage = file.type ? file.type.startsWith('image/') : isImageFileName(safeName);
    const messageType = isImage ? 'image' : 'file';
    const ttlSeconds = Number.isFinite(options.ttlSeconds) ? options.ttlSeconds : getSelectedTtlSeconds();
    const useSpoiler = isImage && (typeof options.spoiler === 'boolean'
        ? options.spoiler
        : parsedCaption.isSpoiler);
    const rawContent = caption || getAttachmentMessageContent(messageType, safeName, isImage);
    const optimisticContent = useSpoiler ? encodeSpoilerContent(rawContent) : rawContent;
    const showOptimistic = target.type === 'dm';
    const tempId = showOptimistic ? generateTempId() : '';
    const time = new Date().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
    let localUrl = '';
    if (showOptimistic && isImage) {
        try {
            localUrl = URL.createObjectURL(file);
        } catch (_) {
            localUrl = '';
        }
    }
    const optimisticMessage = showOptimistic ? {
        content: optimisticContent,
        sent: true,
        status: 'sent',
        temp_id: tempId,
        time,
        message_type: messageType,
        file_name: safeName,
        file_size: file.size,
        local_url: localUrl,
        transfer_state: TRANSFER_STATES.LOADING,
        transfer_progress: 0,
        ttl_seconds: ttlSeconds,
        media_group_id: mediaGroupId
    } : null;
    const optimisticEl = optimisticMessage ? addMessageToUI(optimisticMessage, true) : null;
    const transferRing = optimisticEl ? optimisticEl.querySelector('.file-transfer-ring') : null;
    if (transferRing) {
        setTransferRingState(transferRing, TRANSFER_STATES.LOADING, 0);
        startTransferSimulation(transferRing);
    }

    return new Promise((resolve) => {
        try {
            const reader = new FileReader();
            const readWeight = 20;
            reader.onprogress = (event) => {
                if (!transferRing || !event.lengthComputable) return;
                const readProgress = Math.max(0, Math.min(readWeight, Math.round((event.loaded / event.total) * readWeight)));
                setTransferRingProgress(transferRing, readProgress);
            };
            reader.onload = () => {
                const base64Data = reader.result.split(',')[1];
                const payload = JSON.stringify({
                    token,
                    file_data: base64Data,
                    file_name: safeName
                });

                const xhr = new XMLHttpRequest();
                xhr.open('POST', API_BASE + '/api/upload-file', true);
                xhr.setRequestHeader('Content-Type', 'application/json');

                xhr.upload.onprogress = (event) => {
                    if (!transferRing || !event.lengthComputable) return;
                    const uploadProgress = Math.min(100, Math.round(readWeight + (event.loaded / event.total) * (100 - readWeight)));
                    setTransferRingProgress(transferRing, uploadProgress);
                };

                xhr.onload = async () => {
                    uploadTransfers.delete(tempId);
                    let data = null;
                    try {
                        data = xhr.responseText ? JSON.parse(xhr.responseText) : null;
                    } catch (e) {
                        data = null;
                    }
                    const uploadOk = xhr.status >= 200 && xhr.status < 300 && data && data.success;
                    if (uploadOk) {
                        const sendOk = await sendFileMessageToTarget({
                            target,
                            filePath: data.file_path,
                            fileName: data.file_name,
                            fileSize: data.file_size,
                            messageType,
                            isImage,
                            ttlSeconds,
                            caption,
                            useSpoiler
                        });
                        if (sendOk) {
                            if (transferRing) {
                                setTransferRingState(transferRing, TRANSFER_STATES.DONE, 100);
                            }
                            if (localUrl && localUrl.startsWith('blob:')) {
                                URL.revokeObjectURL(localUrl);
                            }
                            resolve(true);
                            return;
                        }
                        if (transferRing) {
                            setTransferRingState(transferRing, TRANSFER_STATES.IDLE, 0);
                        }
                        if (optimisticEl) {
                            optimisticEl.remove();
                        }
                        if (localUrl && localUrl.startsWith('blob:')) {
                            URL.revokeObjectURL(localUrl);
                        }
                        resolve(false);
                        return;
                    }
                    if (transferRing) {
                        setTransferRingState(transferRing, TRANSFER_STATES.IDLE, 0);
                    }
                    if (optimisticEl) {
                        optimisticEl.remove();
                    }
                    if (localUrl && localUrl.startsWith('blob:')) {
                        URL.revokeObjectURL(localUrl);
                    }
                    notifications.error(data?.message || 'Ошибка загрузки файла');
                    resolve(false);
                };

                xhr.onerror = () => {
                    uploadTransfers.delete(tempId);
                    if (transferRing) {
                        setTransferRingState(transferRing, TRANSFER_STATES.IDLE, 0);
                    }
                    if (optimisticEl) {
                        optimisticEl.remove();
                    }
                    if (localUrl && localUrl.startsWith('blob:')) {
                        URL.revokeObjectURL(localUrl);
                    }
                    notifications.error('Ошибка загрузки файла');
                    resolve(false);
                };

                xhr.onabort = () => {
                    uploadTransfers.delete(tempId);
                    if (transferRing) {
                        setTransferRingState(transferRing, TRANSFER_STATES.IDLE, 0);
                    }
                    if (optimisticEl) {
                        optimisticEl.remove();
                    }
                    if (localUrl && localUrl.startsWith('blob:')) {
                        URL.revokeObjectURL(localUrl);
                    }
                    resolve(false);
                };

                if (transferRing && tempId) {
                    uploadTransfers.set(tempId, { xhr, ring: transferRing, messageEl: optimisticEl });
                }
                xhr.send(payload);
            };

            reader.onerror = () => {
                if (transferRing) {
                    setTransferRingState(transferRing, TRANSFER_STATES.IDLE, 0);
                }
                if (optimisticEl) {
                    optimisticEl.remove();
                }
                if (localUrl && localUrl.startsWith('blob:')) {
                    URL.revokeObjectURL(localUrl);
                }
                notifications.error('Ошибка чтения файла');
                resolve(false);
            };

            reader.readAsDataURL(file);
        } catch (error) {
            console.error('Error uploading file:', error);
            if (transferRing) {
                setTransferRingState(transferRing, TRANSFER_STATES.IDLE, 0);
            }
            if (optimisticEl) {
                optimisticEl.remove();
            }
            if (localUrl && localUrl.startsWith('blob:')) {
                URL.revokeObjectURL(localUrl);
            }
            notifications.error('Ошибка загрузки файла');
            resolve(false);
        }
    });
}

async function uploadVoiceMessage(audioBlob, mimeType = 'audio/webm') {
    if (!currentChat) {
        notifications.warning('Выберите чат для отправки голосового сообщения');
        return;
    }
    
    if (audioBlob.size === 0) {
        notifications.warning('Запись пуста');
        return;
    }
    
    const ttlSeconds = getSelectedTtlSeconds();
    try {
        // Читаем аудио как base64
        const reader = new FileReader();
        reader.onload = async () => {
            const base64Data = reader.result.split(',')[1];
            
            const token = localStorage.getItem('xipher_token');
            const response = await fetch(API_BASE + '/api/upload-voice', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    token: token,
                    voice_data: base64Data,
                    mime_type: mimeType
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Отправляем сообщение с голосовым файлом
                await sendMessageWithFile(data.file_path, data.file_name, data.file_size, 'voice', { ttlSeconds });
            } else {
                notifications.error(data.message || 'Ошибка загрузки голосового сообщения');
            }
        };
        
        reader.onerror = () => {
            notifications.error('Ошибка чтения аудио файла');
        };
        
        reader.readAsDataURL(audioBlob);
    } catch (error) {
        console.error('Error uploading voice:', error);
        notifications.error('Ошибка загрузки голосового сообщения');
    }
}

async function sendMessageWithFile(filePath, fileName, fileSize, messageType, options = {}) {
    stopTypingForCurrentTarget();
    const token = localStorage.getItem('xipher_token');
    const safeName = fileName || 'file';
    const isImage = options.isImage ?? isImageFileName(safeName);
    const useSpoiler = Boolean(options.spoiler) && isImage;
    const caption = typeof options.caption === 'string' ? options.caption.trim() : '';
    const ttlSeconds = Number.isFinite(options.ttlSeconds) ? options.ttlSeconds : getSelectedTtlSeconds();
    const resolvedType = messageType === 'file' && isImage ? 'image' : messageType;
    const baseContent = caption || getAttachmentMessageContent(resolvedType, safeName, isImage);
    let content = baseContent;
    if (useSpoiler) {
        content = encodeSpoilerContent(content);
    }
    
    // Для избранных сообщений receiver_id должен быть равен sender_id (currentUser.id)
    let receiverId = currentChat.id;
    if (currentChat.is_saved_messages) {
        if (!currentUser || !currentUser.id) {
            notifications.error('Ошибка: информация о пользователе не найдена');
            return;
        }
        receiverId = currentUser.id;
    }
    
    try {
        const response = await fetch(API_BASE + '/api/send-message', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                token: token,
                receiver_id: receiverId,
                content: content,
                message_type: resolvedType,
                file_path: filePath,
                file_name: safeName,
                file_size: fileSize,
                reply_to_message_id: replyToMessage ? replyToMessage.id : '',
                ...(ttlSeconds > 0 ? { ttl_seconds: ttlSeconds } : {})
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            replyToMessage = null;
            document.getElementById('replyPreview').style.display = 'none';
            loadChats();
            loadChatMessages(currentChat.id);
            return true;
        } else {
            notifications.error(data.message || 'Ошибка отправки сообщения');
            return false;
        }
    } catch (error) {
        console.error('Error sending message:', error);
        notifications.error('Ошибка отправки сообщения');
        return false;
    }
}

// Загружаем все: чаты, группы и каналы в один список
async function loadAllChats() {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        console.warn('No token found, cannot load chats');
        return;
    }

    console.log('Loading all chats...');

    try {
        // Загружаем все параллельно
        const [chatsData, groupsData, channelsData] = await Promise.all([
            loadChatsData(token),
            loadGroupsData(token),
            loadChannelsData(token)
        ]);

        console.log('Loaded data:', {
            chats: chatsData?.length || 0,
            groups: groupsData?.length || 0,
            channels: channelsData?.length || 0
        });

        // Объединяем все в один массив
        const allItems = [];
        
        // Добавляем чаты
        if (chatsData && chatsData.length > 0) {
            chatsData.forEach(chat => {
                allItems.push({
                    ...chat,
                    type: chat.is_saved_messages ? 'saved_messages' : 'chat',
                    icon: chat.is_saved_messages ? '⭐' : '💬',
                    // Убеждаемся, что избранные сообщения всегда видны
                    name: chat.is_saved_messages ? (chat.name || 'Избранные') : chat.name,
                    // Сохраняем флаг is_saved_messages
                    is_saved_messages: chat.is_saved_messages || false
                });
            });
        }
        
        // Добавляем избранные сообщения в начало списка, если они есть
        // Теперь добавляем всегда, чтобы чат "Избранные" был виден
        const hasSavedMessagesInList = allItems.some(item => item.is_saved_messages);
        if (!hasSavedMessagesInList && currentUser && currentUser.id) {
            allItems.push({
                id: currentUser.id, // ID избранных сообщений - это ID текущего пользователя
                name: 'Избранные сообщения',
                lastMessage: 'Нет сообщений', // По умолчанию
                time: '',
                unread: 0,
                online: false,
                avatar: '⭐',
                type: 'saved_messages',
                is_saved_messages: true,
                data: {
                    id: currentUser.id,
                    name: 'Избранные сообщения',
                    description: 'Ваши сохраненные сообщения',
                    is_saved_messages: true
                }
            });
        }
        
        // Добавляем группы
        if (groupsData && groupsData.length > 0) {
            groupsData.forEach(group => {
                allItems.push({
                    id: group.id,
                    name: group.name,
                    lastMessage: 'Группа',
                    time: '',
                    unread: 0,
                    online: false,
                    avatar: group.name.charAt(0).toUpperCase(),
                    type: 'group',
                    icon: '👥',
                    data: group
                });
            });
        }
        
        // Добавляем каналы
        if (channelsData && channelsData.length > 0) {
            channelsData.forEach(channel => {
                const channelSubtitle = channel.custom_link ? `@${channel.custom_link}` : 'Канал';
                allItems.push({
                    id: channel.id,
                    name: channel.name,
                    lastMessage: channelSubtitle,
                    time: '',
                    unread: 0,
                    online: false,
                    avatar: channel.is_private ? '🔒' : '📢',
                    avatar_url: channel.avatar_url || '',
                    type: 'channel',
                    icon: channel.is_private ? '🔒' : '📢',
                    data: channel
                });
            });
        }
        
        notifyOnChatListUpdate(allItems);

        // Сортируем по времени последнего сообщения (пока просто по порядку)
        chats = allItems;
        console.log('Total items to render:', chats.length);
        renderChats();
    } catch (error) {
        console.error('Error in loadAllChats:', error);
        notifications.error('Ошибка загрузки чатов');
    }
}

async function loadChatsData(token) {
    try {
        const response = await fetch(API_BASE + '/api/chats', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ token })
        });
        const data = await response.json();
        console.log('Loaded chats data:', data);
        if (data.success && data.chats) {
            console.log('Chats count:', data.chats.length);
            return data.chats;
        }
        console.log('No chats returned or error');
        return [];
    } catch (error) {
        console.error('Error loading chats:', error);
        return [];
    }
}

async function loadGroupsData(token) {
    try {
        const response = await fetch('/api/get-groups', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ token })
        });
        const data = await response.json();
        return data.success && data.groups ? data.groups : [];
    } catch (error) {
        console.error('Error loading groups:', error);
        return [];
    }
}

async function loadChannelsData(token) {
    try {
        const response = await fetch('/api/get-channels', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ token })
        });
        const data = await response.json();
        return data.success && data.channels ? data.channels : [];
    } catch (error) {
        console.error('Error loading channels:', error);
        return [];
    }
}

// Старая функция для обратной совместимости
async function loadChats() {
    await loadAllChats();
}

async function loadFriends() {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        return;
    }

    try {
        const response = await fetch(API_BASE + '/api/friends', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ token })
        });

        const data = await response.json();
        
        if (data.success && data.friends) {
            friends = data.friends;
            renderFriends();
        } else {
            friends = [];
            renderFriends();
        }
    } catch (error) {
        console.error('Error loading friends:', error);
        friends = [];
        renderFriends();
    }
}

function renderChats() {
    console.log('renderChats called, chats count:', chats.length);
    const chatsList = document.getElementById('chatsList');
    if (!chatsList) {
        console.error('chatsList element not found!');
        return;
    }

    const visibleChats = getChatsForActiveFolder();
    renderFolderRail();

    if (visibleChats.length === 0) {
        console.log('No chats to render, showing empty state');
        const emptyDiv = document.createElement('div');
        emptyDiv.style.cssText = 'padding: 2rem; text-align: center; color: var(--text-secondary);';
        const p1 = document.createElement('p');
        p1.textContent = activeFolderId === 'all' ? 'Нет чатов' : 'Папка пуста';
        const p2 = document.createElement('p');
        p2.style.cssText = 'font-size: 0.85rem; margin-top: 0.5rem;';
        p2.textContent = activeFolderId === 'all'
            ? 'Добавьте друзей, создайте группу или канал, чтобы начать общение'
            : 'Добавьте чаты в эту папку, чтобы они появились в списке';
        emptyDiv.appendChild(p1);
        emptyDiv.appendChild(p2);
        chatsList.replaceChildren(emptyDiv);
        return;
    }

    const displayChats = sortChatsForDisplay(visibleChats);
    console.log('Rendering', displayChats.length, 'chats');
    const fragment = document.createDocumentFragment();
    displayChats.forEach(chat => {
        const chatItem = createChatItem(chat);
        fragment.appendChild(chatItem);
    });
    chatsList.replaceChildren(fragment);
    applyActiveChatItem();
    restoreLastChatSelection();
    renderPersonalChannels();
    console.log('Chats rendered successfully');
}

function getActiveChatSelection() {
    const activeChannel = window.channelsModule?.currentChannel?.();
    if (activeChannel && activeChannel.id) {
        return { id: activeChannel.id, type: 'channel' };
    }
    const activeGroup = window.groupsModule?.currentGroup?.();
    if (activeGroup && activeGroup.id) {
        return { id: activeGroup.id, type: 'group' };
    }
    if (currentChat && currentChat.id) {
        const type = currentChat.is_saved_messages ? 'saved_messages' : (currentChat.type || 'chat');
        return { id: currentChat.id, type };
    }
    return null;
}

function applyActiveChatItem() {
    const active = getActiveChatSelection();
    if (!active) return;
    const selector = `.chat-item[data-chat-id="${active.id}"][data-chat-type="${active.type}"]`;
    const activeItem = document.querySelector(selector)
        || document.querySelector(`.chat-item[data-chat-id="${active.id}"]`);
    if (activeItem) {
        activeItem.classList.add('active');
    }
}

function persistActiveChatSelection(selection) {
    if (!selection || !selection.id) return;
    const payload = {
        id: selection.id,
        type: selection.type || 'chat'
    };
    try {
        localStorage.setItem(LAST_CHAT_KEY, JSON.stringify(payload));
    } catch (_) {}
}

function readLastChatSelection() {
    try {
        const raw = localStorage.getItem(LAST_CHAT_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || !parsed.id) return null;
        return parsed;
    } catch (_) {
        return null;
    }
}

function shouldRestoreSelection() {
    const path = window.location.pathname;
    if (path.startsWith('/join/')) return false;
    if (path.startsWith('/chat/')) return false;
    if (/^\/@[^\/]+$/.test(path)) return false;
    const params = new URLSearchParams(window.location.search);
    if (params.get('channel') || params.get('join')) return false;
    if (params.get('chat_id') || params.get('chatId') || params.get('chat')) return false;
    return true;
}

function restoreLastChatSelection() {
    if (hasRestoredSelection) return;
    if (!shouldRestoreSelection()) {
        hasRestoredSelection = true;
        return;
    }
    if (getActiveChatSelection()) {
        hasRestoredSelection = true;
        return;
    }
    const visibleChats = getChatsForActiveFolder();
    if (!visibleChats || visibleChats.length === 0) {
        return;
    }
    const stored = readLastChatSelection();
    if (!stored) {
        hasRestoredSelection = true;
        return;
    }
    const match = visibleChats.find(item => item.id == stored.id && (item.type || 'chat') === stored.type)
        || visibleChats.find(item => item.id == stored.id);
    if (!match) {
        try { localStorage.removeItem(LAST_CHAT_KEY); } catch (_) {}
        hasRestoredSelection = true;
        return;
    }
    hasRestoredSelection = true;
    if (stored.type === 'group') {
        if (match.data && window.groupsModule?.selectGroup) {
            window.groupsModule.selectGroup(match.data);
        }
        return;
    }
    if (stored.type === 'channel') {
        if (match.data && window.channelsModule?.selectChannel) {
            window.channelsModule.selectChannel(match.data);
        }
        return;
    }
    selectChat(match);
}

function normalizeChatType(chatType) {
    if (!chatType) return '';
    const type = chatType.toLowerCase();
    if (type === 'direct' || type === 'message') return 'chat';
    return type;
}

function getChatDeepLinkTarget() {
    const path = window.location.pathname;
    const match = path.match(/^\/chat\/([A-Za-z0-9_-]+)/);
    const params = new URLSearchParams(window.location.search);
    const chatId = match?.[1] || params.get('chat_id') || params.get('chatId') || params.get('chat') || '';
    if (!chatId) return null;
    const chatType = normalizeChatType(params.get('type') || params.get('chat_type') || params.get('chatType') || '');
    return { chatId, chatType };
}

async function openChatFromPush(chatId, chatType) {
    if (!chatId) return;
    const normalizedType = normalizeChatType(chatType);
    const baseSelector = `.chat-item[data-chat-id="${chatId}"]`;
    const typedSelector = normalizedType ? `${baseSelector}[data-chat-type="${normalizedType}"]` : baseSelector;
    let target = document.querySelector(typedSelector) || document.querySelector(baseSelector);
    if (!target && typeof loadChats === 'function') {
        await loadChats();
        target = document.querySelector(typedSelector) || document.querySelector(baseSelector);
    }
    if (target) {
        target.click();
    } else {
        console.warn('Chat not found for push open:', chatId, normalizedType);
    }
}

async function handleChatDeepLink() {
    const target = getChatDeepLinkTarget();
    if (!target) return;
    await openChatFromPush(target.chatId, target.chatType);
}

function setupPushMessageHandlers() {
    if (!('serviceWorker' in navigator)) return;
    navigator.serviceWorker.addEventListener('message', (event) => {
        const data = event?.data;
        if (!data || data.type !== 'open_chat') return;
        openChatFromPush(data.chatId, data.chatType);
    });
}

window.persistActiveChatSelection = persistActiveChatSelection;

function renderFriends() {
    const friendsList = document.getElementById('friendsList');
    if (!friendsList) return;

    if (friends.length === 0) {
        const empty = document.createElement('div');
        empty.style.cssText = 'padding: 2rem; text-align: center; color: var(--text-secondary);';
        const p1 = document.createElement('p');
        p1.textContent = 'Нет друзей';
        const p2 = document.createElement('p');
        p2.style.cssText = 'font-size: 0.85rem; margin-top: 0.5rem;';
        p2.textContent = 'Добавьте друзей, чтобы начать общение';
        empty.appendChild(p1);
        empty.appendChild(p2);
        friendsList.replaceChildren(empty);
        return;
    }

    const fragment = document.createDocumentFragment();
    friends.forEach(friend => {
        const friendItem = createFriendItem(friend);
        fragment.appendChild(friendItem);
    });
    friendsList.replaceChildren(fragment);
}

function setupFolderUI() {
    const editBtn = document.getElementById('folderEditBtn');
    if (editBtn) {
        editBtn.addEventListener('click', openFoldersModal);
    }

    const foldersModal = document.getElementById('foldersModal');
    if (foldersModal) {
        foldersModal.addEventListener('click', (event) => {
            if (event.target === foldersModal) {
                closeFoldersModal();
            }
        });
    }

    const closeFoldersBtn = document.getElementById('closeFoldersModal');
    if (closeFoldersBtn) {
        closeFoldersBtn.addEventListener('click', closeFoldersModal);
    }

    const createFolderBtn = document.getElementById('createFolderBtn');
    if (createFolderBtn) {
        createFolderBtn.addEventListener('click', () => {
            if (!canCreateFolder()) {
                handleFolderLimitReached();
                return;
            }
            closeFoldersModal();
            openFolderEditorModal();
        });
    }

    const folderEditorModal = document.getElementById('folderEditorModal');
    if (folderEditorModal) {
        folderEditorModal.addEventListener('click', (event) => {
            if (event.target === folderEditorModal) {
                closeFolderEditorModal();
            }
        });
    }

    const closeFolderEditorBtn = document.getElementById('closeFolderEditorModal');
    if (closeFolderEditorBtn) {
        closeFolderEditorBtn.addEventListener('click', closeFolderEditorModal);
    }

    const cancelFolderBtn = document.getElementById('cancelFolderBtn');
    if (cancelFolderBtn) {
        cancelFolderBtn.addEventListener('click', closeFolderEditorModal);
    }

    const saveFolderBtn = document.getElementById('saveFolderBtn');
    if (saveFolderBtn) {
        saveFolderBtn.addEventListener('click', submitFolderEditorModal);
    }

    const folderChatSearch = document.getElementById('folderChatSearch');
    if (folderChatSearch) {
        folderChatSearch.addEventListener('input', () => {
            renderFolderEditorChatList(folderChatSearch.value);
        });
    }

    const folderAssignModal = document.getElementById('folderAssignModal');
    if (folderAssignModal) {
        folderAssignModal.addEventListener('click', (event) => {
            if (event.target === folderAssignModal) {
                closeFolderAssignModal();
            }
        });
    }

    const closeAssignBtn = document.getElementById('closeFolderAssignModal');
    if (closeAssignBtn) {
        closeAssignBtn.addEventListener('click', closeFolderAssignModal);
    }

    const cancelAssignBtn = document.getElementById('cancelFolderAssignBtn');
    if (cancelAssignBtn) {
        cancelAssignBtn.addEventListener('click', closeFolderAssignModal);
    }

    const saveAssignBtn = document.getElementById('saveFolderAssignBtn');
    if (saveAssignBtn) {
        saveAssignBtn.addEventListener('click', submitFolderAssignModal);
    }

    const createAssignBtn = document.getElementById('createFolderFromAssignBtn');
    if (createAssignBtn) {
        createAssignBtn.addEventListener('click', () => {
            if (!canCreateFolder()) {
                handleFolderLimitReached();
                return;
            }
            const chatKey = pendingFolderAssignChat ? buildChatKey(pendingFolderAssignChat) : '';
            closeFolderAssignModal();
            openFolderEditorModal(null, { preselectKey: chatKey });
        });
    }

    const upgradeBtn = document.getElementById('folderUpgradeBtn');
    if (upgradeBtn) {
        upgradeBtn.addEventListener('click', () => {
            closeFoldersModal();
            openSettingsPanel('premium');
        });
    }

    renderFolderRail();
    updateFolderLimitUI();
}

function openFoldersModal() {
    const modal = document.getElementById('foldersModal');
    if (!modal) return;
    renderFoldersModal();
    modal.style.display = 'flex';
}

function closeFoldersModal() {
    const modal = document.getElementById('foldersModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

function renderFoldersModal() {
    const list = document.getElementById('folderList');
    if (!list) return;

    if (chatFolders.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'folder-empty';
        empty.textContent = 'Папок пока нет';
        list.replaceChildren(empty);
        updateFolderLimitUI();
        return;
    }

    const fragment = document.createDocumentFragment();
    const { keys } = buildVisibleChatKeySet();
    chatFolders.forEach(folder => {
        const row = document.createElement('div');
        row.className = 'folder-list-item';

        const meta = document.createElement('div');
        meta.className = 'folder-list-meta';

        const name = document.createElement('div');
        name.className = 'folder-list-name';
        name.textContent = folder.name;

        const count = document.createElement('div');
        count.className = 'folder-list-count';
        const total = countFolderChats(folder, keys);
        count.textContent = total === 1 ? '1 чат' : `${total} чатов`;

        meta.appendChild(name);
        meta.appendChild(count);

        const actions = document.createElement('div');
        actions.className = 'folder-list-actions';

        const editBtn = document.createElement('button');
        editBtn.className = 'folder-action-btn';
        editBtn.innerHTML = typeof appIcon === 'function' ? appIcon('edit') : '✏️';
        editBtn.title = 'Редактировать';
        editBtn.addEventListener('click', () => {
            closeFoldersModal();
            openFolderEditorModal(folder.id);
        });

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'folder-action-btn danger';
        deleteBtn.innerHTML = typeof appIcon === 'function' ? appIcon('delete') : '🗑️';
        deleteBtn.title = 'Удалить';
        deleteBtn.addEventListener('click', () => {
            const confirmed = confirm(`Удалить папку «${folder.name}»?`);
            if (confirmed) {
                deleteFolder(folder.id);
            }
        });

        actions.appendChild(editBtn);
        actions.appendChild(deleteBtn);

        row.appendChild(meta);
        row.appendChild(actions);
        fragment.appendChild(row);
    });
    list.replaceChildren(fragment);

    updateFolderLimitUI();
}

function deleteFolder(folderId) {
    if (!folderId) return;
    chatFolders = chatFolders.filter(folder => folder.id !== folderId);
    if (activeFolderId === folderId) {
        setActiveFolder('all', { render: false });
    }
    persistChatFolders({ sync: true, render: true });
    renderFoldersModal();
    updatePremiumUI();
}

function openFolderEditorModal(folderId = null, { preselectKey = '' } = {}) {
    const modal = document.getElementById('folderEditorModal');
    if (!modal) return;

    if (!folderId && !canCreateFolder()) {
        handleFolderLimitReached();
        return;
    }
    closeFoldersModal();
    editingFolderId = folderId;
    const folder = folderId ? getFolderById(folderId) : null;
    folderEditorSelection = new Set(folder?.chatKeys || []);
    if (preselectKey) {
        folderEditorSelection.add(preselectKey);
    }

    const title = document.getElementById('folderEditorTitle');
    if (title) {
        title.textContent = folder ? 'Редактировать папку' : 'Новая папка';
    }

    const nameInput = document.getElementById('folderNameInput');
    if (nameInput) {
        nameInput.value = folder?.name || '';
        nameInput.focus();
    }

    const searchInput = document.getElementById('folderChatSearch');
    if (searchInput) {
        searchInput.value = '';
    }

    renderFolderEditorChatList('');
    modal.style.display = 'flex';
}

function closeFolderEditorModal() {
    const modal = document.getElementById('folderEditorModal');
    if (modal) {
        modal.style.display = 'none';
    }
    editingFolderId = null;
    folderEditorSelection = new Set();
}

function renderFolderEditorChatList(filterValue) {
    const list = document.getElementById('folderChatList');
    if (!list) return;

    const normalized = (filterValue || '').trim().toLowerCase();
    const visibleChats = getVisibleChats();
    const filtered = normalized
        ? visibleChats.filter(chat => getChatSearchText(chat).includes(normalized))
        : visibleChats;

    if (filtered.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'folder-empty';
        empty.textContent = normalized ? 'Чаты не найдены' : 'Пока нет чатов';
        list.replaceChildren(empty);
        return;
    }

    const fragment = document.createDocumentFragment();
    filtered.forEach(chat => {
        const key = buildChatKey(chat);
        if (!key) return;

        const item = document.createElement('label');
        item.className = 'folder-chat-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = folderEditorSelection.has(key);
        checkbox.dataset.chatKey = key;
        checkbox.addEventListener('change', () => {
            if (checkbox.checked) {
                folderEditorSelection.add(key);
            } else {
                folderEditorSelection.delete(key);
            }
        });

        const avatar = document.createElement('div');
        avatar.className = 'folder-chat-avatar';
        const fallback = (chat.icon || chat.avatar || getDisplayInitial(chat)).toString().charAt(0).toUpperCase();
        if (chat.avatar_url) {
            const img = document.createElement('img');
            img.src = chat.avatar_url;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            img.style.borderRadius = '50%';
            img.onerror = () => {
                avatar.textContent = fallback;
            };
            avatar.appendChild(img);
        } else {
            avatar.textContent = fallback;
        }

        const meta = document.createElement('div');
        meta.className = 'folder-chat-meta';

        const name = document.createElement('div');
        name.className = 'folder-chat-name';
        name.textContent = getChatDisplayName(chat);

        const type = document.createElement('div');
        type.className = 'folder-chat-type';
        if (chat.is_saved_messages) {
            type.textContent = 'Избранное';
        } else if (chat.type === 'group') {
            type.textContent = 'Группа';
        } else if (chat.type === 'channel') {
            type.textContent = 'Канал';
        } else {
            type.textContent = 'Личный чат';
        }

        meta.appendChild(name);
        meta.appendChild(type);

        item.appendChild(checkbox);
        item.appendChild(avatar);
        item.appendChild(meta);
        fragment.appendChild(item);
    });
    list.replaceChildren(fragment);
}

function submitFolderEditorModal() {
    const nameInput = document.getElementById('folderNameInput');
    const name = nameInput ? nameInput.value.trim() : '';

    if (!name) {
        notifications.error('Введите название папки');
        return;
    }

    if (!editingFolderId && !canCreateFolder()) {
        handleFolderLimitReached();
        return;
    }

    const chatKeys = Array.from(folderEditorSelection);

    if (editingFolderId) {
        const folder = getFolderById(editingFolderId);
        if (!folder) return;
        folder.name = name;
        folder.chatKeys = chatKeys;
    } else {
        const id = createFolderId();
        chatFolders.push({
            id,
            name,
            chatKeys
        });
        setActiveFolder(id, { render: false });
    }

    persistChatFolders({ sync: true, render: true });
    renderFoldersModal();
    closeFolderEditorModal();
    updatePremiumUI();
}

function openFolderAssignModal(chat) {
    const modal = document.getElementById('folderAssignModal');
    if (!modal || !chat) return;
    const chatKey = buildChatKey(chat);
    if (!chatKey) return;

    pendingFolderAssignChat = chat;
    folderAssignSelection = new Set();
    chatFolders.forEach(folder => {
        if (Array.isArray(folder.chatKeys) && folder.chatKeys.includes(chatKey)) {
            folderAssignSelection.add(folder.id);
        }
    });

    const title = document.getElementById('folderAssignTitle');
    if (title) {
        const displayName = getChatDisplayName(chat);
        title.textContent = `Папки для «${displayName}»`;
    }

    renderFolderAssignList();
    updateFolderLimitUI();
    modal.style.display = 'flex';
}

function renderFolderAssignList() {
    const list = document.getElementById('folderAssignList');
    if (!list) return;

    if (chatFolders.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'folder-empty';
        empty.textContent = 'Создайте папку, чтобы сгруппировать чаты.';
        list.replaceChildren(empty);
        return;
    }

    const fragment = document.createDocumentFragment();
    const { keys } = buildVisibleChatKeySet();
    chatFolders.forEach(folder => {
        const item = document.createElement('label');
        item.className = 'folder-assign-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = folderAssignSelection.has(folder.id);
        checkbox.addEventListener('change', () => {
            if (checkbox.checked) {
                folderAssignSelection.add(folder.id);
            } else {
                folderAssignSelection.delete(folder.id);
            }
        });

        const meta = document.createElement('div');
        meta.className = 'folder-list-meta';

        const name = document.createElement('div');
        name.className = 'folder-list-name';
        name.textContent = folder.name;

        const count = document.createElement('div');
        count.className = 'folder-list-count';
        const total = countFolderChats(folder, keys);
        count.textContent = total === 1 ? '1 чат' : `${total} чатов`;

        meta.appendChild(name);
        meta.appendChild(count);

        item.appendChild(checkbox);
        item.appendChild(meta);
        fragment.appendChild(item);
    });
    list.replaceChildren(fragment);
}

function closeFolderAssignModal() {
    const modal = document.getElementById('folderAssignModal');
    if (modal) {
        modal.style.display = 'none';
    }
    pendingFolderAssignChat = null;
    folderAssignSelection = new Set();
}

function submitFolderAssignModal() {
    if (!pendingFolderAssignChat) {
        closeFolderAssignModal();
        return;
    }

    const chatKey = buildChatKey(pendingFolderAssignChat);
    if (!chatKey) {
        closeFolderAssignModal();
        return;
    }

    chatFolders = chatFolders.map(folder => {
        const keys = new Set(Array.isArray(folder.chatKeys) ? folder.chatKeys.map(String) : []);
        if (folderAssignSelection.has(folder.id)) {
            keys.add(chatKey);
        } else {
            keys.delete(chatKey);
        }
        return {
            ...folder,
            chatKeys: Array.from(keys)
        };
    });

    persistChatFolders({ sync: true, render: true });
    renderFoldersModal();
    closeFolderAssignModal();
}

function createChatItem(chat) {
    const item = document.createElement('div');
    item.className = 'chat-item';
    item.dataset.chatId = chat.id;
    item.dataset.chatType = chat.type || 'chat';
    const displayName = getChatDisplayName(chat);

    const avatar = document.createElement('div');
    avatar.className = 'chat-avatar';
    // Используем картинку, если есть avatar_url, иначе иконку/букву
    const chatFallbackAvatar = chat.icon || chat.avatar || getDisplayInitial(chat);
    if (chat.avatar_url) {
        const img = document.createElement('img');
        img.src = chat.avatar_url;
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        img.style.borderRadius = '50%';
        img.onerror = () => {
            avatar.textContent = chatFallbackAvatar;
        };
        avatar.appendChild(img);
    } else {
        avatar.textContent = chatFallbackAvatar;
    }

    const info = document.createElement('div');
    info.className = 'chat-info';

    const headerRow = document.createElement('div');
    headerRow.className = 'chat-header-row';

    const name = document.createElement('div');
    name.className = 'chat-name';
    const nameText = document.createElement('span');
    nameText.className = 'chat-name-text';
    nameText.textContent = displayName;
    name.appendChild(nameText);
    if ((chat.type === 'chat' || !chat.type) && chat.is_premium) {
        name.appendChild(createPremiumBadge());
    }

    const time = document.createElement('div');
    time.className = 'chat-time';
    time.textContent = chat.time || '';

    const meta = document.createElement('div');
    meta.className = 'chat-meta';

    if (isChatPinned(chat)) {
        const pin = document.createElement('span');
        pin.className = 'chat-pin-indicator';
        pin.innerHTML = typeof appIcon === 'function' ? appIcon('bookmark') : '📌';
        meta.appendChild(pin);
        item.classList.add('is-pinned');
    }

    if (isChatMuted(chat)) {
        const mute = document.createElement('span');
        mute.className = 'chat-mute-indicator';
        mute.innerHTML = typeof appIcon === 'function' ? appIcon('notificationOff') : '🔕';
        meta.appendChild(mute);
    }

    meta.appendChild(time);

    headerRow.appendChild(name);
    headerRow.appendChild(meta);

    const preview = document.createElement('div');
    preview.className = 'chat-preview';

    const previewText = document.createElement('span');
    previewText.className = 'chat-preview-text';
    const rawPreview = chat.lastMessage || 'Нет сообщений';
    previewText.textContent = formatMessagePreviewText(rawPreview) || 'Нет сообщений';
    if (chat.type === 'channel' && chat.data?.custom_link) {
        previewText.textContent = `@${chat.data.custom_link}`;
    }

    preview.appendChild(previewText);

    if (chat.unread > 0) {
        const unread = document.createElement('span');
        unread.className = 'chat-unread';
        unread.textContent = chat.unread;
        preview.appendChild(unread);
    }

    // Показываем статус онлайн только для обычных чатов (не групп/каналов)
    if ((chat.type === 'chat' || !chat.type) && chat.online) {
        const status = document.createElement('div');
        status.className = 'chat-status';
        preview.appendChild(status);
    }

    info.appendChild(headerRow);
    info.appendChild(preview);

    item.appendChild(avatar);
    item.appendChild(info);

    // Обработчик клика
    item.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        console.log('Chat item clicked:', chat);
        
        if (chat.type === 'group' && window.groupsModule) {
            window.groupsModule.selectGroup(chat.data);
        } else if (chat.type === 'channel') {
            console.log('Clicking on channel:', chat);
            
            // Убеждаемся, что channelsModule доступен и инициализирован
            if (!window.channelsModule) {
                console.error('channelsModule not found');
                notifications.error('Модуль каналов не загружен. Попробуйте обновить страницу.');
                return;
            }
            
            // Если модуль еще не инициализирован, ждем
            if (window.channelsModule._pending || !window.channelsModule._initialized) {
                console.warn('channelsModule pending initialization, waiting...');
                let attempts = 0;
                while ((window.channelsModule._pending || !window.channelsModule._initialized) && attempts < 50) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                    attempts++;
                }
                if (window.channelsModule._pending || !window.channelsModule._initialized) {
                    console.error('channelsModule initialization timeout');
                    notifications.error('Модуль каналов не загружен. Попробуйте обновить страницу.');
                    return;
                }
            }
            
            if (!window.channelsModule.selectChannel || typeof window.channelsModule.selectChannel !== 'function') {
                console.error('channelsModule.selectChannel not available');
                notifications.error('Модуль каналов не загружен. Попробуйте обновить страницу.');
                return;
            }
            
            // Используем данные канала из chat.data или загружаем по ID
            if (chat.data && chat.data.id) {
                console.log('Using channel data from chat:', chat.data);
                await window.channelsModule.selectChannel(chat.data);
            } else {
                // Если data нет, загружаем канал по ID
                console.log('Loading channel by ID:', chat.id);
                const token = localStorage.getItem('xipher_token');
                if (!token) {
                    notifications.error('Необходима авторизация');
                    return;
                }
                
                try {
                    const response = await fetch('/api/get-channels', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token })
                    });
                    const data = await response.json();
                    if (data.success && data.channels) {
                        const channel = data.channels.find(c => c.id === chat.id);
                        if (channel) {
                            console.log('Found channel:', channel);
                            await window.channelsModule.selectChannel(channel);
                        } else {
                            console.error('Channel not found in list:', chat.id);
                            notifications.error('Канал не найден');
                        }
                    } else {
                        console.error('Failed to load channels:', data);
                        notifications.error('Ошибка загрузки каналов');
                    }
                } catch (error) {
                    console.error('Error loading channel:', error);
                    notifications.error('Ошибка загрузки канала');
                }
            }
        } else {
            selectChat(chat);
        }
    });

    item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        ChatContextMenuManager.getInstance().open(e, chat, item);
    });

    return item;
}

function createFriendItem(friend) {
    const item = document.createElement('div');
    item.className = 'friend-item';
    item.dataset.friendId = friend.id;
    const displayName = getFriendDisplayName(friend);

    const avatar = document.createElement('div');
    avatar.className = 'friend-avatar';
    const friendFallbackAvatar = getDisplayInitial(friend);
    if (friend.avatar_url) {
        const img = document.createElement('img');
        img.src = friend.avatar_url;
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        img.style.borderRadius = '50%';
        img.onerror = () => {
            avatar.textContent = friendFallbackAvatar;
        };
        avatar.appendChild(img);
    } else {
        avatar.textContent = friendFallbackAvatar;
    }

    const info = document.createElement('div');
    info.className = 'friend-info';

    const name = document.createElement('div');
    name.className = 'friend-name';
    const nameText = document.createElement('span');
    nameText.className = 'chat-name-text';
    nameText.textContent = displayName;
    name.appendChild(nameText);
    if (friend.is_premium) {
        name.appendChild(createPremiumBadge());
    }

    const status = document.createElement('div');
    
    // Для ботов не показываем статус онлайн/оффлайн, а показываем "Бот"
    if (friend.is_bot) {
        status.className = 'friend-status bot';
        status.textContent = 'Бот';
        status.style.color = 'var(--purple-primary)';
    } else {
        status.className = friend.online ? 'friend-status online' : 'friend-status offline';
        if (friend.online) {
            status.textContent = 'Онлайн';
        } else if (friend.last_activity) {
            status.textContent = formatTimeAgo(friend.last_activity);
        } else {
            status.textContent = 'Не в сети';
        }
    }

    info.appendChild(name);
    info.appendChild(status);

    item.appendChild(avatar);
    item.appendChild(info);

    // Обработчик клика - открываем чат с другом
    item.addEventListener('click', () => {
        // Находим или создаем чат с этим другом
        let chat = chats.find(c => c.id === friend.id);
        if (!chat) {
            chat = {
                id: friend.id,
                name: friend.username,
                display_name: friend.display_name,
                avatar: getDisplayInitial(friend),
                avatar_url: friend.avatar_url || '',
                lastMessage: '',
                time: '',
                unread: 0,
                online: friend.online || false,
                last_activity: friend.last_activity || null,
                is_bot: friend.is_bot || false,  // Сохраняем информацию о том, что это бот
                is_premium: friend.is_premium || false
            };
        }
        selectChat(chat);
        // Переключаемся на вкладку чатов
        document.querySelector('[data-tab="chats"]').click();
    });

    return item;
}

function selectChat(chat) {
    // If we are switching from a channel/group to a DM, clear other selections to avoid misrouting sendMessage()
    if (window.channelsModule && typeof window.channelsModule.resetCurrentChannel === 'function') {
        window.channelsModule.resetCurrentChannel();
    }
    if (window.groupsModule && typeof window.groupsModule.resetCurrentGroup === 'function') {
        window.groupsModule.resetCurrentGroup();
    }

    clearReplyState();
    clearPendingAttachments();
    stopTypingForCurrentTarget();
    resetReplyKeyboardState();

    // Убираем активный класс со всех чатов
    document.querySelectorAll('.chat-item').forEach(item => {
        item.classList.remove('active');
    });

    // Добавляем активный класс выбранному чату
    const chatItem = document.querySelector(`[data-chat-id="${chat.id}"]`);
    if (chatItem) {
        chatItem.classList.add('active');
    }

    currentChat = chat;
    persistActiveChatSelection({
        id: chat.id,
        type: chat.is_saved_messages ? 'saved_messages' : (chat.type || 'chat')
    });
    const displayName = getChatDisplayName(chat);

    // Обновляем заголовок чата
    const headerName = document.getElementById('chatHeaderName');
    if (headerName) {
        headerName.textContent = '';
        const nameText = document.createElement('span');
        nameText.className = 'chat-name-text';
        nameText.textContent = displayName;
        headerName.appendChild(nameText);
        if ((chat.type === 'chat' || !chat.type) && chat.is_premium) {
            headerName.appendChild(createPremiumBadge('large'));
        }
    }
    const chatHeaderAvatar = document.getElementById('chatHeaderAvatar');
    if (chatHeaderAvatar) {
        const headerFallback = chat.avatar || getDisplayInitial(chat);
        if (chat.avatar_url) {
            const img = document.createElement('img');
            img.src = chat.avatar_url;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            img.style.borderRadius = '50%';
            img.onerror = () => {
                chatHeaderAvatar.textContent = headerFallback;
            };
            chatHeaderAvatar.innerHTML = '';
            chatHeaderAvatar.appendChild(img);
        } else {
            chatHeaderAvatar.textContent = headerFallback;
        }
    }
    
    // Обновляем статус в заголовке
    let statusText = '';
    let statusColor = '';
    if (chat.is_saved_messages) {
        statusText = 'Ваши сохранённые сообщения';
    } else if (chat.type === 'group' || chat.type === 'channel') {
        statusText = chat.type === 'group' ? 'Группа' : 'Канал';
    } else if (chat.is_bot) {
        // Для ботов показываем "Бот" вместо статуса онлайн/оффлайн
        statusText = 'Бот';
        statusColor = 'var(--purple-primary)';
    } else if (chat.online) {
        statusText = 'Онлайн';
    } else if (chat.last_activity) {
        statusText = formatTimeAgo(chat.last_activity);
    } else {
        statusText = 'Не в сети';
    }
    setChatHeaderStatusBase(statusText, statusColor);
    clearTypingIndicator();
    document.getElementById('chatHeader').style.display = 'flex';
    document.getElementById('chatInputArea').style.display = 'block';
    
    // Скрываем кнопку звонка для избранных сообщений и ботов
    const callBtn = document.getElementById('callBtn');
    const searchBtn = document.getElementById('searchChannelBtn');
    const menuBtn = document.getElementById('channelMenuBtn');
    if (chat.is_saved_messages || chat.is_bot) {
        if (callBtn) callBtn.style.display = 'none';
    } else {
        if (callBtn) callBtn.style.display = 'flex';
    }
    if (searchBtn) searchBtn.style.display = 'none';
    if (menuBtn) menuBtn.style.display = 'none';
    
    // Удаляем кнопку подписки из обычных чатов (если она там есть)
    const subscribeBtn = document.getElementById('channelSubscribeBtn');
    if (subscribeBtn) {
        subscribeBtn.remove();
    }
    const leaveBtn = document.getElementById('leaveGroupBtn');
    if (leaveBtn) leaveBtn.style.display = 'none';

    // Очищаем сообщения
    const messagesContainer = document.getElementById('chatMessages');
    messagesContainer.innerHTML = '';

    // Загружаем сообщения чата
    loadChatMessages(chat.id);

    updatePremiumGiftAvailability();
    closePremiumGiftModal();

    // Сбрасываем непрочитанные
    if (chat.unread > 0) {
        chat.unread = 0;
        loadChats(); // Перезагружаем список
    }
}

function resetActiveChatSelection() {
    clearReplyState();
    stopTypingForCurrentTarget();
    clearTypingIndicator();
    resetReplyKeyboardState();
    if (window.channelsModule && typeof window.channelsModule.resetCurrentChannel === 'function') {
        window.channelsModule.resetCurrentChannel();
    }
    if (window.groupsModule && typeof window.groupsModule.resetCurrentGroup === 'function') {
        window.groupsModule.resetCurrentGroup();
    }
    currentChat = null;
    try {
        localStorage.removeItem(LAST_CHAT_KEY);
    } catch (_) {}

    document.querySelectorAll('.chat-item').forEach(item => {
        item.classList.remove('active');
    });

    const chatHeader = document.getElementById('chatHeader');
    const chatInputArea = document.getElementById('chatInputArea');
    if (chatHeader) chatHeader.style.display = 'none';
    if (chatInputArea) chatInputArea.style.display = 'none';

    const messagesContainer = document.getElementById('chatMessages');
    if (messagesContainer) {
        messagesContainer.innerHTML = '';
        const emptyChat = document.createElement('div');
        emptyChat.className = 'empty-chat';
        const icon = document.createElement('div');
        icon.className = 'empty-chat-icon';
        icon.innerHTML = typeof appIcon === 'function' ? appIcon('chat', 'app-icon-xl') : '💬';
        const title = document.createElement('h3');
        title.textContent = t('chat.emptyTitle');
        const subtitle = document.createElement('p');
        subtitle.textContent = t('chat.emptySubtitle');
        emptyChat.appendChild(icon);
        emptyChat.appendChild(title);
        emptyChat.appendChild(subtitle);
        messagesContainer.appendChild(emptyChat);
    }

    updatePremiumGiftAvailability();
    closePremiumGiftModal();
}

async function loadChatMessages(chatId) {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        return;
    }

    resetChecklistState();
    resetReplyKeyboardState();

    // Сброс превью закрепа перед загрузкой
    setPinnedPreview(null);

    try {
        const response = await fetch(API_BASE + '/api/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ token, friend_id: chatId })
        });

        const data = await response.json();
        
        if (data.success && data.messages) {
            // Очищаем контейнер сообщений перед загрузкой
            const messagesContainer = document.getElementById('chatMessages');
            if (messagesContainer) {
                messagesContainer.innerHTML = '';
            }
            
            // Сервер возвращает сообщения от новых к старым (DESC), нужно перевернуть,
            // чтобы старые были вверху, а новые внизу
            const messages = Array.isArray(data.messages) ? data.messages : [];
            
            // Переворачиваем массив, чтобы старые сообщения были первыми (вверху)
            const sortedMessages = [...messages].reverse();
            
            // Добавляем сообщения последовательно - старые сначала, новые потом
            sortedMessages.forEach(msg => {
                addMessageToUI(msg, false); // Не прокручиваем при загрузке всех сообщений
            });

            // Показываем актуальный закреп
            const pinnedMsg = sortedMessages.find((m) => m.is_pinned);
            if (pinnedMsg) {
                setPinnedPreview(pinnedMsg.id || pinnedMsg.message_id, formatMessagePreviewText(pinnedMsg) || '[медиа]');
            } else {
                setPinnedPreview(null);
            }
            
            // Прокручиваем вниз к последнему сообщению после загрузки
            if (messagesContainer) {
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    });
                });
            }
        }
    } catch (error) {
        console.error('Error loading messages:', error);
        notifications.error('Ошибка загрузки сообщений');
    }
}

function generateTempId() {
    if (window.crypto && typeof window.crypto.randomUUID === 'function') {
        return window.crypto.randomUUID();
    }
    return `temp-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function generateChecklistId() {
    if (window.crypto && typeof window.crypto.randomUUID === 'function') {
        return window.crypto.randomUUID();
    }
    return `checklist-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function generateChecklistItemId() {
    if (window.crypto && typeof window.crypto.randomUUID === 'function') {
        return window.crypto.randomUUID();
    }
    return `item-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function formatServerTimeToLocal(timeString) {
    try {
        if (!timeString) return new Date().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
        const date = new Date(timeString);
        if (isNaN(date.getTime())) {
            return new Date().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
        }
        return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
    } catch {
        return new Date().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
    }
}

const LIVE_LOCATION_UPDATE_INTERVAL = 10000;
const LIVE_LOCATION_MIN_SEND_INTERVAL = 8000;
const LIVE_LOCATION_COUNTDOWN_INTERVAL = 15000;

const liveLocationState = {
    active: false,
    liveId: null,
    expiresAt: 0,
    watchId: null,
    sendTimerId: null,
    countdownTimerId: null,
    lastCoords: null,
    lastSentAt: 0,
    target: null,
    hasSentInitial: false,
    startedNotified: false
};

function resolveMessageTarget() {
    const activeGroup = window.groupsModule && typeof window.groupsModule.currentGroup === 'function'
        ? window.groupsModule.currentGroup()
        : (window.currentGroup || null);
    if (window.groupsModule && (window.groupsModule.isGroupActive?.() || activeGroup)) {
        if (activeGroup && activeGroup.id) {
            return {
                type: 'group',
                id: activeGroup.id,
                label: activeGroup.name || 'Группа'
            };
        }
    }

    if (window.channelsModule && window.channelsModule.isChannelActive?.()) {
        const channel = window.channelsModule.currentChannel?.();
        if (channel && channel.id) {
            return {
                type: 'channel',
                id: channel.id,
                label: channel.name || 'Канал'
            };
        }
    }

    if (!currentChat) return null;
    let receiverId = currentChat.id;
    if (currentChat.is_saved_messages) {
        if (!currentUser || !currentUser.id) {
            return null;
        }
        receiverId = currentUser.id;
    }
    return {
        type: 'dm',
        id: receiverId,
        label: getChatDisplayName(currentChat) || currentChat.username || currentChat.id || ''
    };
}

async function postMessageToTarget({ target, content, messageType = 'text', silent = false, ttlSeconds = 0 }) {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        if (!silent) {
            notifications.error('Необходима авторизация');
            window.location.href = '/login';
        }
        return false;
    }

    const resolvedTarget = target || resolveMessageTarget();
    if (!resolvedTarget) {
        if (!silent) {
            notifications.warning('Выберите чат для отправки сообщения');
        }
        return false;
    }

    let endpoint = API_BASE + '/api/send-message';
    const body = {
        token,
        content,
        message_type: messageType
    };

    if (resolvedTarget.type === 'dm') {
        body.receiver_id = resolvedTarget.id;
    } else if (resolvedTarget.type === 'group') {
        endpoint = '/api/send-group-message';
        body.group_id = resolvedTarget.id;
    } else if (resolvedTarget.type === 'channel') {
        endpoint = '/api/send-channel-message';
        body.channel_id = resolvedTarget.id;
    }
    const resolvedTtl = Number.isFinite(ttlSeconds) ? ttlSeconds : 0;
    if (resolvedTtl > 0) {
        body.ttl_seconds = resolvedTtl;
    }

    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });
        const data = await response.json();
        if (!data.success) {
            if (data.message && data.message.includes('Invalid token')) {
                await window.xipherSession?.logout();
                notifications.error('Сессия истекла. Необходима повторная авторизация');
                setTimeout(() => {
                    window.location.href = '/login';
                }, 2000);
            } else if (!silent) {
                notifications.error(data.message || 'Ошибка отправки сообщения');
            }
            return false;
        }
        return true;
    } catch (error) {
        console.error('Error sending message:', error);
        if (!silent) {
            notifications.error('Ошибка отправки сообщения');
        }
        return false;
    }
}

async function sendChecklistUpdatePayload(payload) {
    if (!payload || !payload.checklistId) return false;
    const target = resolveMessageTarget();
    if (!target) return false;
    const content = `${CHECKLIST_UPDATE_PREFIX}${JSON.stringify(payload)}`;
    return postMessageToTarget({ target, content, messageType: 'text', silent: true });
}

async function sendChecklistPayload(payload) {
    if (!payload || !payload.id) return false;
    const target = resolveMessageTarget();
    if (!target) {
        notifications.warning('Выберите чат для отправки сообщения');
        return false;
    }
    const content = `${CHECKLIST_PREFIX}${JSON.stringify(payload)}`;
    const ttlSeconds = getSelectedTtlSeconds();
    const clearReply = () => {
        replyToMessage = null;
        const replyPreview = document.getElementById('replyPreview');
        if (replyPreview) replyPreview.style.display = 'none';
    };

    if (target.type === 'group' && window.groupsModule?.sendGroupMessage) {
        await window.groupsModule.sendGroupMessage(content, 'text', '', '', 0, ttlSeconds);
        clearReply();
        return true;
    }
    if (target.type === 'channel' && window.channelsModule?.sendChannelMessage) {
        await window.channelsModule.sendChannelMessage(content, 'text', '', '', 0, ttlSeconds);
        clearReply();
        return true;
    }
    if (target.type !== 'dm') {
        const ok = await postMessageToTarget({ target, content, messageType: 'text', ttlSeconds });
        if (ok) {
            clearReply();
        }
        return ok;
    }

    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications.error('Необходима авторизация');
        window.location.href = '/login';
        return false;
    }
    if (!currentChat) {
        notifications.warning('Выберите чат для отправки сообщения');
        return false;
    }

    let receiverId = currentChat.id;
    if (currentChat.is_saved_messages) {
        if (!currentUser || !currentUser.id) {
            notifications.error('Ошибка: информация о пользователе не найдена');
            return false;
        }
        receiverId = currentUser.id;
    }

    const tempId = generateTempId();
    const time = new Date().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
    const optimisticMessage = {
        content,
        sent: true,
        status: 'sent',
        temp_id: tempId,
        time,
        message_type: 'text',
        reply_to_message_id: replyToMessage ? replyToMessage.id : '',
        ttl_seconds: ttlSeconds
    };
    addMessageToUI(optimisticMessage, true);

    try {
        const requestBody = {
            token,
            receiver_id: receiverId,
            content,
            message_type: 'text',
            reply_to_message_id: replyToMessage ? replyToMessage.id : '',
            temp_id: tempId
        };
        if (ttlSeconds > 0) {
            requestBody.ttl_seconds = ttlSeconds;
        }
        const response = await fetch(API_BASE + '/api/send-message', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        const data = await response.json();

        if (!data.success) {
            if (data.message && data.message.includes('Invalid token')) {
                await window.xipherSession?.logout();
                notifications.error('Сессия истекла. Необходима повторная авторизация');
                setTimeout(() => {
                    window.location.href = '/login';
                }, 2000);
            } else {
                notifications.error(data.message || 'Ошибка отправки сообщения. Попробуйте еще раз.');
            }
            return false;
        }

        reconcileTempMessage(tempId, {
            id: data.message_id,
            temp_id: data.temp_id || tempId,
            time: formatServerTimeToLocal(data.created_at),
            ttl_seconds: ttlSeconds
        });

        replyToMessage = null;
        document.getElementById('replyPreview').style.display = 'none';
        await loadChats();
        if (currentChat && currentChat.id) {
            setTimeout(() => {
                checkNewMessages(currentChat.id);
            }, 500);
        }
        return true;
    } catch (error) {
        console.error('Error sending checklist:', error);
        notifications.error('Ошибка отправки сообщения');
        return false;
    }
}

function buildLocationUrl(lat, lon, liveId, expiresAt) {
    const base = `https://yandex.ru/maps/?pt=${lon.toFixed(6)},${lat.toFixed(6)}&z=16&l=map`;
    if (!liveId) return base;
    return `${base}#xipher_live=1&xipher_id=${encodeURIComponent(liveId)}&xipher_expires=${expiresAt}`;
}

function showLiveLocationBar(targetLabel, expiresAt) {
    const bar = document.getElementById('liveLocationBar');
    if (!bar) return;
    bar.style.display = 'flex';
    const targetEl = document.getElementById('liveLocationTarget');
    if (targetEl) {
        if (targetLabel) {
            targetEl.textContent = `· ${targetLabel}`;
            targetEl.style.display = 'inline-flex';
        } else {
            targetEl.textContent = '';
            targetEl.style.display = 'none';
        }
    }
    const timerEl = document.getElementById('liveLocationTimer');
    if (timerEl) {
        timerEl.textContent = formatLiveLocationRemaining(expiresAt);
    }
}

function hideLiveLocationBar() {
    const bar = document.getElementById('liveLocationBar');
    if (!bar) return;
    bar.style.display = 'none';
}

function updateLiveLocationBar() {
    if (!liveLocationState.active) return;
    if (liveLocationState.expiresAt && Date.now() >= liveLocationState.expiresAt) {
        stopLiveLocationSharing('expired');
        return;
    }
    const timerEl = document.getElementById('liveLocationTimer');
    if (timerEl) {
        timerEl.textContent = formatLiveLocationRemaining(liveLocationState.expiresAt);
    }
}

async function sendLocationPayload({ content, messageType, target, optimistic = false, reloadChats = true, includeReply = false, silent = false }) {
    if (!content) return false;
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        if (!silent) {
            notifications.error('Необходима авторизация');
            window.location.href = '/login';
        }
        return false;
    }

    const handleInvalidToken = async () => {
        await window.xipherSession?.logout();
        notifications.error('Сессия истекла. Необходима повторная авторизация');
        setTimeout(() => {
            window.location.href = '/login';
        }, 2000);
    };

    const resolvedTarget = target || resolveMessageTarget();
    if (!resolvedTarget) {
        if (!silent) {
            notifications.warning('Выберите чат для отправки сообщения');
        }
        return false;
    }

    const replyId = includeReply && replyToMessage ? replyToMessage.id : '';

    if (resolvedTarget.type === 'group') {
        const activeGroup = window.groupsModule?.currentGroup?.();
        const isCurrentGroup = activeGroup && activeGroup.id === resolvedTarget.id && window.groupsModule?.isGroupActive?.();
        if (isCurrentGroup && window.groupsModule?.sendGroupMessage) {
            await window.groupsModule.sendGroupMessage(content, messageType);
            if (includeReply) {
                clearReplyState();
            }
            return true;
        }
        try {
            const response = await fetch('/api/send-group-message', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    token,
                    group_id: resolvedTarget.id,
                    content,
                    message_type: messageType
                })
            });
            const data = await response.json();
            if (!data.success) {
                if (data.message && data.message.includes('Invalid token')) {
                    await handleInvalidToken();
                } else if (!silent) {
                    notifications.error(data.message || 'Ошибка отправки геопозиции');
                }
                return false;
            }
            if (includeReply) {
                clearReplyState();
            }
            return true;
        } catch (error) {
            console.error('Error sending group location:', error);
            if (!silent) {
                notifications.error(t('chat.location.error'));
            }
            return false;
        }
    }

    if (resolvedTarget.type === 'channel') {
        const activeChannel = window.channelsModule?.currentChannel?.();
        const isCurrentChannel = activeChannel && activeChannel.id === resolvedTarget.id && window.channelsModule?.isChannelActive?.();
        if (isCurrentChannel && window.channelsModule?.sendChannelMessage) {
            await window.channelsModule.sendChannelMessage(content, messageType);
            if (includeReply) {
                clearReplyState();
            }
            return true;
        }
        try {
            const response = await fetch('/api/send-channel-message', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    token,
                    channel_id: resolvedTarget.id,
                    content,
                    message_type: messageType
                })
            });
            const data = await response.json();
            if (!data.success) {
                if (data.message && data.message.includes('Invalid token')) {
                    await handleInvalidToken();
                } else if (!silent) {
                    notifications.error(data.message || 'Ошибка отправки геопозиции');
                }
                return false;
            }
            if (includeReply) {
                clearReplyState();
            }
            return true;
        } catch (error) {
            console.error('Error sending channel location:', error);
            if (!silent) {
                notifications.error(t('chat.location.error'));
            }
            return false;
        }
    }

    const tempId = optimistic ? generateTempId() : '';
    if (optimistic) {
        const time = new Date().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
        const optimisticMessage = {
            content,
            sent: true,
            status: 'sent',
            temp_id: tempId,
            time,
            message_type: messageType,
            reply_to_message_id: replyId
        };
        addMessageToUI(optimisticMessage, true);
    }

    try {
        const requestBody = {
            token,
            receiver_id: resolvedTarget.id,
            content,
            message_type: messageType,
            reply_to_message_id: replyId
        };
        if (tempId) {
            requestBody.temp_id = tempId;
        }

        const response = await fetch(API_BASE + '/api/send-message', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        const data = await response.json();
        if (!data.success) {
            if (data.message && data.message.includes('Invalid token')) {
                await handleInvalidToken();
            } else if (!silent) {
                console.error('Failed to send location. Server response:', data);
                notifications.error(data.message || 'Ошибка отправки геопозиции');
            }
            return false;
        }

        if (optimistic && tempId) {
            reconcileTempMessage(tempId, {
                id: data.message_id,
                temp_id: data.temp_id || tempId,
                time: formatServerTimeToLocal(data.created_at)
            });
        }

        if (includeReply) {
            clearReplyState();
        }

        if (reloadChats) {
            await loadChats();
            if (currentChat && currentChat.id) {
                setTimeout(() => {
                    checkNewMessages(currentChat.id);
                }, 500);
            }
        }

        return true;
    } catch (error) {
        console.error('Error sending location:', error);
        if (!silent) {
            notifications.error(t('chat.location.error'));
        }
        return false;
    }
}

async function sendLocationMessage() {
    stopTypingForCurrentTarget();
    if (!navigator.geolocation) {
        notifications.error(t('chat.location.unavailable'));
        return;
    }

    const target = resolveMessageTarget();
    if (!target) {
        notifications.warning('Выберите чат для отправки сообщения');
        return;
    }

    notifications.info(t('chat.location.loading'));

    navigator.geolocation.getCurrentPosition(async (position) => {
        const lat = Number(position?.coords?.latitude);
        const lon = Number(position?.coords?.longitude);
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
            notifications.error(t('chat.location.error'));
            return;
        }

        const content = buildLocationUrl(lat, lon);
        const optimistic = target.type === 'dm';
        await sendLocationPayload({
            content,
            messageType: 'location',
            target,
            optimistic,
            reloadChats: true,
            includeReply: true,
            silent: false
        });
    }, (error) => {
        console.error('Geolocation error:', error);
        if (error && error.code === 1) {
            notifications.error(t('chat.location.permission'));
        } else {
            notifications.error(t('chat.location.error'));
        }
    }, {
        enableHighAccuracy: true,
        timeout: 12000,
        maximumAge: 30000
    });
}

function startLiveLocationSharing(durationSeconds) {
    if (liveLocationState.active) {
        notifications.info(t('chat.live.alreadyActive'));
        showLiveLocationBar(liveLocationState.target?.label || '', liveLocationState.expiresAt);
        return;
    }

    if (!navigator.geolocation) {
        notifications.error(t('chat.location.unavailable'));
        return;
    }

    const target = resolveMessageTarget();
    if (!target) {
        notifications.warning('Выберите чат для отправки сообщения');
        return;
    }

    const liveId = generateTempId();
    const expiresAt = Date.now() + durationSeconds * 1000;

    Object.assign(liveLocationState, {
        active: true,
        liveId,
        expiresAt,
        watchId: null,
        sendTimerId: null,
        countdownTimerId: null,
        lastCoords: null,
        lastSentAt: 0,
        target,
        hasSentInitial: false,
        startedNotified: false
    });

    clearReplyState();
    showLiveLocationBar(target.label || '', expiresAt);
    updateLiveLocationBar();

    const geoOptions = {
        enableHighAccuracy: true,
        timeout: 12000,
        maximumAge: 5000
    };

    const handlePosition = (position) => {
        if (!liveLocationState.active) return;
        const lat = Number(position?.coords?.latitude);
        const lon = Number(position?.coords?.longitude);
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
        liveLocationState.lastCoords = { lat, lon };
        sendLiveLocationUpdate();
    };

    const handleError = (error) => {
        console.error('Live location error:', error);
        if (error && error.code === 1) {
            notifications.error(t('chat.location.permission'));
        } else {
            notifications.error(t('chat.location.error'));
        }
        stopLiveLocationSharing('error', { silent: true });
    };

    liveLocationState.watchId = navigator.geolocation.watchPosition(handlePosition, handleError, geoOptions);
    navigator.geolocation.getCurrentPosition(handlePosition, handleError, geoOptions);

    liveLocationState.sendTimerId = setInterval(sendLiveLocationUpdate, LIVE_LOCATION_UPDATE_INTERVAL);
    liveLocationState.countdownTimerId = setInterval(updateLiveLocationBar, LIVE_LOCATION_COUNTDOWN_INTERVAL);

}

function stopLiveLocationSharing(reason = 'user', options = {}) {
    if (!liveLocationState.active) return;

    if (liveLocationState.watchId !== null && navigator.geolocation?.clearWatch) {
        navigator.geolocation.clearWatch(liveLocationState.watchId);
    }
    if (liveLocationState.sendTimerId) {
        clearInterval(liveLocationState.sendTimerId);
    }
    if (liveLocationState.countdownTimerId) {
        clearInterval(liveLocationState.countdownTimerId);
    }

    Object.assign(liveLocationState, {
        active: false,
        liveId: null,
        expiresAt: 0,
        watchId: null,
        sendTimerId: null,
        countdownTimerId: null,
        lastCoords: null,
        lastSentAt: 0,
        target: null,
        hasSentInitial: false,
        startedNotified: false
    });

    hideLiveLocationBar();

    if (options.silent) return;
    if (reason === 'expired') {
        notifications.info(t('chat.live.ended'));
    } else if (reason === 'user') {
        notifications.info(t('chat.live.stopped'));
    }
}

async function sendLiveLocationUpdate() {
    if (!liveLocationState.active) return;
    if (!liveLocationState.target) return;
    if (liveLocationState.expiresAt && Date.now() >= liveLocationState.expiresAt) {
        stopLiveLocationSharing('expired');
        return;
    }
    if (!liveLocationState.lastCoords) return;
    const now = Date.now();
    if (now - liveLocationState.lastSentAt < LIVE_LOCATION_MIN_SEND_INTERVAL) return;
    liveLocationState.lastSentAt = now;
    const content = buildLocationUrl(
        liveLocationState.lastCoords.lat,
        liveLocationState.lastCoords.lon,
        liveLocationState.liveId,
        liveLocationState.expiresAt
    );
    const optimistic = !liveLocationState.hasSentInitial && liveLocationState.target?.type === 'dm';
    const reloadChats = !liveLocationState.hasSentInitial;
    const ok = await sendLocationPayload({
        content,
        messageType: 'live_location',
        target: liveLocationState.target,
        optimistic,
        reloadChats,
        includeReply: false,
        silent: liveLocationState.hasSentInitial
    });
    if (ok && !liveLocationState.startedNotified) {
        liveLocationState.startedNotified = true;
        notifications.info(t('chat.live.started'));
    }
    if (ok && !liveLocationState.hasSentInitial) {
        liveLocationState.hasSentInitial = true;
    }
}

async function sendPendingAttachments(caption) {
    if (pendingAttachments.length === 0) {
        return { captionUsed: false, sentAny: false };
    }
    if (isSendingAttachments) {
        return { captionUsed: false, sentAny: false };
    }
    isSendingAttachments = true;
    const target = resolveMessageTarget();
    if (!target) {
        notifications.warning('Выберите чат для отправки сообщения');
        isSendingAttachments = false;
        return { captionUsed: false, sentAny: false };
    }
    const trimmedCaption = typeof caption === 'string' ? caption.trim() : '';
    const parsedCaption = parseSpoilerMarkup(trimmedCaption, { allowEmpty: true });
    const normalizedCaption = parsedCaption.content;
    const spoilerRequested = parsedCaption.isSpoiler;
    const ttlSeconds = getSelectedTtlSeconds();
    let captionUsed = false;
    let sentAny = false;
    const items = pendingAttachments.slice();
    const imageItems = items.filter(item => item.isImage);
    const mediaGroupId = imageItems.length > 1 ? generateTempId() : '';
    clearPendingAttachments();
    try {
        for (const item of items) {
            const useCaption = !captionUsed ? normalizedCaption : '';
            const ok = await uploadFile(item.file, {
                caption: useCaption,
                ttlSeconds,
                target,
                spoiler: item.isImage && spoilerRequested,
                mediaGroupId: item.isImage ? mediaGroupId : ''
            });
            if (ok) {
                sentAny = true;
                if (useCaption) {
                    captionUsed = true;
                }
            }
        }
        return { captionUsed, sentAny };
    } finally {
        isSendingAttachments = false;
    }
}

async function sendMessage() {
    const input = document.getElementById('messageInput');
    const message = input.value.trim();

    const hasAttachments = pendingAttachments.length > 0;
    if (!message && !hasAttachments) {
        return;
    }

    stopTypingForCurrentTarget();

    if (hasAttachments) {
        const { captionUsed } = await sendPendingAttachments(message);
        if (captionUsed || !message) {
            input.value = '';
            input.style.height = 'auto';
        }
        return;
    }

    const parsedMessage = parseSpoilerMarkup(message);
    const outgoingContent = parsedMessage.isSpoiler
        ? encodeSpoilerContent(parsedMessage.content)
        : parsedMessage.content;
    const ttlSeconds = getSelectedTtlSeconds();

    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications.error('Необходима авторизация');
        window.location.href = '/login';
        return;
    }

    // Проверяем, активна ли группа (fallback через currentGroup, чтобы не блокироваться, если флаг не выставился)
    const activeGroup = window.groupsModule && typeof window.groupsModule.currentGroup === 'function'
        ? window.groupsModule.currentGroup()
        : (window.currentGroup || null);
    
    console.log('[Chat] Checking for active group:', {
        hasGroupsModule: !!window.groupsModule,
        isGroupActive: window.groupsModule?.isGroupActive?.(),
        activeGroup: activeGroup,
        windowCurrentGroup: window.currentGroup
    });
    
    if (window.groupsModule && (window.groupsModule.isGroupActive?.() || activeGroup)) {
        console.log('[Chat] Sending message to group via groupsModule');
        await window.groupsModule.sendGroupMessage(outgoingContent, 'text', '', '', 0, ttlSeconds);
        input.value = '';
        input.style.height = 'auto';
        replyToMessage = null;
        const replyPreview = document.getElementById('replyPreview');
        if (replyPreview) replyPreview.style.display = 'none';
        return;
    }
    
    // Проверяем, активен ли канал
    if (window.channelsModule && window.channelsModule.isChannelActive()) {
        await window.channelsModule.sendChannelMessage(outgoingContent, 'text', '', '', 0, ttlSeconds);
        input.value = '';
        input.style.height = 'auto';
        replyToMessage = null;
        const replyPreview = document.getElementById('replyPreview');
        if (replyPreview) replyPreview.style.display = 'none';
        return;
    }

    // Обычный чат
    if (!currentChat) {
        notifications.warning('Выберите чат для отправки сообщения');
        return;
    }
    
    // Для избранных сообщений receiver_id должен быть равен sender_id (currentUser.id)
    let receiverId = currentChat.id;
    if (currentChat.is_saved_messages) {
        if (!currentUser || !currentUser.id) {
            notifications.error('Ошибка: информация о пользователе не найдена');
            return;
        }
        receiverId = currentUser.id;
        console.log('Sending to saved messages - receiver_id set to currentUser.id:', receiverId);
    }

    // Очистка input
    input.value = '';
    input.style.height = 'auto';

    const tempId = generateTempId();

    // Добавление сообщения в UI сразу (оптимистичное обновление)
    const time = new Date().toLocaleTimeString('ru-RU', { 
        hour: '2-digit', 
        minute: '2-digit' 
    });
    const optimisticMessage = {
        content: outgoingContent,
        sent: true,
        status: 'sent',
        temp_id: tempId,
        time: time,
        message_type: 'text',
        reply_to_message_id: replyToMessage ? replyToMessage.id : '',
        ttl_seconds: ttlSeconds
    };
    addMessageToUI(optimisticMessage, true); // scrollToBottom = true для немедленной прокрутки

    // Отправка на сервер
    try {
    const requestBody = {
        token: token,
        receiver_id: receiverId,
        content: outgoingContent,
        message_type: 'text',
            reply_to_message_id: replyToMessage ? replyToMessage.id : '',
            temp_id: tempId
        };
        if (ttlSeconds > 0) {
            requestBody.ttl_seconds = ttlSeconds;
        }

        const response = await fetch(API_BASE + '/api/send-message', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        const data = await response.json();
        console.log('Response data:', data);
        console.log('Response success:', data.success);
        console.log('Response message:', data.message);
        
        if (!data.success) {
            // Если токен невалиден, очищаем и редиректим
            if (data.message && data.message.includes('Invalid token')) {
                await window.xipherSession?.logout();
                notifications.error('Сессия истекла. Необходима повторная авторизация');
                setTimeout(() => {
                    window.location.href = '/login';
                }, 2000);
            } else {
                console.error('Failed to send message. Server response:', data);
                notifications.error(data.message || 'Ошибка отправки сообщения. Попробуйте еще раз.');
            }
        } else {
            // Совмещаем оптимистичное сообщение с реальным ID
            reconcileTempMessage(tempId, {
                id: data.message_id,
                temp_id: data.temp_id || tempId,
                time: formatServerTimeToLocal(data.created_at),
                ttl_seconds: ttlSeconds
            });

            // Сбрасываем реплай
            replyToMessage = null;
            document.getElementById('replyPreview').style.display = 'none';
            // Обновление последнего сообщения в списке чатов
            console.log('Message sent successfully, reloading chats...');
            await loadChats(); // Перезагружаем список чатов
            console.log('Chats reloaded after message send');
            // Перезагружаем сообщения текущего чата, чтобы получить правильный ID и данные с сервера
            // Но не очищаем контейнер, так как сообщение уже добавлено оптимистично
            if (currentChat && currentChat.id) {
                // Просто проверяем новые сообщения, не перезагружая все
                setTimeout(() => {
                    checkNewMessages(currentChat.id);
                }, 500);
            }
        }
    } catch (error) {
        console.error('Error sending message:', error);
        notifications.error('Ошибка отправки сообщения');
    }
}

function isAutoImageCaption(content, fileName) {
    const normalized = (content || '').trim();
    if (!normalized) return true;
    if (normalized === '[Photo]' || normalized === 'Фото' || normalized === 'Photo') {
        return true;
    }
    if (normalized.startsWith('📎')) {
        if (!fileName) return true;
        return normalized.includes(fileName);
    }
    return false;
}

function isGroupableMediaMessage(msg, isImageAttachment, hideImageText) {
    if (!msg || !isImageAttachment || !hideImageText) return false;
    if (msg.reply_to_message_id) return false;
    if (msg.reply_markup) return false;
    return true;
}

function buildMediaGroupKey(msg, { isSent, timeText, isSpoilerMessage }) {
    if (!msg) return '';
    const mediaGroupId = msg.media_group_id || msg.mediaGroupId || '';
    if (mediaGroupId) return `media:${mediaGroupId}`;
    const senderId = msg.sender_id || msg.senderId || (isSent ? 'self' : 'other');
    const timeKey = msg.time || timeText || '';
    const ttlKey = Number.isFinite(msg.ttl_seconds)
        ? msg.ttl_seconds
        : (Number.isFinite(msg.ttlSeconds) ? msg.ttlSeconds : 0);
    const spoilerKey = isSpoilerMessage ? '1' : '0';
    return `t:${senderId}:${timeKey}:${ttlKey}:${spoilerKey}`;
}

function getLastMessageElement(container) {
    if (!container) return null;
    const messages = container.querySelectorAll('.message');
    return messages.length ? messages[messages.length - 1] : null;
}

function appendMessageToMediaGroup(container, messageDiv, groupKey, isSent) {
    if (!container || !messageDiv || !groupKey) return false;
    const lastMessage = getLastMessageElement(container);
    if (!lastMessage) return false;
    const lastKey = lastMessage.dataset.mediaGroupKey || '';
    if (!lastKey || lastKey !== groupKey) return false;

    let group = lastMessage.closest('.message-group');
    if (group) {
        if ((group.dataset.mediaGroupKey || '') !== groupKey) return false;
    } else {
        group = document.createElement('div');
        group.className = `message-group ${isSent ? 'sent' : 'received'}`;
        group.dataset.mediaGroupKey = groupKey;
        container.insertBefore(group, lastMessage);
        group.appendChild(lastMessage);
        lastMessage.classList.add('is-media-group-item');
    }

    messageDiv.classList.add('is-media-group-item');
    group.appendChild(messageDiv);
    return true;
}

function addMessageToUI(msg, scrollToBottom = false) {
    const messagesContainer = document.getElementById('chatMessages');
    const tempId = msg.temp_id || msg.tempId || '';
    const hasTempId = Boolean(tempId);
    const contentText = typeof msg.content === 'string' ? msg.content : '';
    const isSpoilerMessage = isSpoilerContent(contentText);
    const displayContent = stripSpoilerContent(contentText);

    if (handleChecklistUpdateMessage(msg)) {
        return null;
    }
    
    // Удаляем empty state если есть
    const emptyChat = messagesContainer.querySelector('.empty-chat');
    if (emptyChat) {
        emptyChat.remove();
    }

    const locationPayload = isLocationMessageType(msg.message_type) ? parseLocationPayload(displayContent) : null;
    const liveId = msg.message_type === 'live_location' && locationPayload?.liveId ? locationPayload.liveId : null;
    const locationCard = typeof buildLocationCard === 'function' ? buildLocationCard(msg) : null;
    const isLocationMessage = Boolean(locationCard);
    const checklistPayload = isSpoilerMessage ? null : parseChecklistPayloadContent(displayContent);
    const isChecklistMessage = !isSpoilerMessage && isChecklistContent(displayContent);
    const giftPayload = isSpoilerMessage ? null : parsePremiumGiftPayloadContent(displayContent);
    const isGiftMessage = Boolean(giftPayload);

    if (liveId) {
        const existingLive = messagesContainer.querySelector(`[data-live-id="${liveId}"]`);
        if (existingLive) {
            if (msg.id) {
                existingLive.dataset.messageId = msg.id;
                existingLive.id = `msg-${msg.id}`;
            }
            if (hasTempId) {
                existingLive.dataset.tempId = tempId;
            }
            existingLive.dataset.liveId = liveId;
            const timeEl = existingLive.querySelector('.message-time-text') || existingLive.querySelector('.message-time');
            if (timeEl && msg.time) {
                timeEl.textContent = msg.time;
            }
            const bubble = existingLive.querySelector('.message-bubble');
            if (bubble && locationCard) {
                const existingCard = bubble.querySelector('.message-location');
                if (existingCard) {
                    existingCard.replaceWith(locationCard);
                } else {
                    bubble.insertBefore(locationCard, bubble.firstChild);
                }
            }
            return existingLive;
        }
    }

    const existingById = msg.id ? messagesContainer.querySelector(`[data-message-id="${msg.id}"]`) : null;
    const existingByTemp = hasTempId ? messagesContainer.querySelector(`[data-temp-id="${tempId}"]`) : null;

    // Если сообщение с таким реальным ID уже есть, не добавляем новое
    if (existingById && (!existingByTemp || existingByTemp === existingById)) {
        applyMessageTtlData(existingById, msg);
        return existingById;
    }

    // Если пришел real ID для оптимистичного сообщения - обновляем существующий элемент
    if (existingByTemp && msg.id) {
        existingByTemp.dataset.messageId = msg.id;
        existingByTemp.dataset.tempId = tempId;
        existingByTemp.id = `msg-${msg.id}`;
        existingByTemp.classList.add('sent');
        const timeEl = existingByTemp.querySelector('.message-time-text') || existingByTemp.querySelector('.message-time');
        if (timeEl && msg.time) {
            timeEl.textContent = msg.time;
        }
        const statusEl = existingByTemp.querySelector('.message-status');
        if (statusEl) {
            applyMessageStatus(statusEl, resolveMessageStatus(msg, true));
        }
        const textEl = existingByTemp.querySelector('.message-text');
        if (textEl && typeof msg.content === 'string') {
            const rawContent = msg.content;
            const isSpoiler = isSpoilerContent(rawContent);
            const safeContent = stripSpoilerContent(rawContent);
            textEl.innerHTML = parseMentions(safeContent);
            applySpoilerTextState(textEl, isSpoiler);
            textEl.querySelectorAll('.mention-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    if (textEl.classList.contains('spoiler-blur') && !textEl.classList.contains('is-revealed')) {
                        e.preventDefault();
                        e.stopPropagation();
                        textEl.classList.add('is-revealed');
                        return;
                    }
                    e.preventDefault();
                    e.stopPropagation();
                    const username = link.dataset.username;
                    if (username) {
                        handleMentionClick(username);
                    }
                });
            });
        }
        applyMessageTtlData(existingByTemp, msg);
        if (resolveMessageStatus(msg, true) === 'read' && msg.id) {
            markMessageReadLocal(msg.id, existingByTemp);
        }
        return existingByTemp;
    }

    const isSent = isMessageFromCurrentUser(msg);
    const isIncoming = !isSent;
    const isVoiceMessage = msg.message_type === 'voice';
    const videoNoteProbe = (msg.file_name || msg.file_path || '').toLowerCase();
    const isVideoNoteFile = msg.message_type === 'file'
        && videoNoteProbe.includes('videonote_')
        && videoNoteProbe.endsWith('.mp4');
    const fileNameHint = msg.file_name || msg.file_path || '';
    const hasLocalPreview = typeof msg.local_url === 'string' && msg.local_url;
    const hasFilePayload = Boolean(msg.file_path || hasLocalPreview || msg.transfer_state);
    const isImageAttachment = (msg.message_type === 'image'
        || (msg.message_type === 'file' && isImageFileName(fileNameHint)))
        && hasFilePayload;
    const hideImageText = isImageAttachment && isAutoImageCaption(displayContent, fileNameHint);
    const time = msg.time || new Date().toLocaleTimeString('ru-RU', { 
        hour: '2-digit', 
        minute: '2-digit' 
    });

    // Проверяем, является ли сообщение "только медиа" (изображение без текста)
    const isMediaOnly = isImageAttachment && hideImageText && !msg.reply_to_message_id;
    
    // Проверяем, является ли сообщение "только файл" (файл без текста)
    const isFileOnly = hasFilePayload && !isImageAttachment && !isVoiceMessage && !isVideoNoteFile
        && (!displayContent || displayContent.trim() === '' || isAutoImageCaption(displayContent, fileNameHint))
        && !msg.reply_to_message_id;

    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
    if (isVoiceMessage) {
        messageDiv.classList.add('is-voice-message');
    }
    if (isMediaOnly) {
        messageDiv.classList.add('is-media-only');
    }
    if (isFileOnly) {
        messageDiv.classList.add('is-file-only');
    }
    messageDiv.dataset.messageId = msg.id || '';
    messageDiv.dataset.tempId = hasTempId ? tempId : '';
    if (liveId) {
        messageDiv.dataset.liveId = liveId;
    }
    messageDiv.id = msg.id ? `msg-${msg.id}` : hasTempId ? `msg-temp-${tempId}` : '';
    const canGroupMedia = isGroupableMediaMessage(msg, isImageAttachment, hideImageText);
    const mediaGroupKey = canGroupMedia
        ? buildMediaGroupKey(msg, { isSent, timeText: time, isSpoilerMessage })
        : '';
    if (mediaGroupKey) {
        messageDiv.dataset.mediaGroupKey = mediaGroupKey;
    }

    const avatar = document.createElement('div');
    avatar.className = 'message-avatar';
    const senderFallback = currentUser?.username?.charAt(0).toUpperCase() || 'U';
    const receiverFallback = currentChat?.avatar || currentChat?.name?.charAt(0).toUpperCase() || 'F';
    
    if (isSent) {
        const userAvatarUrl = getStoredAvatarUrl(getCurrentUserId());
        if (userAvatarUrl && isValidUrl(userAvatarUrl)) {
            const img = document.createElement('img');
            img.src = userAvatarUrl;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            img.style.borderRadius = '50%';
            img.onerror = () => {
                avatar.textContent = senderFallback;
            };
            avatar.appendChild(img);
        } else {
            avatar.textContent = senderFallback;
        }
    } else {
        if (currentChat?.avatar_url && isValidUrl(currentChat.avatar_url)) {
            const img = document.createElement('img');
            img.src = currentChat.avatar_url;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            img.style.borderRadius = '50%';
            img.onerror = () => {
                avatar.textContent = receiverFallback;
            };
            avatar.appendChild(img);
        } else {
            avatar.textContent = receiverFallback;
        }
    }

    const bubble = document.createElement('div');
    bubble.className = 'message-bubble';

    // Реплай (если есть)
    if (msg.reply_to_message_id) {
        const replyDiv = document.createElement('div');
        replyDiv.className = 'message-reply';
        replyDiv.dataset.replyTo = msg.reply_to_message_id;
        
        const replyLabel = document.createElement('div');
        replyLabel.className = 'message-reply-label';
        // Показываем имя автора оригинального сообщения
        const replyAuthor = msg.reply_sender_name || msg.reply_author || '';
        if (replyAuthor) {
            replyLabel.textContent = replyAuthor;
        } else {
            replyLabel.textContent = t('chat.replyLabel') || 'Ответ на сообщение';
        }
        
        const replyText = document.createElement('div');
        replyText.className = 'message-reply-text';
        const replyContent = msg.reply_content || msg.reply_text || '';
        replyText.textContent = formatMessagePreviewText(replyContent) || 'Сообщение';
        
        replyDiv.appendChild(replyLabel);
        replyDiv.appendChild(replyText);
        
        // Клик для прокрутки к оригинальному сообщению
        replyDiv.addEventListener('click', (e) => {
            e.stopPropagation();
            scrollToMessage(msg.reply_to_message_id);
        });
        
        bubble.appendChild(replyDiv);
    }

    if (isGiftMessage && giftPayload) {
        const giftEl = buildPremiumGiftElement(giftPayload, msg);
        if (giftEl) {
            messageDiv.classList.add('is-gift');
            bubble.appendChild(giftEl);
        }
    } else if (isLocationMessage) {
        bubble.appendChild(locationCard);
    } else if (checklistPayload) {
        const checklistEl = buildChecklistElement(checklistPayload, msg, messageDiv);
        if (checklistEl) {
            checklistEl.addEventListener('click', (e) => {
                if (e.target.closest('input, button')) return;
                if (typeof setReplyToMessage === 'function') {
                    setReplyToMessage(msg);
                }
            });
            bubble.appendChild(checklistEl);
        }
    } else if (isChecklistMessage) {
        const messageText = document.createElement('p');
        messageText.className = 'message-text';
        messageText.textContent = t('chat.checklist.preview');
        bubble.appendChild(messageText);
    } else if (!isVoiceMessage && !isVideoNoteFile && !hideImageText) {
        const messageText = document.createElement('p');
        messageText.className = 'message-text';
        
        // Парсим упоминания (@username и @channel) и делаем их кликабельными
        const parsedContent = parseMentions(displayContent);
        messageText.innerHTML = parsedContent;
        applySpoilerTextState(messageText, isSpoilerMessage);

        // Добавляем обработчики кликов на упоминания
        messageText.querySelectorAll('.mention-link').forEach(link => {
            link.addEventListener('click', (e) => {
                if (messageText.classList.contains('spoiler-blur') && !messageText.classList.contains('is-revealed')) {
                    e.preventDefault();
                    e.stopPropagation();
                    messageText.classList.add('is-revealed');
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                const username = link.dataset.username;
                if (username) {
                    handleMentionClick(username);
                }
            });
        });

        // Добавляем обработчик для реплая (только если не кликнули на упоминание)
        messageText.style.cursor = 'pointer';
        messageText.addEventListener('click', (e) => {
            if (messageText.classList.contains('spoiler-blur') && !messageText.classList.contains('is-revealed')) {
                e.preventDefault();
                e.stopPropagation();
                messageText.classList.add('is-revealed');
                return;
            }
            // Если кликнули на упоминание, не открываем реплай
            if (e.target.classList.contains('mention-link')) {
                return;
            }
            setReplyToMessage(msg);
        });

        bubble.appendChild(messageText);
    }

    const replyMarkup = parseReplyMarkupFromMessage(msg);

    // Inline keyboard buttons (reply_markup)
    if (replyMarkup && replyMarkup.inline_keyboard && Array.isArray(replyMarkup.inline_keyboard)) {
        const keyboardDiv = document.createElement('div');
        keyboardDiv.className = 'message-keyboard';
        
        replyMarkup.inline_keyboard.forEach(row => {
            const rowDiv = document.createElement('div');
            rowDiv.className = 'keyboard-row';
            
            row.forEach(button => {
                const btn = document.createElement('button');
                btn.className = 'keyboard-button';
                btn.textContent = button.text || '';
                btn.dataset.callbackData = button.callback_data || '';
                btn.dataset.url = button.url || '';
                
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleKeyboardButtonClick(button, msg);
                });
                
                rowDiv.appendChild(btn);
            });
            
            keyboardDiv.appendChild(rowDiv);
        });
        
        bubble.appendChild(keyboardDiv);
    }

    if (replyMarkup) {
        applyReplyKeyboardFromMarkup(replyMarkup, { isIncoming: !isSent });
    }

    // Файл
    if ((msg.message_type === 'file' || msg.message_type === 'image') && hasFilePayload) {
        const fileName = msg.file_name || 'Файл';
        const fileExt = fileName.split('.').pop().toLowerCase();
        const videoExts = ['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv'];
        const fileUrl = msg.file_path ? getSafeFileUrl(msg.file_path) : '';
        const isExplicitImage = msg.message_type === 'image';
        const isImageFile = isExplicitImage || IMAGE_EXTS.includes(fileExt);
        const transferState = resolveTransferState(msg, isSent);
        const transferProgress = typeof msg.transfer_progress === 'number' ? msg.transfer_progress : 0;
        const isUploading = isSent && transferState === TRANSFER_STATES.LOADING && !fileUrl;

        if (!fileUrl && !hasLocalPreview && transferState !== TRANSFER_STATES.LOADING) {
            const fileDiv = document.createElement('div');
            fileDiv.className = 'message-file';
            if (fileExt) {
                fileDiv.dataset.ext = fileExt;
            }
            const fileIconWrap = document.createElement('div');
            fileIconWrap.className = 'message-file-icon-wrap';
            const fileIcon = document.createElement('div');
            fileIcon.className = 'message-file-icon';
            fileIcon.innerHTML = typeof appIconSvg === 'function' ? appIconSvg('file') : '📎';
            fileIconWrap.appendChild(fileIcon);
            fileDiv.appendChild(fileIconWrap);
            const fileInfo = document.createElement('div');
            fileInfo.className = 'message-file-info';
            const fileNameDiv = document.createElement('div');
            fileNameDiv.className = 'message-file-name';
            fileNameDiv.textContent = `${fileName} (недоступен)`;
            const fileSize = document.createElement('div');
            fileSize.className = 'message-file-size';
            fileSize.textContent = formatFileSize(msg.file_size || 0);
            fileInfo.appendChild(fileNameDiv);
            fileInfo.appendChild(fileSize);
            fileDiv.appendChild(fileInfo);
            bubble.appendChild(fileDiv);
        } else if (isImageFile) {
            const imageDiv = document.createElement('div');
            imageDiv.className = 'message-image';
            const img = document.createElement('img');
            const initialImageUrl = hasLocalPreview ? msg.local_url : fileUrl;
            if (initialImageUrl) {
                img.src = initialImageUrl;
            }
            img.alt = fileName;
            img.style.maxWidth = '100%';
            img.style.maxHeight = '400px';
            img.style.borderRadius = '8px';
            img.style.cursor = 'pointer';
            img.style.objectFit = 'contain';

            const transferRing = createTransferRing({
                state: transferState,
                progress: transferProgress,
                kind: 'image',
                size: 48
            });
            if (transferRing) {
                imageDiv.appendChild(transferRing);
                transferRing.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (transferRing.dataset.state === TRANSFER_STATES.LOADING) {
                        if (isUploading) {
                            cancelUploadTransfer(messageDiv.dataset.tempId || tempId);
                        } else {
                            cancelDownloadTransfer(getMessageKeyFromElement(messageDiv));
                        }
                        return;
                    }
                    if (transferRing.dataset.state === TRANSFER_STATES.IDLE) {
                        if (isUploading) return;
                        if (!fileUrl) {
                            notifications.error('Файл недоступен');
                            return;
                        }
                        startDownloadTransfer({
                            messageDiv,
                            ring: transferRing,
                            fileUrl,
                            fileName,
                            isImage: true
                        });
                    }
                });
            }

            const isSpoilerMedia = isSpoilerMessage;
            if (isSpoilerMedia) {
                imageDiv.classList.add('spoiler-media');
                img.classList.add('spoiler-blur');
            }

            img.addEventListener('load', () => {
                if (hasLocalPreview && msg.local_url.startsWith('blob:')) {
                    URL.revokeObjectURL(msg.local_url);
                }
            });

            // Клик для открытия в полном размере
            img.addEventListener('click', (e) => {
                if (isSpoilerMedia && !imageDiv.classList.contains('is-revealed')) {
                    e.preventDefault();
                    e.stopPropagation();
                    imageDiv.classList.add('is-revealed');
                    img.classList.add('is-revealed');
                    return;
                }
                if (transferRing && transferRing.dataset.state === TRANSFER_STATES.LOADING && !isUploading) {
                    return;
                }
                if (transferRing && transferRing.dataset.state === TRANSFER_STATES.IDLE && isIncoming) {
                    if (!fileUrl) {
                        notifications.error('Файл недоступен');
                        return;
                    }
                    startDownloadTransfer({
                        messageDiv,
                        ring: transferRing,
                        fileUrl,
                        fileName,
                        isImage: true
                    });
                    return;
                }
                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center; cursor: pointer;';
                const fullImg = document.createElement('img');
                fullImg.src = messageDiv.dataset.downloadUrl || fileUrl || img.src;
                fullImg.style.cssText = 'max-width: 90%; max-height: 90%; object-fit: contain;';
                modal.appendChild(fullImg);
                modal.addEventListener('click', () => modal.remove());
                document.body.appendChild(modal);
            });
            
            let overlay = null;
            if (isSpoilerMedia) {
                overlay = document.createElement('div');
                overlay.className = 'spoiler-overlay';
                overlay.textContent = t('chat.spoiler.reveal');
            }

            imageDiv.appendChild(img);
            if (overlay) {
                imageDiv.appendChild(overlay);
            }
            bubble.appendChild(imageDiv);
        }
        // Видео - показываем inline с плеером
        else if (!isExplicitImage && videoExts.includes(fileExt)) {
            const lowerName = (fileName || msg.file_path || '').toLowerCase();
            const isVideoNote = fileExt === 'mp4' && lowerName.includes('videonote_');

            if (isVideoNote) {
                const videoNote = document.createElement('div');
                videoNote.className = 'message-video-note';

                const video = document.createElement('video');
                video.src = fileUrl;
                video.preload = 'metadata';
                video.playsInline = true;
                video.loop = true;
                video.muted = false;

                const overlay = document.createElement('button');
                overlay.className = 'video-note-play';
                overlay.type = 'button';
                overlay.setAttribute('aria-label', 'Play video note');
                overlay.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M3 2L13 8L3 14V2Z" fill="white"/></svg>';

                const toggle = () => {
                    if (video.paused) {
                        video.play().catch(() => {});
                    } else {
                        video.pause();
                    }
                };

                overlay.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggle();
                });
                videoNote.addEventListener('click', toggle);

                video.addEventListener('play', () => overlay.classList.add('is-hidden'));
                video.addEventListener('pause', () => overlay.classList.remove('is-hidden'));

                videoNote.appendChild(video);
                videoNote.appendChild(overlay);
                bubble.appendChild(videoNote);
            } else {
                const videoDiv = document.createElement('div');
                videoDiv.className = 'message-video';
                const video = document.createElement('video');
                video.src = fileUrl;
                video.controls = true;
                video.style.maxWidth = '100%';
                video.style.maxHeight = '400px';
                video.style.borderRadius = '8px';
                video.style.backgroundColor = '#000';
                
                const videoInfo = document.createElement('div');
                videoInfo.className = 'message-file-info';
                videoInfo.style.marginTop = '0.5rem';
                const videoName = document.createElement('div');
                videoName.className = 'message-file-name';
                videoName.textContent = fileName;
                const videoSize = document.createElement('div');
                videoSize.className = 'message-file-size';
                videoSize.textContent = formatFileSize(msg.file_size || 0);
                videoInfo.appendChild(videoName);
                videoInfo.appendChild(videoSize);
                
                videoDiv.appendChild(video);
                videoDiv.appendChild(videoInfo);
                bubble.appendChild(videoDiv);
            }
        }
        // Обычный файл - показываем как ссылку для скачивания
        else {
            const fileDiv = document.createElement('div');
            fileDiv.className = 'message-file';
            // Добавляем расширение для цветовой схемы иконки
            if (fileExt) {
                fileDiv.dataset.ext = fileExt;
            }
            const fileIconWrap = document.createElement('div');
            fileIconWrap.className = 'message-file-icon-wrap';
            const fileIcon = document.createElement('div');
            fileIcon.className = 'message-file-icon';
            // Выбираем иконку по типу файла
            let fileIconName = 'file';
            if (['pdf'].includes(fileExt)) fileIconName = 'description';
            else if (['doc', 'docx', 'txt', 'rtf'].includes(fileExt)) fileIconName = 'description';
            else if (['xls', 'xlsx', 'csv'].includes(fileExt)) fileIconName = 'file';
            else if (['zip', 'rar', '7z', 'tar', 'gz'].includes(fileExt)) fileIconName = 'file';
            else if (['mp3', 'wav', 'ogg', 'flac', 'aac'].includes(fileExt)) fileIconName = 'mic';
            else if (['mp4', 'avi', 'mkv', 'mov', 'webm'].includes(fileExt)) fileIconName = 'video';
            else if (['apk'].includes(fileExt)) fileIconName = 'download';
            fileIcon.innerHTML = typeof appIconSvg === 'function' ? appIconSvg(fileIconName) : '📎';
            fileIconWrap.appendChild(fileIcon);
            const transferRing = createTransferRing({
                state: transferState,
                progress: transferProgress,
                kind: 'file',
                size: 36
            });
            if (transferRing) {
                fileIconWrap.appendChild(transferRing);
            }
            const fileInfo = document.createElement('div');
            fileInfo.className = 'message-file-info';
            const fileNameDiv = document.createElement('div');
            fileNameDiv.className = 'message-file-name';
            fileNameDiv.textContent = fileName;
            const fileSize = document.createElement('div');
            fileSize.className = 'message-file-size';
            fileSize.textContent = formatFileSize(msg.file_size || 0);
            fileInfo.appendChild(fileNameDiv);
            fileInfo.appendChild(fileSize);
            fileDiv.appendChild(fileIconWrap);
            fileDiv.appendChild(fileInfo);
            
            const openFile = (url) => {
                if (!url) return;
                if (url.startsWith('blob:')) {
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = fileName || 'file';
                    link.rel = 'noopener';
                    link.click();
                    return;
                }
                const opened = window.open(url, '_blank', 'noopener,noreferrer');
                if (opened) opened.opener = null;
            };
            const handleTransferStart = () => {
                if (!transferRing || isUploading) return;
                if (!fileUrl) {
                    notifications.error('Файл недоступен');
                    return;
                }
                startDownloadTransfer({
                    messageDiv,
                    ring: transferRing,
                    fileUrl,
                    fileName,
                    isImage: false
                });
            };

            if (transferRing) {
                transferRing.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (transferRing.dataset.state === TRANSFER_STATES.LOADING) {
                        if (isUploading) {
                            cancelUploadTransfer(messageDiv.dataset.tempId || tempId);
                        } else {
                            cancelDownloadTransfer(getMessageKeyFromElement(messageDiv));
                        }
                        return;
                    }
                    if (transferRing.dataset.state === TRANSFER_STATES.IDLE) {
                        handleTransferStart();
                        return;
                    }
                    if (transferRing.dataset.state === TRANSFER_STATES.DONE) {
                        const savedUrl = messageDiv.dataset.downloadUrl || '';
                        if (savedUrl) {
                            openFile(savedUrl);
                        } else {
                            openFile(fileUrl);
                        }
                    }
                });
            }

            // Ссылка на скачивание
            fileDiv.style.cursor = 'pointer';
            fileDiv.addEventListener('click', () => {
                if (isUploading) return;
                if (transferRing && transferRing.dataset.state === TRANSFER_STATES.LOADING) return;
                const savedUrl = messageDiv.dataset.downloadUrl || '';
                if (isIncoming) {
                    if (!savedUrl) {
                        handleTransferStart();
                        return;
                    }
                    openFile(savedUrl);
                    return;
                }
                if (savedUrl) {
                    openFile(savedUrl);
                } else {
                    openFile(fileUrl);
                }
            });
            
            bubble.appendChild(fileDiv);
        }
    }

    // Голосовое сообщение
    if (msg.message_type === 'voice' && msg.file_path) {
        const voiceDiv = document.createElement('div');
        voiceDiv.className = 'message-voice';
        
        // Создаем аудио элемент
        const audio = document.createElement('audio');
        const voiceUrl = getSafeFileUrl(msg.file_path);
        if (!voiceUrl) {
            console.error('Invalid file path:', msg.file_path);
            const errorText = document.createElement('div');
            errorText.className = 'message-file-info';
            errorText.textContent = 'Голосовое сообщение недоступно';
            voiceDiv.appendChild(errorText);
            bubble.appendChild(voiceDiv);
        } else {
            audio.src = voiceUrl;
            audio.preload = 'auto';
            audio.crossOrigin = 'anonymous';
        
        // Кнопка воспроизведения
        const playBtn = document.createElement('button');
        playBtn.className = 'voice-play-btn';
        playBtn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M5 3L19 12L5 21V3Z" fill="white"/></svg>';
        playBtn.setAttribute('aria-label', 'Воспроизвести');
        
        // Контейнер для визуализации волны
        const waveformContainer = document.createElement('div');
        waveformContainer.className = 'voice-waveform-container';
        
        const canvas = document.createElement('canvas');
        canvas.className = 'voice-waveform';
        canvas.width = 260;
        canvas.height = 23;
        waveformContainer.appendChild(canvas);
        
        // Информация о длительности и размере
        const voiceInfo = document.createElement('div');
        voiceInfo.className = 'voice-info';
        
        // Вычисляем начальную длительность из размера файла (приблизительно)
        // Типичный bitrate для голосовых: ~32kbps = 4KB/s
        const estimatedDuration = msg.file_size ? Math.round(msg.file_size / 4000) : 0;
        const estMinutes = Math.floor(estimatedDuration / 60);
        const estSeconds = estimatedDuration % 60;
        
        const durationSpan = document.createElement('span');
        durationSpan.className = 'voice-duration';
        durationSpan.textContent = estimatedDuration > 0 ? `${estMinutes}:${String(estSeconds).padStart(2, '0')}` : '0:00';

        const speedBtn = document.createElement('button');
        speedBtn.className = 'voice-speed-btn';
        speedBtn.type = 'button';
        speedBtn.textContent = formatVoicePlaybackRate(voicePlaybackRate);
        speedBtn.setAttribute('aria-label', 'Скорость воспроизведения');
        speedBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            voicePlaybackRate = getNextVoicePlaybackRate(voicePlaybackRate);
            speedBtn.textContent = formatVoicePlaybackRate(voicePlaybackRate);
            applyVoicePlaybackRate(audio, voicePlaybackRate);
            try {
                localStorage.setItem('xipher_voice_rate', String(voicePlaybackRate));
            } catch (_) {}
        });
        
        const sizeSpan = document.createElement('span');
        sizeSpan.className = 'voice-size';
        sizeSpan.textContent = formatFileSize(msg.file_size || 0);
        
        const metaRow = document.createElement('div');
        metaRow.className = 'voice-meta-row';
        metaRow.appendChild(durationSpan);
        metaRow.appendChild(speedBtn);
        voiceInfo.appendChild(metaRow);
        voiceInfo.appendChild(sizeSpan);
        
        // Кнопка пересылки
        const forwardBtn = document.createElement('button');
        forwardBtn.className = 'voice-forward-btn';
        forwardBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 14 14" fill="none"><path d="M1 7H13M13 7L8 2M13 7L8 12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg> A';
        forwardBtn.setAttribute('aria-label', 'Переслать');
        
        // Обработчик клика на пересылку
        forwardBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            // TODO: Реализовать пересылку сообщения
            notifications.info('Функция пересылки в разработке');
        });
        
        // Инициализация Web Audio API для визуализации
        let audioContext = null;
        let analyser = null;
        let source = null;
        let animationFrameId = null;
        let waveformData = null;
        let dataArray = null;
        const waveformBars = 63;
        
        // Функция для генерации реалистичных данных волны (стиль Telegram)
        function generateWaveformData() {
            const data = [];
            let prev = 0.3;
            for (let i = 0; i < waveformBars; i++) {
                // Плавные изменения высоты
                const target = Math.random() * 0.8 + 0.15;
                prev = prev * 0.6 + target * 0.4;
                data.push(prev);
            }
            return data;
        }
        
        function getWaveColors(isPlaying) {
            const styles = getComputedStyle(voiceDiv);
            const basePlayed = styles.getPropertyValue('--voice-wave-played').trim() || '#53bdeb';
            const baseUnplayed = styles.getPropertyValue('--voice-wave-unplayed').trim() || 'rgba(0, 0, 0, 0.15)';
            return {
                played: basePlayed,
                unplayed: baseUnplayed
            };
        }
        
        function getWaveProgress() {
            const duration = audio.duration;
            if (!isFinite(duration) || duration <= 0) return 0;
            return Math.max(0, Math.min(1, audio.currentTime / duration));
        }
        
        function drawWaveformBars(getValue) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            ctx.clearRect(0, 0, width, height);
            
            const isPlaying = !audio.paused && !audio.ended;
            const colors = getWaveColors(isPlaying);
            const progress = getWaveProgress();
            const barWidth = 2;
            const barGap = 2;
            const totalWidth = (barWidth + barGap) * waveformBars;
            const startX = Math.max(0, (width - totalWidth) / 2);
            
            for (let i = 0; i < waveformBars; i++) {
                const value = Math.max(0.12, getValue(i));
                const barHeight = Math.max(3, value * height * 0.85);
                const x = startX + i * (barWidth + barGap);
                const y = (height - barHeight) / 2;
                const isPlayed = (i + 1) / waveformBars <= progress;
                
                ctx.fillStyle = isPlayed ? colors.played : colors.unplayed;
                ctx.beginPath();
                ctx.roundRect(x, y, barWidth, barHeight, 1);
                ctx.fill();
            }
        }
        
        function renderWaveformFrame() {
            if (analyser && dataArray && !audio.paused && !audio.ended) {
                analyser.getByteFrequencyData(dataArray);
                drawWaveformBars((i) => {
                    const dataIndex = Math.floor((i / waveformBars) * dataArray.length);
                    return Math.max(0.15, dataArray[dataIndex] / 255);
                });
                return;
            }
            
            if (!waveformData) {
                waveformData = generateWaveformData();
            }
            drawWaveformBars((i) => waveformData[i]);
        }
        
        function startWaveformAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            const tick = () => {
                renderWaveformFrame();
                if (!audio.paused && !audio.ended) {
                    animationFrameId = requestAnimationFrame(tick);
                } else {
                    animationFrameId = null;
                }
            };
            tick();
        }
        
        function initWaveform() {
            waveformData = generateWaveformData();
            renderWaveformFrame();
        }
        
        // Инициализация Web Audio API для реальной визуализации
        async function initRealWaveform() {
            try {
                if (!window.AudioContext && !window.webkitAudioContext) {
                    return;
                }
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                
                source = audioContext.createMediaElementSource(audio);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                if (!waveformData) {
                    waveformData = generateWaveformData();
                }
                renderWaveformFrame();
            } catch (error) {
                console.error('Error initializing audio visualization:', error);
                audioContext = null;
                analyser = null;
                source = null;
                dataArray = null;
            }
        }
        
        // Загружаем метаданные для получения длительности
        audio.addEventListener('loadedmetadata', () => {
            applyVoicePlaybackRate(audio, voicePlaybackRate);
            const duration = audio.duration;
            if (isFinite(duration) && duration > 0) {
                const minutes = Math.floor(duration / 60);
                const seconds = Math.floor(duration % 60);
                durationSpan.textContent = `${minutes}:${String(seconds).padStart(2, '0')}`;
            }
        });
        
        // Обновляем время во время воспроизведения
        audio.addEventListener('timeupdate', () => {
            const current = audio.currentTime;
            const duration = audio.duration;
            if (isFinite(current) && isFinite(duration) && duration > 0) {
                const minutes = Math.floor(current / 60);
                const seconds = Math.floor(current % 60);
                durationSpan.textContent = `${minutes}:${String(seconds).padStart(2, '0')}`;
            }
        });

        audio.addEventListener('play', () => {
            startWaveformAnimation();
        });

        audio.addEventListener('pause', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            renderWaveformFrame();
        });
        
        // Обработчик воспроизведения/паузы
        playBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            
            try {
                if (audio.paused) {
                    // Восстанавливаем контекст аудио, если он был приостановлен
                    if (audioContext && audioContext.state === 'suspended') {
                        await audioContext.resume();
                    }
                    
                    applyVoicePlaybackRate(audio, voicePlaybackRate);
                    await audio.play();
                    playBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none"><rect x="4" y="2" width="3" height="12" fill="white"/><rect x="9" y="2" width="3" height="12" fill="white"/></svg>';
                    playBtn.setAttribute('aria-label', 'Пауза');
                    
                    // Инициализируем реальную визуализацию при первом воспроизведении
                    if (!audioContext) {
                        initRealWaveform();
                    }
                } else {
                    audio.pause();
                    playBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M3 2L13 8L3 14V2Z" fill="white"/></svg>';
                    playBtn.setAttribute('aria-label', 'Воспроизвести');
                }
            } catch (error) {
                console.error('Error playing audio:', error);
                notifications.error('Ошибка воспроизведения аудио');
            }
        });
        
        audio.addEventListener('ended', () => {
            playBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M3 2L13 8L3 14V2Z" fill="white"/></svg>';
            playBtn.setAttribute('aria-label', 'Воспроизвести');
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            renderWaveformFrame();
        });
        
        // Обработка ошибок загрузки
        audio.addEventListener('error', (e) => {
            console.error('Audio loading error:', e);
            notifications.error('Ошибка загрузки голосового сообщения');
        });
        
        // Очистка ресурсов при удалении сообщения
        const cleanup = () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close().catch(err => console.error('Error closing audio context:', err));
                audioContext = null;
            }
            if (source) {
                try {
                    source.disconnect();
                } catch (e) {
                    console.error('Error disconnecting source:', e);
                }
                source = null;
            }
            analyser = null;
            audio.pause();
            audio.src = '';
            audio.load();
        };
        
        // Сохраняем функцию очистки в элементе для возможного использования в будущем
        voiceDiv.dataset.cleanup = 'true';
        voiceDiv._cleanup = cleanup;
        
        // Собираем все элементы
        const voicePlayer = document.createElement('div');
        voicePlayer.className = 'voice-player';
        voicePlayer.appendChild(playBtn);
        voicePlayer.appendChild(waveformContainer);
        voicePlayer.appendChild(voiceInfo);
        voicePlayer.appendChild(forwardBtn);
        
        voiceDiv.appendChild(voicePlayer);
        bubble.appendChild(voiceDiv);
        
        // Инициализируем статичную визуализацию
        initWaveform();
        }
    }

    const messageTime = document.createElement('div');
    messageTime.className = 'message-time';
    const timeText = document.createElement('span');
    timeText.className = 'message-time-text';
    timeText.textContent = time;
    messageTime.appendChild(timeText);

    if (isSent) {
        const statusEl = document.createElement('span');
        statusEl.className = 'message-status';
        applyMessageStatus(statusEl, resolveMessageStatus(msg, isSent));
        messageTime.appendChild(statusEl);
    }

    // Индикатор закрепления
    if (msg.is_pinned) {
        const pinIndicator = document.createElement('span');
        pinIndicator.className = 'message-pin-indicator';
        pinIndicator.innerHTML = (typeof appIcon === 'function' ? appIcon('bookmark') : '📌') + ' Закреплено';
        messageTime.appendChild(pinIndicator);
        messageDiv.classList.add('pinned');
    }

    bubble.appendChild(messageTime);
    messageDiv.appendChild(avatar);
    messageDiv.appendChild(bubble);
    applyMessageTtlData(messageDiv, msg);

    // Добавляем обработчик правой кнопки мыши
    messageDiv.addEventListener('contextmenu', (e) => handleRightClick(e, msg, messageDiv));

    const appendedToGroup = mediaGroupKey
        ? appendMessageToMediaGroup(messagesContainer, messageDiv, mediaGroupKey, isSent)
        : false;

    // КРИТИЧНО: Используем appendChild для добавления сообщения ВНИЗ (в конец контейнера)
    // Это гарантирует, что новые сообщения появляются снизу, а не сверху
    if (!appendedToGroup) {
        messagesContainer.appendChild(messageDiv);
    }

    if (!isSent) {
        if (msg.id) {
            sendDeliveryReceipt(msg.id);
            sendReadReceipt(msg.id);
        }
        markMessageReadLocal(msg.id, messageDiv);
    }

    // Прокрутка вниз, если нужно
    if (scrollToBottom) {
        // Используем двойной requestAnimationFrame для гарантированной прокрутки после рендеринга
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            });
        });
    }

    return messageDiv;
}

function reconcileTempMessage(tempId, serverMessage = {}) {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) return;

    const messageElement = tempId ? messagesContainer.querySelector(`[data-temp-id="${tempId}"]`) : null;
    const payload = {
        ...serverMessage,
        temp_id: tempId || serverMessage.temp_id,
        sent: serverMessage.sent !== undefined ? serverMessage.sent : true,
        status: serverMessage.status || 'sent'
    };

    if (!payload.time) {
        payload.time = formatServerTimeToLocal(serverMessage.created_at || serverMessage.time);
    }

    if (messageElement) {
        if (payload.id) {
            messageElement.dataset.messageId = payload.id;
            messageElement.id = `msg-${payload.id}`;
            // Удаляем возможные дубликаты с тем же реальным ID
            messagesContainer.querySelectorAll(`[data-message-id="${payload.id}"]`).forEach(el => {
                if (el !== messageElement) {
                    el.remove();
                }
            });
        }
        if (payload.temp_id) {
            messageElement.dataset.tempId = payload.temp_id;
        }
        messageElement.classList.add(payload.sent ? 'sent' : 'received');

        const timeEl = messageElement.querySelector('.message-time-text') || messageElement.querySelector('.message-time');
        if (timeEl && payload.time) {
            timeEl.textContent = payload.time;
        }
        const statusEl = messageElement.querySelector('.message-status');
        if (statusEl) {
            applyMessageStatus(statusEl, payload.status || 'sent');
        }
        applyMessageTtlData(messageElement, payload);
        if (payload.status === 'read' && payload.id) {
            markMessageReadLocal(payload.id, messageElement);
        }

        if (typeof payload.content === 'string') {
            const textEl = messageElement.querySelector('.message-text');
            if (textEl) {
                textEl.innerHTML = parseMentions(payload.content);
                textEl.querySelectorAll('.mention-link').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const username = link.dataset.username;
                        if (username) {
                            handleMentionClick(username);
                        }
                    });
                });
            }
        }
        return;
    }

    addMessageToUI(payload, true);
}

function setReplyToMessage(msg) {
    replyToMessage = msg;
    const replyPreview = document.getElementById('replyPreview');
    const replyPreviewText = document.getElementById('replyPreviewText');
    const replyPreviewLabel = document.querySelector('.reply-preview-label');
    
    // Показываем имя автора
    if (replyPreviewLabel) {
        const authorName = msg.sender_username || msg.sender_name || '';
        if (authorName) {
            replyPreviewLabel.textContent = authorName;
        } else if (msg.sender_id === currentUser?.id) {
            replyPreviewLabel.textContent = t('chat.you') || 'Вы';
        } else {
            replyPreviewLabel.textContent = t('chat.replyLabel') || 'Ответ на сообщение';
        }
    }
    
    replyPreviewText.textContent = formatMessagePreviewText(msg) || 'Сообщение';
    replyPreview.style.display = 'flex';
    
    // Фокус на поле ввода
    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.focus();
    }
}

// Прокрутка к сообщению по ID (для кликабельных reply)
function scrollToMessage(messageId) {
    if (!messageId) return;
    
    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) {
        messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // Подсветка сообщения
        messageElement.classList.add('message-highlight');
        setTimeout(() => {
            messageElement.classList.remove('message-highlight');
        }, 2000);
    }
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

let searchTimeout = null;
let searchResults = [];

async function filterChats(query) {
    const lowerQuery = query.toLowerCase().trim();
    const chatsList = document.getElementById('chatsList');
    if (!chatsList) return;
    
    // Очищаем предыдущий таймер
    if (searchTimeout) {
        clearTimeout(searchTimeout);
    }
    
    // Если запрос пустой, показываем обычные чаты
    if (!lowerQuery) {
        renderChats();
        return;
    }
    
    // Фильтруем существующие чаты
    const filtered = getChatsForActiveFolder().filter(chat => 
        getChatSearchText(chat).includes(lowerQuery) ||
        (chat.lastMessage && chat.lastMessage.toLowerCase().includes(lowerQuery))
    );
    
    // Показываем отфильтрованные чаты
    if (filtered.length > 0) {
        const displayChats = sortChatsForDisplay(filtered);
        const fragment = document.createDocumentFragment();
        displayChats.forEach(chat => {
            const chatItem = createChatItem(chat);
            fragment.appendChild(chatItem);
        });
        chatsList.replaceChildren(fragment);
    } else {
        chatsList.replaceChildren();
    }
    applyActiveChatItem();
    
    // Ищем пользователей, если запрос похож на username (минимум 3 символа)
    if (lowerQuery.length >= 3) {
        searchTimeout = setTimeout(async () => {
            await searchUsersForChat(lowerQuery, filtered.length > 0);
        }, 500);
    }
}

async function searchUsersForChat(query, hasFilteredChats) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return;
    
    try {
        // Используем правильный API для поиска пользователя
        const response = await fetch(API_BASE + '/api/find-user', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ token, username: query })
        });
        
        const data = await response.json();
        const chatsList = document.getElementById('chatsList');
        
        // Удаляем старый результат поиска
        const oldSearchItem = chatsList.querySelector('.search-user-item');
        if (oldSearchItem) {
            oldSearchItem.remove();
        }
        
        if (data.success && data.user_id) {
            // Пользователь найден, проверяем, не друг ли он уже
            const isFriend = friends.some(f => f.id === data.user_id || f.username.toLowerCase() === query.toLowerCase());
            const isCurrentUser = currentUser?.username?.toLowerCase() === query.toLowerCase();
            const isPremiumUser = data.is_premium === true || data.is_premium === 'true';
            
            if (!isCurrentUser) {
                // Создаем элемент для начала чата с пользователем
                const userItem = document.createElement('div');
                userItem.className = 'chat-item search-user-item';
                userItem.dataset.chatId = data.user_id;
                userItem.style.borderLeft = '3px solid #10b981';
                userItem.style.background = 'rgba(16, 185, 129, 0.1)';
                
                const avatar = document.createElement('div');
                avatar.className = 'chat-avatar';
                avatar.textContent = query.charAt(0).toUpperCase();
                avatar.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                
                const info = document.createElement('div');
                info.className = 'chat-info';
                
                const headerRow = document.createElement('div');
                headerRow.className = 'chat-header-row';
                
                const name = document.createElement('div');
                name.className = 'chat-name';
                const nameText = document.createElement('span');
                nameText.className = 'chat-name-text';
                nameText.textContent = query;
                nameText.style.color = '#10b981';
                name.appendChild(nameText);
                if (isPremiumUser) {
                    name.appendChild(createPremiumBadge());
                }
                
                const badge = document.createElement('span');
                badge.textContent = isFriend ? '✓ Друг' : 'Написать';
                badge.style.fontSize = '0.75rem';
                badge.style.color = isFriend ? '#10b981' : '#10b981';
                badge.style.marginLeft = '0.5rem';
                badge.style.fontWeight = '600';
                
                headerRow.appendChild(name);
                headerRow.appendChild(badge);
                
                const preview = document.createElement('div');
                preview.className = 'chat-preview';
                preview.style.display = 'flex';
                preview.style.alignItems = 'center';
                preview.style.gap = '0.5rem';
                
                const previewText = document.createElement('span');
                previewText.className = 'chat-preview-text';
                previewText.textContent = isFriend ? 'Нажмите, чтобы открыть чат' : 'Нажмите, чтобы начать общение';
                previewText.style.color = 'var(--text-secondary)';
                
                // Кнопка добавления в друзья, если не друг
                preview.appendChild(previewText);

                if (!isFriend) {
                    const addBtn = document.createElement('button');
                    addBtn.className = 'btn-primary btn-small';
                    addBtn.textContent = '+ Добавить';
                    addBtn.style.padding = '0.25rem 0.75rem';
                    addBtn.style.fontSize = '0.75rem';
                    addBtn.onclick = (e) => {
                        e.stopPropagation();
                        sendFriendRequest(query);
                    };
                    preview.appendChild(addBtn);
                }
                
                info.appendChild(headerRow);
                info.appendChild(preview);
                
                userItem.appendChild(avatar);
                userItem.appendChild(info);
                
                // Обработчик клика - открываем чат с пользователем
                userItem.addEventListener('click', () => {
                    openChatWithUser(query, isFriend, data.user_id, isPremiumUser);
                });
                
                // Добавляем в начало списка
                if (chatsList.firstChild) {
                    chatsList.insertBefore(userItem, chatsList.firstChild);
                } else {
                    chatsList.appendChild(userItem);
                }
            }
        } else {
            // Пользователь не найден - удаляем старый результат
            const oldSearchItem = chatsList.querySelector('.search-user-item');
            if (oldSearchItem) {
                oldSearchItem.remove();
            }
        }
    } catch (error) {
        console.error('Search users error:', error);
    }
}

async function openChatWithUser(username, isFriend, userId = null, isPremium = null) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return;
    
    try {
        let isPremiumUser = typeof isPremium === 'boolean' ? isPremium : false;
        if (userId) {
            const friend = friends.find(f => f.id === userId);
            if (friend) {
                isPremiumUser = friend.is_premium || false;
            }
        }
        // Если user_id не передан, получаем его
        if (!userId) {
            const findResponse = await fetch(API_BASE + '/api/find-user', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ token, username })
            });
            
            const findData = await findResponse.json();
            if (!findData.success || !findData.user_id) {
                notifications.error('Пользователь не найден');
                return;
            }
            userId = findData.user_id;
            isPremiumUser = findData.is_premium === true || findData.is_premium === 'true';
        }
        
        // Создаем объект чата
        const chat = {
            id: userId,
            name: username,
            avatar: username.charAt(0).toUpperCase(),
            lastMessage: '',
            time: '',
            unread: 0,
            online: true,
            isNotFriend: !isFriend,
            is_premium: isPremiumUser
        };
        
        // Открываем чат
        selectChat(chat);
        
        // Если не друг, показываем кнопку добавления в друзья в заголовке
        if (!isFriend) {
            showAddFriendButtonInChat(username);
        } else {
            // Убираем кнопку, если стал другом
            const addBtn = document.getElementById('addFriendInChatBtn');
            if (addBtn) {
                addBtn.remove();
            }
        }
    } catch (error) {
        console.error('Open chat error:', error);
        notifications.error('Ошибка открытия чата');
    }
}

// =========================
// Profile modal (Xipher-like)
// =========================
async function openUserProfile(params) {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications.error('Необходима авторизация');
        return;
    }

    const existing = document.getElementById('userProfileModal');
    if (existing) existing.remove();

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.id = 'userProfileModal';
    overlay.style.display = 'flex';
    overlay.innerHTML = `
        <div class="modal-content" style="max-width: 520px; width: 92%;">
            <div class="modal-header">
                <h2 style="margin:0;">Профиль</h2>
                <button class="close-btn" id="closeUserProfileModal">&times;</button>
            </div>
            <div class="modal-body">
                <div style="padding: 1rem; text-align:center; color: var(--text-secondary);">Загрузка...</div>
            </div>
        </div>
    `;
    document.body.appendChild(overlay);

    const close = () => overlay.remove();
    overlay.querySelector('#closeUserProfileModal')?.addEventListener('click', close);
    overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });

    try {
        const payload = { token };
        if (params?.user_id) payload.user_id = params.user_id;
        if (params?.username) payload.username = params.username;

        const res = await fetch(API_BASE + '/api/get-user-profile', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (!data.success || !data.user) {
            notifications.error(data.error || 'Не удалось загрузить профиль');
            close();
            return;
        }

        const u = data.user;
        const avatarUrl = u.avatar_url || '';
        const initials = (u.display_name || u.username || 'U').charAt(0).toUpperCase();
        const onlineText = u.is_online ? 'Онлайн' : (u.last_seen ? `Был(а) в сети: ${u.last_seen}` : 'Скрыто');

        const birth = (u.birth_day && u.birth_month)
            ? `${String(u.birth_day).padStart(2,'0')}.${String(u.birth_month).padStart(2,'0')}${u.birth_year ? '.' + u.birth_year : ''}`
            : '';
        const personalChannel = u.personal_channel && u.personal_channel.id ? u.personal_channel : null;
        const personalChannelTitle = personalChannel?.name || 'Канал';
        const personalChannelLink = personalChannel?.custom_link ? `@${personalChannel.custom_link}` : '';
        const businessHoursHtml = buildBusinessHoursSummary(u.business_hours);
        const canOpenPremium = u.is_self && !u.is_premium;
        const premiumBadgeHtml = u.is_premium
            ? `<span class="premium-badge premium-badge--large" title="${escapeHtml(t('premium.badge'))}" aria-label="${escapeHtml(t('premium.badge'))}">★</span>`
            : (canOpenPremium
                ? `<span class="premium-badge premium-badge--large premium-badge--cta" role="button" tabindex="0" data-action="open-premium" title="${escapeHtml(t('settings.premium.open'))}" aria-label="${escapeHtml(t('settings.premium.open'))}">★</span>`
                : '');

        const bodyEl = overlay.querySelector('.modal-body');
        bodyEl.innerHTML = `
            <div style="display:flex; gap:14px; align-items:center; margin-bottom: 12px;">
                <div style="width:64px;height:64px;border-radius:50%;background: var(--gradient-purple);display:flex;align-items:center;justify-content:center;overflow:hidden;flex:0 0 64px;">
                    ${avatarUrl ? `<img src="${avatarUrl}" style="width:100%;height:100%;object-fit:cover;" onerror="this.remove();">` : `<span style="font-weight:700; font-size:24px; color:#fff;">${escapeHtml(initials)}</span>`}
                </div>
                <div style="min-width:0; text-align:left;">
                    <div style="font-weight:800; font-size:18px; color: var(--text-primary); overflow:hidden; text-overflow:ellipsis; white-space:nowrap; display:flex; align-items:center; gap:0.4rem;">
                        <span class="chat-name-text">${escapeHtml(u.display_name || u.username)}</span>
                        ${premiumBadgeHtml}
                    </div>
                    <div style="color: var(--text-secondary); font-size: 13px;">@${escapeHtml(u.username || '')}</div>
                    <div style="color: var(--text-muted); font-size: 13px; margin-top: 4px;">${escapeHtml(onlineText)}</div>
                </div>
            </div>

            ${u.bio ? `<div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 12px; margin-bottom: 12px; text-align:left;">
                <div style="color: var(--text-secondary); font-size: 12px; font-weight:700; margin-bottom:6px;">О себе</div>
                <div style="white-space: pre-wrap; color: var(--text-primary);">${escapeHtml(u.bio)}</div>
            </div>` : ''}

            ${birth ? `<div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 12px; margin-bottom: 12px; text-align:left;">
                <div style="color: var(--text-secondary); font-size: 12px; font-weight:700; margin-bottom:6px;">Дата рождения</div>
                <div style="color: var(--text-primary);">${escapeHtml(birth)}</div>
            </div>` : ''}

            ${businessHoursHtml}

            ${personalChannel ? `<div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 12px; margin-bottom: 12px; text-align:left;">
                <div style="color: var(--text-secondary); font-size: 12px; font-weight:700; margin-bottom:6px;">Персональный канал</div>
                <div style="font-weight:700; color: var(--text-primary);">${escapeHtml(personalChannelTitle)}</div>
                ${personalChannelLink ? `<div style="color: var(--text-muted); font-size: 12px; margin-top: 4px;">${escapeHtml(personalChannelLink)}</div>` : ''}
                <button class="btn-secondary" id="profileChannelBtn" style="margin-top:10px;">Открыть канал</button>
            </div>` : ''}

            <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center; margin-top: 10px;">
                <button class="btn-primary" id="profileMsgBtn">Написать</button>
                ${u.is_self ? '' : `<button class="btn-secondary" id="profileAddFriendBtn">${u.is_friend ? '✓ В друзьях' : '+ Добавить в друзья'}</button>`}
                <button class="btn-secondary" id="profileCopyLinkBtn">Скопировать ссылку</button>
            </div>
        `;

        bodyEl.querySelector('#profileMsgBtn')?.addEventListener('click', () => {
            close();
            if (u.username) {
                openChatWithUser(u.username, !!u.is_friend, u.id, u.is_premium);
            }
        });

        const premiumCta = bodyEl.querySelector('[data-action="open-premium"]');
        if (premiumCta) {
            const openPremium = () => {
                close();
                openSettingsPanel('premium');
            };
            premiumCta.addEventListener('click', openPremium);
            premiumCta.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    openPremium();
                }
            });
        }

        bodyEl.querySelector('#profileAddFriendBtn')?.addEventListener('click', async () => {
            if (u.is_friend) return;
            if (!u.username) return;
            try {
                await sendFriendRequest(u.username);
            } catch (_) {}
        });

        bodyEl.querySelector('#profileCopyLinkBtn')?.addEventListener('click', async () => {
            const link = `${window.location.origin}/@${u.username}`;
            try {
                await navigator.clipboard.writeText(link);
                notifications.success('Ссылка скопирована');
            } catch (e) {
                notifications.info(link);
            }
        });

        bodyEl.querySelector('#profileChannelBtn')?.addEventListener('click', () => {
            if (!personalChannel?.id) return;
            close();
            openChannelById(personalChannel.id);
        });
    } catch (err) {
        console.error('openUserProfile error', err);
        notifications.error('Ошибка загрузки профиля');
        close();
    }
}

window.openUserProfile = openUserProfile;

function showAddFriendButtonInChat(username) {
    const chatActions = document.querySelector('.chat-actions');
    if (!chatActions) return;
    
    // Удаляем старую кнопку, если есть
    const oldBtn = document.getElementById('addFriendInChatBtn');
    if (oldBtn) {
        oldBtn.remove();
    }
    
    // Создаем кнопку добавления в друзья
    const addFriendBtn = document.createElement('button');
    addFriendBtn.id = 'addFriendInChatBtn';
    addFriendBtn.className = 'chat-action-btn';
    addFriendBtn.title = 'Добавить в друзья';
    addFriendBtn.innerHTML = typeof appIcon === 'function' ? appIcon('userAdd') : '👤+';
    addFriendBtn.onclick = () => {
        sendFriendRequest(username);
    };
    
    chatActions.insertBefore(addFriendBtn, chatActions.firstChild);
}

// Tabs functionality
function setupTabs() {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const tabName = tab.dataset.tab;
            
            // Update active tab
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            // Show/hide sections
            document.getElementById('chatsList').style.display = 'none';
            document.getElementById('friendsList').style.display = 'none';
            document.getElementById('requestsList').style.display = 'none';
            document.getElementById('chatsSearchSection').style.display = 'none';
            
            if (tabName === 'chats') {
                document.getElementById('chatsList').style.display = 'block';
                document.getElementById('chatsSearchSection').style.display = 'block';
            } else if (tabName === 'friends') {
                document.getElementById('friendsList').style.display = 'block';
                loadFriends();
            } else if (tabName === 'requests') {
                document.getElementById('requestsList').style.display = 'block';
                loadFriendRequests();
            }
        });
    });
}

// Add friend functionality
function setupAddFriend() {
    // Убрали кнопки добавления - все через поиск

    const closeBtn = document.getElementById('closeModal');
    const searchBtn = document.getElementById('searchFriendBtn');
    const searchInput = document.getElementById('friendSearchInput');
    
    closeBtn.addEventListener('click', () => {
        document.getElementById('addFriendModal').style.display = 'none';
        searchInput.value = '';
        document.getElementById('searchResults').innerHTML = '';
    });
    
    // Закрытие по клику на overlay
    document.getElementById('addFriendModal').addEventListener('click', (e) => {
        if (e.target.id === 'addFriendModal') {
            document.getElementById('addFriendModal').style.display = 'none';
            searchInput.value = '';
            document.getElementById('searchResults').innerHTML = '';
        }
    });
    
    searchBtn.addEventListener('click', searchUser);
    searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            searchUser();
        }
    });
}

async function searchUser() {
    const username = document.getElementById('friendSearchInput').value.trim();
    const resultsDiv = document.getElementById('searchResults');
    
    if (!username) {
        notifications.warning('Введите username');
        return;
    }
    
    resultsDiv.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-secondary);">Поиск...</div>';
    
    try {
        const token = localStorage.getItem('xipher_token');
        
        // Ищем и пользователя, и канал одновременно
        const [userResponse, channelResponse] = await Promise.all([
            fetch(API_BASE + '/api/check-username', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username })
            }),
            fetch('/api/search-channel', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ custom_link: username })
            })
        ]);
        
        const userData = await userResponse.json();
        let channelData;
        try {
            channelData = await channelResponse.json();
        } catch (e) {
            // Если канал не найден, это нормально
            channelData = { success: false };
        }
        
        resultsDiv.innerHTML = ''; // Очищаем безопасно
        
        let hasResults = false;
        
        // Показываем канал, если найден
        if (channelData.success && channelData.channel) {
            hasResults = true;
            const channel = channelData.channel;
            
            const resultItem = document.createElement('div');
            resultItem.className = 'search-result-item';
            
            const avatar = document.createElement('div');
            avatar.className = 'search-result-avatar';
            avatar.style.background = 'var(--gradient-purple)';
            avatar.innerHTML = typeof appIcon === 'function' 
                ? appIcon(channel.is_private ? 'channelPrivate' : 'channel', 'app-icon-lg') 
                : (channel.is_private ? '🔒' : '📢');
            
            const info = document.createElement('div');
            info.className = 'search-result-info';
            info.style.flex = '1';
            
            const h4 = document.createElement('h4');
            h4.textContent = channel.name;
            
            const p = document.createElement('p');
            p.textContent = channel.custom_link ? '@' + channel.custom_link : 'Канал';
            p.style.color = 'var(--text-secondary)';
            p.style.fontSize = '0.85rem';
            
            if (channel.description) {
                const desc = document.createElement('p');
                desc.textContent = channel.description;
                desc.style.color = 'var(--text-muted)';
                desc.style.fontSize = '0.8rem';
                desc.style.marginTop = '0.25rem';
                info.appendChild(desc);
            }
            
            info.appendChild(h4);
            info.appendChild(p);
            
            const actions = document.createElement('div');
            actions.className = 'search-result-actions';
            
            const button = document.createElement('button');
            button.className = 'btn-primary btn-small';
            button.textContent = 'Открыть';
            button.addEventListener('click', async () => {
                // Переходим на канал
                if (window.channelsModule) {
                    await window.channelsModule.loadChannels();
                    const channelsList = window.channelsModule.channels();
                    const foundChannel = channelsList?.find(c => c.id === channel.id);
                    if (foundChannel) {
                        window.channelsModule.selectChannel(foundChannel);
                        // Переключаемся на вкладку каналов
                        const channelsTab = document.querySelector('[data-tab="channels"]');
                        if (channelsTab) {
                            channelsTab.click();
                        }
                        document.getElementById('addFriendModal').style.display = 'none';
                    } else {
                        // Если канал не найден в списке, подписываемся
                        await subscribeToChannel(channel.id);
                    }
                }
            });
            
            actions.appendChild(button);
            
            resultItem.appendChild(avatar);
            resultItem.appendChild(info);
            resultItem.appendChild(actions);
            
            resultsDiv.appendChild(resultItem);
        }
        
        // Показываем пользователя, если найден
        if (userData.success) {
            hasResults = true;
            
            const resultItem = document.createElement('div');
            resultItem.className = 'search-result-item';
            
            const avatar = document.createElement('div');
            avatar.className = 'search-result-avatar';
            avatar.textContent = username.charAt(0).toUpperCase();
            
            const info = document.createElement('div');
            info.className = 'search-result-info';
            
            const h4 = document.createElement('h4');
            h4.textContent = username;
            
            const p = document.createElement('p');
            p.textContent = 'Пользователь';
            p.style.color = 'var(--text-secondary)';
            p.style.fontSize = '0.85rem';
            
            info.appendChild(h4);
            info.appendChild(p);
            
            const actions = document.createElement('div');
            actions.className = 'search-result-actions';
            
            const button = document.createElement('button');
            button.className = 'btn-primary btn-small';
            button.textContent = 'Добавить';
            button.addEventListener('click', () => {
                sendFriendRequest(username);
            });
            
            actions.appendChild(button);
            
            resultItem.appendChild(avatar);
            resultItem.appendChild(info);
            resultItem.appendChild(actions);
            
            resultsDiv.appendChild(resultItem);
        }
        
        if (!hasResults) {
            const notFound = document.createElement('div');
            notFound.style.cssText = 'padding: 1rem; text-align: center; color: var(--text-secondary);';
            notFound.textContent = 'Пользователь или канал не найдены';
            resultsDiv.appendChild(notFound);
        }
    } catch (error) {
        console.error('Search error:', error);
        notifications.error('Ошибка поиска');
    }
}

async function subscribeToChannel(channelId) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return;
    
    try {
        const response = await fetch('/api/subscribe-channel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, channel_id: channelId })
        });
        
        const data = await response.json();
        if (data.success) {
            const msg = (data.message || '').toLowerCase();
            const requested = msg.includes('request');
            notifications.success(requested ? 'Заявка отправлена' : 'Подписка на канал успешна');
            if (!requested && window.channelsModule) {
                await window.channelsModule.loadChannels();
                const channelsList = window.channelsModule.channels();
                const channel = channelsList?.find(c => c.id === channelId);
                if (channel) {
                    window.channelsModule.selectChannel(channel);
                }
            }
        } else {
            notifications.error(data.error || 'Ошибка подписки на канал');
        }
    } catch (error) {
        console.error('Subscribe error:', error);
        notifications.error('Ошибка подписки на канал');
    }
}

async function sendFriendRequest(username) {
    const token = localStorage.getItem('xipher_token');
    
    if (!token) {
        notifications.error('Необходима авторизация');
        window.location.href = '/login';
        return;
    }
    
    
    try {
        const response = await fetch('/api/friend-request', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ token, username })
        });
        
        const data = await response.json();
        
        if (data.success) {
            notifications.success('Запрос в друзья отправлен');
            
            // Закрываем модальное окно, если открыто
            const modal = document.getElementById('addFriendModal');
            if (modal) {
                modal.style.display = 'none';
                document.getElementById('friendSearchInput').value = '';
                document.getElementById('searchResults').innerHTML = '';
            }
            
            // Удаляем кнопку добавления в друзья из чата, если есть
            const addFriendBtn = document.getElementById('addFriendInChatBtn');
            if (addFriendBtn) {
                addFriendBtn.remove();
            }
            
            // Обновляем список друзей и чатов
            loadFriends(); // Обновляем список друзей
            loadChats(); // Обновляем список чатов
            
            // Обновляем поиск, если открыт
            const searchInput = document.getElementById('chatSearch');
            if (searchInput && searchInput.value.trim().length >= 3) {
                filterChats(searchInput.value.trim());
            }
        } else {
            notifications.error(data.message || 'Ошибка отправки запроса');
        }
    } catch (error) {
        console.error('Send request error:', error);
        notifications.error('Ошибка отправки запроса');
    }
}

async function loadFriendRequests() {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        return;
    }

    try {
        const response = await fetch(API_BASE + '/api/friend-requests', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ token })
        });

        const data = await response.json();
        const requestsList = document.getElementById('requestsList');
        
        if (data.success && data.requests && data.requests.length > 0) {
            requestsList.innerHTML = '';
            data.requests.forEach(req => {
                const requestItem = createRequestItem(req);
                requestsList.appendChild(requestItem);
            });
        } else {
            requestsList.innerHTML = `
                <div style="padding: 2rem; text-align: center; color: var(--text-secondary);">
                    <p>Нет входящих запросов</p>
                </div>
            `;
        }
    } catch (error) {
        console.error('Error loading requests:', error);
    }
}

function createRequestItem(request) {
    const item = document.createElement('div');
    item.className = 'request-item';
    
    const avatar = document.createElement('div');
    avatar.className = 'request-avatar';
    avatar.textContent = request.sender_username.charAt(0).toUpperCase();
    
    const info = document.createElement('div');
    info.className = 'request-info';
    
    const name = document.createElement('h4');
    name.textContent = request.sender_username;
    
    const time = document.createElement('p');
    const reqDate = new Date(request.created_at);
    time.textContent = `Запрос отправлен ${reqDate.toLocaleDateString('ru-RU')}`;
    
    info.appendChild(name);
    info.appendChild(time);
    
    const actions = document.createElement('div');
    actions.className = 'request-actions';
    
    const acceptBtn = document.createElement('button');
    acceptBtn.className = 'btn-primary btn-small';
    acceptBtn.textContent = 'Принять';
    acceptBtn.onclick = () => acceptFriendRequest(request.id);
    
    const rejectBtn = document.createElement('button');
    rejectBtn.className = 'btn-secondary btn-small';
    rejectBtn.textContent = 'Отклонить';
    rejectBtn.onclick = () => rejectFriendRequest(request.id);
    
    actions.appendChild(acceptBtn);
    actions.appendChild(rejectBtn);
    
    item.appendChild(avatar);
    item.appendChild(info);
    item.appendChild(actions);
    
    return item;
}

async function acceptFriendRequest(requestId) {
    const token = localStorage.getItem('xipher_token');
    
    try {
        const response = await fetch(API_BASE + '/api/accept-friend', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ token, request_id: requestId })
        });
        
        const data = await response.json();
        
        if (data.success) {
            notifications.success('Запрос принят! Теперь вы друзья');
            loadFriendRequests();
            loadFriends(); // Обновляем список друзей
            loadChats(); // Обновляем список чатов
        } else {
            notifications.error(data.message || 'Ошибка принятия запроса');
        }
    } catch (error) {
        console.error('Accept request error:', error);
        notifications.error('Ошибка принятия запроса');
    }
}

async function rejectFriendRequest(requestId) {
    const token = localStorage.getItem('xipher_token');
    
    try {
        const response = await fetch(API_BASE + '/api/reject-friend', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ token, request_id: requestId })
        });
        
        const data = await response.json();
        
        if (data.success) {
            notifications.info('Запрос отклонен');
            loadFriendRequests();
        } else {
            notifications.error(data.message || 'Ошибка отклонения запроса');
        }
    } catch (error) {
        console.error('Reject request error:', error);
        notifications.error('Ошибка отклонения запроса');
    }
}

// Автоматическое обновление сообщений и чатов
let autoRefreshInterval = null;

// Функция для обновления активности пользователя
async function updateUserActivity() {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        return;
    }
    
    try {
        await fetch(API_BASE + '/api/update-activity', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ token })
        });
    } catch (error) {
        console.error('Error updating activity:', error);
        // Не показываем ошибку, чтобы не спамить уведомлениями
    }
}

// Запуск периодического обновления активности
function startActivityUpdate() {
    // Обновляем сразу при загрузке
    updateUserActivity();
    
    // Затем каждые 30 секунд
    activityUpdateInterval = setInterval(() => {
        updateUserActivity();
    }, 30000);
}

// Остановка обновления активности
function stopActivityUpdate() {
    if (activityUpdateInterval) {
        clearInterval(activityUpdateInterval);
        activityUpdateInterval = null;
    }
}

function startAutoRefresh() {
    // Обновляем каждые 2 секунды
    autoRefreshInterval = setInterval(() => {
        // Обновляем список чатов (все: чаты, группы, каналы)
        loadAllChats();
        syncPinnedChatsFromServer();
        syncChatFoldersFromServer();
        
        // Если есть активный чат, обновляем сообщения
        if (currentChat && currentChat.id) {
            checkNewMessages(currentChat.id);
        }
        
        // Если есть активная группа, проверяем новые сообщения
        if (window.currentGroup && window.currentGroup.id && typeof checkNewGroupMessages === 'function') {
            checkNewGroupMessages(window.currentGroup.id);
        }
    }, 2000);
}

function stopAutoRefresh() {
    if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
    }
}

async function checkNewMessages(chatId) {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        return;
    }

    try {
        const response = await fetch(API_BASE + '/api/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ token, friend_id: chatId })
        });

        const data = await response.json();
        
        if (data.success && data.messages && Array.isArray(data.messages)) {
            const messagesContainer = document.getElementById('chatMessages');
            const currentMessageIds = new Set();
            
            // Собираем ID всех текущих сообщений в UI
            messagesContainer.querySelectorAll('[data-message-id]').forEach(el => {
                const msgId = el.dataset.messageId;
                if (msgId) {
                    currentMessageIds.add(msgId);
                }
            });
            checklistSeenUpdateIds.forEach((msgId) => {
                currentMessageIds.add(String(msgId));
            });
            
            // Проверяем новые сообщения (те, которых нет в UI)
            // Сервер возвращает сообщения от новых к старым (DESC)
            // Нам нужно найти только новые сообщения и добавить их в правильном порядке
            const messages = Array.isArray(data.messages) ? data.messages : [];
            let hasNewMessages = false;
            const newMessages = [];
            
            // Собираем только новые сообщения (тех, которых нет в UI)
            // Сервер возвращает сообщения от новых к старым (DESC)
            messages.forEach(msg => {
                if (msg.id && !currentMessageIds.has(msg.id)) {
                    newMessages.push(msg);
                }
            });
            
            // Если есть новые сообщения, добавляем их в правильном порядке
            // Сервер вернул их от новых к старым (DESC), поэтому переворачиваем,
            // чтобы добавить от старых к новым (старые новые сначала, потом новые новые)
            // Это гарантирует, что сообщения добавляются вниз в правильном порядке
            if (newMessages.length > 0) {
                // Переворачиваем массив, чтобы старые новые сообщения добавлялись первыми
                // (они уже отсортированы от новых к старым, поэтому reverse() даст старые к новым)
                // Пример: сервер вернул [новое3, новое2, новое1] -> после reverse: [новое1, новое2, новое3]
                // Добавляем через appendChild: новое1 (старое из новых) -> новое2 -> новое3 (самое новое)
                const sortedMessages = [...newMessages].reverse();
                
                // Добавляем каждое сообщение вниз через appendChild
                // ВАЖНО: appendChild добавляет элемент в конец контейнера (вниз)
                sortedMessages.forEach(msg => {
                    const isUpdate = isChecklistUpdateContent(msg.content || '');
                    const added = addMessageToUI(msg, false); // Не прокручиваем для каждого отдельно
                    if (added || isUpdate) {
                        hasNewMessages = true;
                    }
                    if (!isUpdate && !isMessageFromCurrentUser(msg)) {
                        notifyIncomingMessageFromPayload(msg);
                    }
                });
                
                // Прокручиваем вниз один раз после добавления всех новых сообщений
                if (messagesContainer) {
                    // Используем двойной requestAnimationFrame для гарантированной прокрутки
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        });
                    });
                }
            }
            
            // Если были новые сообщения, обновляем список чатов
            if (hasNewMessages) {
                loadChats();
            }
        }
    } catch (error) {
        console.error('Error checking new messages:', error);
        // Не показываем ошибку, чтобы не спамить уведомлениями
    }
}

class ChatContextMenuManager {
    constructor() {
        this.menuEl = document.getElementById('chatContextMenu');
        if (!this.menuEl) {
            this.menuEl = document.createElement('div');
            this.menuEl.id = 'chatContextMenu';
            this.menuEl.className = 'message-context-menu';
            document.body.appendChild(this.menuEl);
        }
        this.currentChat = null;
        this.currentElement = null;
        this.outsideHandler = (event) => this.handleOutsideClick(event);
        this.menuEl.addEventListener('contextmenu', (event) => event.preventDefault());
    }

    static getInstance() {
        if (!ChatContextMenuManager.instance) {
            ChatContextMenuManager.instance = new ChatContextMenuManager();
        }
        return ChatContextMenuManager.instance;
    }

    open(event, chat, chatElement) {
        event.preventDefault();
        this.currentChat = chat;
        this.currentElement = chatElement;
        this.renderItems(chat);
        this.positionMenu(event);
        this.menuEl.style.display = 'block';
        document.addEventListener('click', this.outsideHandler, { capture: true });
    }

    close() {
        this.menuEl.style.display = 'none';
        document.removeEventListener('click', this.outsideHandler, { capture: true });
        this.currentChat = null;
        this.currentElement = null;
    }

    handleOutsideClick(event) {
        if (!this.menuEl.contains(event.target)) {
            this.close();
        }
    }

    renderItems(chat) {
        const pinned = isChatPinned(chat);
        const muted = isChatMuted(chat);
        const isDirect = (chat.type === 'chat' || !chat.type) && !chat.is_saved_messages;
        const items = [
            {
                id: 'pin',
                label: pinned ? 'Открепить' : 'Закрепить',
                iconName: 'bookmark',
                visible: true,
                action: () => setChatPinned(chat, !pinned)
            },
            {
                id: 'mute',
                label: muted ? 'Размьютить' : 'Замьютить',
                iconName: muted ? 'notification' : 'notificationOff',
                visible: true,
                action: () => setChatMuted(chat, !muted)
            },
            {
                id: 'folder',
                label: 'В папку',
                iconName: 'file',
                visible: true,
                action: () => openFolderAssignModal(chat)
            },
            {
                id: 'delete',
                label: 'Удалить чат',
                iconName: 'delete',
                visible: isDirect,
                danger: true,
                action: () => openDeleteChatModal(chat)
            }
        ];

        this.menuEl.innerHTML = '';
        items.filter(item => item.visible).forEach(item => {
            const row = document.createElement('div');
            row.className = item.danger ? 'context-menu-item is-danger' : 'context-menu-item';
            row.dataset.action = item.id;
            const iconHtml = typeof appIcon === 'function' ? appIcon(item.iconName) : item.iconName;
            row.innerHTML = `<span>${iconHtml}</span><span>${item.label}</span>`;
            row.addEventListener('click', () => {
                item.action();
                this.close();
            });
            this.menuEl.appendChild(row);
        });
    }

    positionMenu(event) {
        const { clientX, clientY } = event;
        this.menuEl.style.visibility = 'hidden';
        this.menuEl.style.display = 'block';

        const menuRect = this.menuEl.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        let x = clientX;
        let y = clientY;

        if (x + menuRect.width > viewportWidth) {
            x = Math.max(8, viewportWidth - menuRect.width - 8);
        }
        if (y + menuRect.height > viewportHeight) {
            y = Math.max(8, viewportHeight - menuRect.height - 8);
        }

        this.menuEl.style.left = `${x}px`;
        this.menuEl.style.top = `${y}px`;
        this.menuEl.style.visibility = 'visible';
    }
}

class ContextMenuManager {
    constructor() {
        this.menuEl = document.getElementById('messageContextMenu');
        if (!this.menuEl) {
            this.menuEl = document.createElement('div');
            this.menuEl.id = 'messageContextMenu';
            this.menuEl.className = 'message-context-menu';
            document.body.appendChild(this.menuEl);
        }
        this.currentMessage = null;
        this.currentElement = null;
        this.outsideHandler = (event) => this.handleOutsideClick(event);
        // Блокируем стандартное контекстное меню внутри нашего меню
        this.menuEl.addEventListener('contextmenu', (event) => event.preventDefault());
    }

    static getInstance() {
        if (!ContextMenuManager.instance) {
            ContextMenuManager.instance = new ContextMenuManager();
        }
        return ContextMenuManager.instance;
    }

    open(event, message, messageElement) {
        event.preventDefault();
        this.currentMessage = message;
        this.currentElement = messageElement;
        this.renderItems(message);
        this.positionMenu(event);
        this.menuEl.style.display = 'block';
        document.addEventListener('click', this.outsideHandler, { capture: true });
    }

    close() {
        this.menuEl.style.display = 'none';
        document.removeEventListener('click', this.outsideHandler, { capture: true });
        this.currentMessage = null;
        this.currentElement = null;
    }

    handleOutsideClick(event) {
        if (!this.menuEl.contains(event.target)) {
            this.close();
        }
    }

    getPermissions(message) {
        const currentUserId = localStorage.getItem('xipher_user_id');
        const currentUsername = localStorage.getItem('xipher_username');
        const isOwn = Boolean(
            isMessageFromCurrentUser(message) ||
            (message.sender_username && message.sender_username === currentUsername)
        );

        let isAdmin = false;
        // Канал
        try {
            if (window.channelsModule && window.channelsModule.isChannelActive && window.channelsModule.isChannelActive()) {
                if (typeof currentChannelInfo !== 'undefined' && currentChannelInfo && currentChannelInfo.is_admin) {
                    isAdmin = true;
                }
            }
        } catch (err) {
            console.warn('Channel admin detection failed', err);
        }

        // Группа (пока считаем админом только создателя)
        try {
            if (!isAdmin && window.groupsModule && window.groupsModule.isGroupActive && window.groupsModule.isGroupActive()) {
                const activeGroup = window.groupsModule.currentGroup ? window.groupsModule.currentGroup() : null;
                if (activeGroup && activeGroup.creator_id && currentUserId && activeGroup.creator_id === currentUserId) {
                    isAdmin = true;
                }
            }
        } catch (err) {
            console.warn('Group admin detection failed', err);
        }

        return {
            isOwn,
            isAdmin,
            canPin: isAdmin,
            canDelete: isOwn || isAdmin
        };
    }

    async copyToClipboard(text) {
        if (!text) return;
        try {
            await navigator.clipboard.writeText(text);
            notifications.success('Скопировано в буфер обмена');
        } catch (err) {
            // Fallback
            const area = document.createElement('textarea');
            area.value = text;
            area.style.position = 'fixed';
            area.style.left = '-9999px';
            document.body.appendChild(area);
            area.focus();
            area.select();
            try {
                document.execCommand('copy');
                notifications.success('Скопировано в буфер обмена');
            } catch (copyErr) {
                console.error('Clipboard fallback failed', copyErr);
                notifications.error('Не удалось скопировать текст');
            } finally {
                document.body.removeChild(area);
            }
        }
    }

    renderItems(message) {
        const permissions = this.getPermissions(message);
        const items = [
            {
                id: 'reply',
                label: 'Ответить',
                iconName: 'chat',
                visible: true,
                action: () => setReplyToMessage(message)
            },
            {
                id: 'forward',
                label: 'Переслать',
                iconName: 'arrowForward',
                visible: true,
                action: () => showForwardMessageModal(message)
            },
            {
                id: 'copy',
                label: 'Скопировать',
                iconName: 'copy',
                visible: Boolean(message.content),
                action: () => this.copyToClipboard(message.content || '')
            },
            {
                id: 'report',
                label: 'Пожаловаться',
                iconName: 'warning',
                // Показываем всегда, даже на свои (юзеру видимая жалоба)
                visible: true,
                action: () => openReportModal(message)
            },
            {
                id: 'pin',
                label: message.is_pinned ? 'Открепить' : 'Закрепить',
                iconName: 'bookmark',
                visible: permissions.canPin,
                action: () => {
                    const mid = message.id || message.message_id || message.temp_id;
                    if (!mid) return;
                    if (message.is_pinned) {
                        unpinMessage(mid).then((ok) => {
                            if (ok) message.is_pinned = false;
                        });
                    } else {
                        pinMessage(mid).then((ok) => {
                            if (ok) message.is_pinned = true;
                        });
                    }
                }
            },
            {
                id: 'delete',
                label: 'Удалить',
                iconName: 'delete',
                visible: permissions.canDelete,
                action: () => {
                    const confirmed = confirm('Удалить сообщение?');
                    if (confirmed) {
                        const mid = message.id || message.message_id || message.temp_id;
                        const el = this.currentElement;
                        deleteMessage(mid).then((ok) => {
                            if (ok && el) el.remove();
                        });
                    }
                }
            }
        ];

        this.menuEl.innerHTML = '';
        items.filter(item => item.visible).forEach(item => {
            const row = document.createElement('div');
            row.className = 'context-menu-item';
            row.dataset.action = item.id;
            const iconHtml = typeof appIcon === 'function' ? appIcon(item.iconName) : item.iconName;
            row.innerHTML = `<span>${iconHtml}</span><span>${item.label}</span>`;
            row.addEventListener('click', () => {
                item.action();
                this.close();
            });
            this.menuEl.appendChild(row);
        });
    }

    positionMenu(event) {
        const { clientX, clientY } = event;
        // Предварительно показываем меню для получения размеров
        this.menuEl.style.visibility = 'hidden';
        this.menuEl.style.display = 'block';

        const menuRect = this.menuEl.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        let x = clientX;
        let y = clientY;

        if (x + menuRect.width > viewportWidth) {
            x = Math.max(8, viewportWidth - menuRect.width - 8);
        }
        if (y + menuRect.height > viewportHeight) {
            y = Math.max(8, viewportHeight - menuRect.height - 8);
        }

        this.menuEl.style.left = `${x}px`;
        this.menuEl.style.top = `${y}px`;
        this.menuEl.style.visibility = 'visible';
    }
}

const contextMenuManager = ContextMenuManager.getInstance();

function handleRightClick(event, message, messageElement) {
    contextMenuManager.open(event, message, messageElement);
}

function openReportModal(message) {
    const modal = document.getElementById('reportModal');
    if (!modal) return;
    reportTargetMessage = message;
    const preview = document.getElementById('reportMessagePreview');
    const contentPreview = (message && message.content) ? message.content.trim() : '[медиа/вложение]';
    if (preview) {
        const shortText = contentPreview.length > 180 ? contentPreview.slice(0, 180) + '…' : contentPreview;
        preview.textContent = `ID: ${message.id || message.message_id || '—'} · ${shortText}`;
    }
    const reason = document.getElementById('reportReason');
    const comment = document.getElementById('reportComment');
    if (reason) reason.value = 'spam';
    if (comment) comment.value = '';
    modal.style.display = 'flex';
}

function closeReportModal() {
    const modal = document.getElementById('reportModal');
    if (modal) {
        modal.style.display = 'none';
    }
    reportTargetMessage = null;
}

function openDeleteChatModal(chat) {
    const modal = document.getElementById('deleteChatModal');
    if (!modal || !chat || !chat.id) return;
    const displayName = getChatDisplayName(chat);
    pendingDeleteChat = {
        id: chat.id,
        type: chat.type || 'chat',
        name: displayName || ''
    };
    const subtitle = document.getElementById('deleteChatSubtitle');
    if (subtitle) {
        const label = pendingDeleteChat.name ? `«${pendingDeleteChat.name}»` : 'этот чат';
        subtitle.textContent = `Удалить чат ${label}?`;
    }
    modal.style.display = 'flex';
}

function closeDeleteChatModal() {
    const modal = document.getElementById('deleteChatModal');
    if (modal) {
        modal.style.display = 'none';
    }
    pendingDeleteChat = null;
}

async function deleteChatForAll(chat) {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications.error('Необходима авторизация');
        return;
    }
    try {
        const response = await fetch(API_BASE + '/api/delete-chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                token,
                chat_id: chat.id,
                chat_type: chat.type || 'chat'
            })
        });
        let data = null;
        try {
            data = await response.json();
        } catch (_) {}

        if (response.ok && data && data.success) {
            hideChatForMe(chat);
            notifications.success('Чат удалён у всех');
            closeDeleteChatModal();
            return;
        }
        notifications.error((data && data.message) ? data.message : 'Не удалось удалить чат у всех');
    } catch (error) {
        console.error('Delete chat error:', error);
        notifications.error('Ошибка удаления чата');
    }
}

async function submitReport() {
    if (!reportTargetMessage) {
        notifications.error('Не выбрано сообщение');
        return;
    }
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications.error('Необходима авторизация');
        return;
    }

    const reasonEl = document.getElementById('reportReason');
    const commentEl = document.getElementById('reportComment');
    const reason = reasonEl ? reasonEl.value : 'spam';
    const comment = commentEl ? commentEl.value.trim() : '';
    const messageContent = reportTargetMessage.content || reportTargetMessage.text || '[медиа]';
    const reportedUserId = reportTargetMessage.sender_id || reportTargetMessage.user_id || reportTargetMessage.sender || reportTargetMessage.author_id || '';

    const payload = {
        token,
        message_id: reportTargetMessage.id || reportTargetMessage.message_id || reportTargetMessage.temp_id,
        reported_user_id: reportedUserId,
        message_content: messageContent,
        reason,
        comment
    };

    try {
        const res = await fetch(API_BASE + '/api/reports', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (data.success) {
            notifications.success('Жалоба отправлена');
            closeReportModal();
        } else {
            notifications.error(data.error || 'Не удалось отправить жалобу');
        }
    } catch (err) {
        console.error(err);
        notifications.error('Сеть недоступна, попробуйте позже');
    }
}

// Показать пикер реакций
function showReactionPicker(messageId) {
    const modal = document.getElementById('reactionPickerModal');
    const grid = document.getElementById('reactionGrid');
    if (!modal || !grid) return;

    // Популярные реакции
    const reactions = ['👍', '❤️', '😂', '😮', '😢', '🔥', '👏', '🎉', '💯', '✅', '❌', '⭐', '💪', '🙏', '👎', '😍', '🤔', '😴', '🤯', '🥳', '😎', '🤗', '🤝', '💔', '😡', '🤢', '🤮', '💀', '👻', '🤖'];

    grid.innerHTML = '';
    reactions.forEach(reaction => {
        const item = document.createElement('div');
        item.className = 'reaction-item';
        item.textContent = reaction;
        item.addEventListener('click', () => {
            addReactionToMessage(messageId, reaction);
            modal.style.display = 'none';
        });
        grid.appendChild(item);
    });

    modal.style.display = 'flex';

    // Закрытие модального окна
    const closeBtn = document.getElementById('closeReactionPickerModal');
    if (closeBtn) {
        closeBtn.onclick = () => {
            modal.style.display = 'none';
        };
    }

    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    });
}

// Добавить реакцию к сообщению
async function addReactionToMessage(messageId, reaction) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return;

    try {
        const response = await fetch('/api/add-message-reaction', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                token,
                message_id: messageId,
                reaction
            })
        });

        const data = await response.json();
        if (data.success) {
            notifications.success('Реакция добавлена');
            // Обновляем отображение реакций
            if (window.channelsModule && window.channelsModule.isChannelActive()) {
                if (typeof loadMessageReactions === 'function') {
                    loadMessageReactions(messageId);
                }
            }
        } else {
            notifications.error(data.error || 'Ошибка при добавлении реакции');
        }
    } catch (error) {
        console.error('Error adding reaction:', error);
        notifications.error('Ошибка при добавлении реакции');
    }
}

// Закрепить сообщение
async function pinMessage(messageId) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return false;

    let endpoint = '/api/pin-message';
    const body = { token, message_id: messageId };

    if (window.groupsModule && window.groupsModule.isGroupActive()) {
        const group = window.groupsModule.currentGroup();
        if (group) {
            body.group_id = group.id;
        }
    } else if (window.channelsModule && window.channelsModule.isChannelActive()) {
        const channel = window.channelsModule.currentChannel();
        if (channel) {
            body.channel_id = channel.id;
        }
    }

    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });

        const data = await response.json();
        if (data.success) {
            notifications.success('Сообщение закреплено');
            updatePinnedState(messageId, true);
            return true;
        }
        notifications.error(data.error || 'Ошибка при закреплении сообщения');
        return false;
    } catch (error) {
        console.error('Error pinning message:', error);
        notifications.error('Ошибка при закреплении сообщения');
        return false;
    }
}

function setPinnedPreview(messageId, text = '') {
    const panel = document.getElementById('pinnedPanel');
    const textEl = document.getElementById('pinnedPanelText');
    if (!panel || !textEl) return;

    if (!messageId) {
        panel.dataset.messageId = '';
        textEl.textContent = 'Закреплённые сообщения появятся здесь';
        textEl.style.color = 'var(--text-secondary)';
        panel.style.opacity = '0.7';
        return;
    }

    panel.dataset.messageId = messageId;
    const resolved = formatMessagePreviewText(text);
    textEl.textContent = resolved && resolved.trim() ? resolved.trim() : '[медиа]';
    textEl.style.color = 'var(--text-primary)';
    panel.style.opacity = '1';
}

// Открепить сообщение
async function unpinMessage(messageId) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return false;

    let endpoint = '/api/unpin-message';
    const body = { token, message_id: messageId };

    if (window.groupsModule && window.groupsModule.isGroupActive()) {
        const group = window.groupsModule.currentGroup();
        if (group) {
            body.group_id = group.id;
        }
    } else if (window.channelsModule && window.channelsModule.isChannelActive()) {
        const channel = window.channelsModule.currentChannel();
        if (channel) {
            body.channel_id = channel.id;
        }
    }

    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });

        const data = await response.json();
        if (data.success) {
            notifications.success('Сообщение откреплено');
            updatePinnedState(messageId, false);
            return true;
        }
        notifications.error(data.error || 'Ошибка при откреплении сообщения');
        return false;
    } catch (error) {
        console.error('Error unpinning message:', error);
        notifications.error('Ошибка при откреплении сообщения');
        return false;
    }
}

function updatePinnedState(messageId, pinned) {
    const el = document.getElementById(`msg-${messageId}`) || document.querySelector(`[data-message-id="${messageId}"]`);
    if (!el) {
        if (pinned) {
            setPinnedPreview(messageId, '[медиа]');
        } else {
            setPinnedPreview(null);
        }
        return;
    }
    el.classList.toggle('pinned', pinned);
    const timeEl = el.querySelector('.message-time');
    if (timeEl) {
        let pin = timeEl.querySelector('.message-pin-indicator');
        if (pinned) {
            if (!pin) {
                pin = document.createElement('span');
                pin.className = 'message-pin-indicator';
                pin.innerHTML = (typeof appIcon === 'function' ? appIcon('bookmark') : '📌') + ' Закреплено';
                timeEl.appendChild(pin);
            }
        } else if (pin) {
            pin.remove();
        }
    }

    if (pinned) {
        const previewText = getMessagePreviewFromElement(el);
        setPinnedPreview(messageId, previewText || '[медиа]');
    } else {
        setPinnedPreview(null);
    }
}

// Удалить сообщение
async function deleteMessage(messageId) {
    const token = localStorage.getItem('xipher_token');
    if (!token) return false;

    // Определяем тип чата
    let endpoint = '/api/delete-message';
    let body = { token, message_id: messageId };

    if (window.groupsModule && window.groupsModule.isGroupActive()) {
        const group = window.groupsModule.currentGroup();
        if (group) {
            endpoint = '/api/delete-group-message';
            body.group_id = group.id;
        }
    } else if (window.channelsModule && window.channelsModule.isChannelActive()) {
        const channel = window.channelsModule.currentChannel();
        if (channel) {
            endpoint = '/api/delete-channel-message';
            body.channel_id = channel.id;
        }
    }

    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });

        const data = await response.json();
        if (data.success) {
            notifications.success('Сообщение удалено');
            // Удаляем сообщение из UI
            if (currentContextMessageElement) {
                currentContextMessageElement.remove();
                currentContextMessageElement = null;
            }
            clearMessageTtlTimer(messageId);
            return true;
        } else {
            notifications.error(data.error || 'Ошибка при удалении сообщения');
            return false;
        }
    } catch (error) {
        console.error('Error deleting message:', error);
        notifications.error('Ошибка при удалении сообщения');
        return false;
    }
}

// Показать модальное окно пересылки сообщения (минимальная рабочая версия: личный чат/группа/канал)
function showForwardMessageModal(msg) {
    const token = localStorage.getItem('xipher_token');
    if (!token) {
        notifications.error('Необходима авторизация');
        return;
    }

    const existing = document.getElementById('forwardMessageModal');
    if (existing) existing.remove();

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.id = 'forwardMessageModal';
    overlay.style.display = 'flex';

    const contentText = (msg && msg.content) ? msg.content : '';
    const shortPreview = contentText.length > 220 ? (contentText.slice(0, 220) + '…') : contentText;

    overlay.innerHTML = `
        <div class="modal-content" style="max-width: 520px; width: 92%;">
            <div class="modal-header">
                <h2 style="margin:0;">Переслать сообщение</h2>
                <button class="close-btn" id="closeForwardMessageModal">&times;</button>
            </div>
            <div class="modal-body">
                <div style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 0.75rem;">
                    ${escapeHtml(shortPreview || '[медиа/пусто]')}
                </div>

                <div style="display:flex; gap:0.5rem; margin-bottom: 0.75rem;">
                    <button class="btn-secondary" id="forwardTypeDirect">Личное</button>
                    <button class="btn-secondary" id="forwardTypeGroup">Группа</button>
                    <button class="btn-secondary" id="forwardTypeChannel">Канал</button>
                </div>

                <div id="forwardHint" style="color: var(--text-muted); font-size: 0.85rem; margin-bottom: 0.5rem;">
                    Введите username (без @) или user_id
                </div>
                <input class="modal-input" id="forwardTargetInput" placeholder="username или id" />

                <div class="modal-actions" style="margin-top: 1rem;">
                    <button class="btn-secondary" id="cancelForwardMessage">Отмена</button>
                    <button class="btn-primary" id="confirmForwardMessage">Переслать</button>
                </div>
            </div>
        </div>
    `;

    document.body.appendChild(overlay);

    let mode = 'direct';
    const setMode = (m) => {
        mode = m;
        const hint = overlay.querySelector('#forwardHint');
        const input = overlay.querySelector('#forwardTargetInput');
        const b1 = overlay.querySelector('#forwardTypeDirect');
        const b2 = overlay.querySelector('#forwardTypeGroup');
        const b3 = overlay.querySelector('#forwardTypeChannel');
        [b1, b2, b3].forEach(b => b && b.classList.remove('active'));
        if (m === 'direct') {
            b1 && b1.classList.add('active');
            if (hint) hint.textContent = 'Введите username (без @) или user_id';
            if (input) input.placeholder = 'username или user_id';
        } else if (m === 'group') {
            b2 && b2.classList.add('active');
            if (hint) hint.textContent = 'Введите group_id';
            if (input) input.placeholder = 'group_id';
        } else {
            b3 && b3.classList.add('active');
            if (hint) hint.textContent = 'Введите channel_id (UUID) или @username';
            if (input) input.placeholder = '@username или channel_id';
        }
    };
    setMode('direct');

    const close = () => overlay.remove();
    overlay.querySelector('#closeForwardMessageModal')?.addEventListener('click', close);
    overlay.querySelector('#cancelForwardMessage')?.addEventListener('click', close);
    overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });

    overlay.querySelector('#forwardTypeDirect')?.addEventListener('click', () => setMode('direct'));
    overlay.querySelector('#forwardTypeGroup')?.addEventListener('click', () => setMode('group'));
    overlay.querySelector('#forwardTypeChannel')?.addEventListener('click', () => setMode('channel'));

    overlay.querySelector('#confirmForwardMessage')?.addEventListener('click', async () => {
        const raw = (overlay.querySelector('#forwardTargetInput')?.value || '').trim();
        if (!raw) {
            notifications.warning('Укажите получателя');
            return;
        }

        // Compose forwarded text
        const from = (msg && msg.sender_username) ? msg.sender_username : 'unknown';
        const forwardText = `Переслано от ${from}:\n${contentText || ''}`;

        try {
            if (mode === 'direct') {
                // Resolve username -> user_id if needed
                let receiverId = raw;
                if (!/^[0-9a-fA-F-]{32,}$/.test(raw)) {
                    const r = await fetch(API_BASE + '/api/find-user', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token, username: raw.replace(/^@/, '') })
                    });
                    const d = await r.json();
                    if (!d.success || !d.user_id) {
                        notifications.error('Пользователь не найден');
                        return;
                    }
                    receiverId = d.user_id;
                }
                const r2 = await fetch(API_BASE + '/api/send-message', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token, receiver_id: receiverId, content: forwardText })
                });
                const d2 = await r2.json();
                if (!d2.success) {
                    notifications.error(d2.error || 'Ошибка пересылки');
                    return;
                }
            } else if (mode === 'group') {
                const r2 = await fetch('/api/send-group-message', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token, group_id: raw, content: forwardText, message_type: 'text' })
                });
                const d2 = await r2.json();
                if (!d2.success) {
                    notifications.error(d2.error || 'Ошибка пересылки');
                    return;
                }
            } else {
                const r2 = await fetch('/api/send-channel-message', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token, channel_id: raw, content: forwardText, message_type: 'text' })
                });
                const d2 = await r2.json();
                if (!d2.success) {
                    notifications.error(d2.error || 'Ошибка пересылки');
                    return;
                }
            }

            notifications.success('Сообщение переслано');
            close();
        } catch (err) {
            console.error('Forward error', err);
            notifications.error('Ошибка пересылки');
        }
    });
}

// Инициализация контекстного меню при загрузке
document.addEventListener('DOMContentLoaded', () => {
    setupMarketplace();
    setupIntegrations();
    setupSettingsTabs();

    // Click on chat header (name/avatar) opens profile of the current peer for direct chats
    const headerInfo = document.querySelector('.chat-header-info');
    if (headerInfo) {
        headerInfo.style.cursor = 'pointer';
        headerInfo.addEventListener('click', () => {
            try {
                if (window.channelsModule && window.channelsModule.isChannelActive && window.channelsModule.isChannelActive()) {
                    if (typeof window.channelsModule.openChannelInfoPanel === 'function') {
                        window.channelsModule.openChannelInfoPanel();
                    }
                    return;
                }
                if (window.groupsModule && window.groupsModule.isGroupActive && window.groupsModule.isGroupActive()) {
                    // Открываем настройки группы при клике на шапку
                    if (typeof window.groupsModule.openGroupSettings === 'function') {
                        window.groupsModule.openGroupSettings();
                    }
                    return;
                }
                if (currentChat && currentChat.id && typeof window.openUserProfile === 'function') {
                    window.openUserProfile({ user_id: currentChat.id });
                }
            } catch (_) {}
        });
    }
});

// ========== MARKETPLACE ==========
function setupMarketplace() {
    // Переключение вкладок
    const shopTabBtn = document.getElementById('shopTabBtn');
    if (shopTabBtn) {
        shopTabBtn.addEventListener('click', () => {
            loadShopProducts();
        });
    }

    // Кнопка добавления товара
    const addProductBtn = document.getElementById('addProductBtn');
    if (addProductBtn) {
        addProductBtn.addEventListener('click', () => {
            showAddProductModal();
        });
    }
}

async function loadShopProducts() {
    const shopProductsList = document.getElementById('shopProductsList');
    if (!shopProductsList) return;

    // Определяем текущий чат (группа или канал)
    let owner_chat_id = '';
    let owner_type = '';
    
    if (window.groupsModule && window.groupsModule.isGroupActive()) {
        const group = window.groupsModule.currentGroup();
        if (group) {
            owner_chat_id = group.id;
            owner_type = 'group';
        }
    } else if (window.channelsModule && window.channelsModule.isChannelActive()) {
        const channel = window.channelsModule.currentChannel();
        if (channel) {
            owner_chat_id = channel.id;
            owner_type = 'channel';
        }
    }

    if (!owner_chat_id || !owner_type) {
        shopProductsList.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-secondary); grid-column: 1 / -1;">Выберите группу или канал</div>';
        return;
    }

    try {
        const token = localStorage.getItem('xipher_token');
        const response = await fetch('/api/get-store-items', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                token,
                owner_chat_id,
                owner_type
            })
        });

        const data = await response.json();
        if (data.success && data.products) {
            renderShopProducts(data.products);
        } else {
            shopProductsList.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-secondary); grid-column: 1 / -1;">Товары не найдены</div>';
        }
    } catch (error) {
        console.error('Error loading shop products:', error);
        shopProductsList.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-secondary); grid-column: 1 / -1;">Ошибка загрузки товаров</div>';
    }
}

function renderShopProducts(products) {
    const shopProductsList = document.getElementById('shopProductsList');
    if (!shopProductsList) return;

    if (products.length === 0) {
        shopProductsList.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-secondary); grid-column: 1 / -1;">Товары отсутствуют</div>';
        return;
    }

    shopProductsList.innerHTML = products.map(product => `
        <div class="shop-product-card" data-product-id="${escapeHtml(product.id)}" style="background: var(--black-secondary); border-radius: 8px; padding: 1rem; border: 1px solid var(--border-color); cursor: pointer; transition: all 0.2s;">
            ${product.image_path ? `<img src="/files/${escapeHtml(product.image_path)}" style="width: 100%; height: 150px; object-fit: cover; border-radius: 6px; margin-bottom: 0.75rem;">` : '<div style="width: 100%; height: 150px; background: var(--black-tertiary); border-radius: 6px; margin-bottom: 0.75rem; display: flex; align-items: center; justify-content: center; color: var(--text-muted);">Нет изображения</div>'}
            <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem;">${escapeHtml(product.title)}</div>
            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.75rem; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">${escapeHtml(product.description || '')}</div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="font-weight: 700; color: var(--purple-primary);">${product.price_amount} ${escapeHtml(product.price_currency)}</div>
                <button class="btn-primary btn-small" onclick="purchaseProduct('${escapeHtml(product.id)}')">Купить</button>
            </div>
        </div>
    `).join('');
}

function showAddProductModal() {
    // TODO: Реализовать модальное окно для добавления товара
    notifications.info('Модальное окно добавления товара будет реализовано');
}

async function purchaseProduct(productId) {
    try {
        const token = localStorage.getItem('xipher_token');
        // TODO: Реализовать создание invoice через платежную систему
        const invoice_id = 'invoice_' + Date.now();
        
        const response = await fetch('/api/purchase-product', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                token,
                product_id: productId,
                invoice_id
            })
        });

        const data = await response.json();
        if (data.success) {
            notifications.success('Товар успешно куплен!');
            if (data.key_id) {
                notifications.info('Ключ отправлен в личные сообщения');
            }
        } else {
            notifications.error(data.error || 'Ошибка при покупке товара');
        }
    } catch (error) {
        console.error('Error purchasing product:', error);
        notifications.error('Ошибка при покупке товара');
    }
}

// ========== INTEGRATIONS ==========
function setupIntegrations() {
    const integrationsTabBtn = document.getElementById('integrationsTabBtn');
    if (integrationsTabBtn) {
        integrationsTabBtn.addEventListener('click', () => {
            loadIntegrations();
        });
    }

    // Обработчики для карточек интеграций
    document.querySelectorAll('.integration-card').forEach(card => {
        card.addEventListener('click', () => {
            const service = card.getAttribute('data-service');
            connectIntegration(service);
        });
    });
}

async function loadIntegrations() {
    const integrationsList = document.getElementById('integrationsList');
    if (!integrationsList) return;

    // Определяем текущий чат
    let owner_chat_id = '';
    let owner_type = '';
    
    if (window.groupsModule && window.groupsModule.isGroupActive()) {
        const group = window.groupsModule.currentGroup();
        if (group) {
            owner_chat_id = group.id;
            owner_type = 'group';
        }
    } else if (window.channelsModule && window.channelsModule.isChannelActive()) {
        const channel = window.channelsModule.currentChannel();
        if (channel) {
            owner_chat_id = channel.id;
            owner_type = 'channel';
        }
    }

    if (!owner_chat_id || !owner_type) {
        integrationsList.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-secondary);">Выберите группу или канал</div>';
        return;
    }

    try {
        const token = localStorage.getItem('xipher_token');
        const response = await fetch('/api/get-integrations', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                token,
                chat_id: owner_chat_id,
                chat_type: owner_type
            })
        });

        const data = await response.json();
        if (data.success && data.integrations) {
            renderIntegrations(data.integrations);
        } else {
            integrationsList.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-secondary);">Интеграции не найдены</div>';
        }
    } catch (error) {
        console.error('Error loading integrations:', error);
        integrationsList.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-secondary);">Ошибка загрузки интеграций</div>';
    }
}

function renderIntegrations(integrations) {
    const integrationsList = document.getElementById('integrationsList');
    if (!integrationsList) return;

    if (integrations.length === 0) {
        integrationsList.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-secondary);">Нет подключенных интеграций</div>';
        return;
    }

    integrationsList.innerHTML = integrations.map(integration => `
        <div class="integration-item" style="padding: 1rem; background: var(--black-secondary); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
            <div>
                <div style="font-weight: 600; color: var(--text-primary);">${escapeHtml(integration.service_name)}</div>
                <div style="font-size: 0.85rem; color: var(--text-secondary);">Подключено</div>
            </div>
            <button class="btn-secondary btn-small" onclick="disconnectIntegration('${escapeHtml(integration.id)}')">Отключить</button>
        </div>
    `).join('');
}

async function connectIntegration(serviceName) {
    // TODO: Реализовать OAuth flow
    notifications.info(`Подключение ${serviceName} будет реализовано через OAuth`);
}

// Handle inline keyboard button clicks
async function handleKeyboardButtonClick(button, message) {
    if (button.url) {
        if (!isValidUrl(button.url)) {
            notifications.error('Неверная ссылка');
            return;
        }
        let safeUrl = '';
        try {
            safeUrl = new URL(button.url, window.location.origin).href;
        } catch (e) {
            notifications.error('Неверная ссылка');
            return;
        }
        const opened = window.open(safeUrl, '_blank', 'noopener,noreferrer');
        if (opened) opened.opener = null;
        return;
    }
    
    if (button.callback_data) {
        // Send callback_query to bot
        try {
            const token = localStorage.getItem('xipher_token');
            const response = await fetch('/api/bot-callback-query', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    token,
                    message_id: message.id,
                    callback_data: button.callback_data,
                    from_user_id: currentUser?.id || ''
                })
            });
            
            const data = await response.json();
            if (data.success && data.response) {
                // Bot can return a response (e.g., alert, edit message, etc.)
                if (data.response.alert) {
                    notifications.info(data.response.alert);
                }
                // Update button state if needed
                if (data.response.update_message) {
                    // Reload messages to show updated state
                    loadMessages();
                }
            }
        } catch (error) {
            console.error('Error handling callback query:', error);
            notifications.error('Ошибка при обработке кнопки');
        }
    }
}

function handleReplyKeyboardButtonClick(button) {
    if (!button) return;

    if (button.request_location) {
        sendLocationMessage();
        if (replyKeyboardState.oneTime) {
            resetReplyKeyboardState();
        }
        return;
    }

    if (button.request_contact) {
        notifications.info('Запрос контакта пока не поддерживается');
        return;
    }

    const webAppUrl = button.web_app && button.web_app.url ? button.web_app.url : '';
    const urlToOpen = button.url || webAppUrl;
    if (urlToOpen) {
        if (!isValidUrl(urlToOpen)) {
            notifications.error('Неверная ссылка');
            return;
        }
        let safeUrl = '';
        try {
            safeUrl = new URL(urlToOpen, window.location.origin).href;
        } catch (e) {
            notifications.error('Неверная ссылка');
            return;
        }
        const opened = window.open(safeUrl, '_blank', 'noopener,noreferrer');
        if (opened) opened.opener = null;
        return;
    }

    const text = typeof button.text === 'string' ? button.text.trim() : '';
    if (!text) return;

    const input = document.getElementById('messageInput');
    if (!input) return;
    input.value = text;
    sendMessage();
    if (replyKeyboardState.oneTime) {
        resetReplyKeyboardState();
    }
}

async function disconnectIntegration(integrationId) {
    try {
        const token = localStorage.getItem('xipher_token');
        const response = await fetch('/api/delete-integration', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                token,
                integration_id: integrationId
            })
        });

        const data = await response.json();
        if (data.success) {
            notifications.success('Интеграция отключена');
            loadIntegrations();
        } else {
            notifications.error(data.error || 'Ошибка при отключении интеграции');
        }
    } catch (error) {
        console.error('Error disconnecting integration:', error);
        notifications.error('Ошибка при отключении интеграции');
    }
}

// ========== SETTINGS TABS ==========
function setupSettingsTabs() {
    const settingsTabs = document.querySelectorAll('.settings-tab');
    settingsTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const tabName = tab.getAttribute('data-tab');
            
            // Убираем активный класс у всех вкладок
            settingsTabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            // Скрываем все контенты
            document.querySelectorAll('.settings-tab-content').forEach(content => {
                content.style.display = 'none';
                content.classList.remove('active');
            });
            
            // Показываем нужный контент
            const targetContent = document.getElementById(`settingsTab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
            if (targetContent) {
                targetContent.style.display = 'block';
                targetContent.classList.add('active');
            }
        });
    });
}
